/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@mapbox/fusspot/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@mapbox/fusspot/lib/index.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/**
 * Validators are functions which assert certain type.
 * They can return a string which can then be used
 * to display a helpful error message.
 * They can also return a function for a custom error message.
 */

var isPlainObject = __webpack_require__(/*! is-plain-obj */ "./node_modules/is-plain-obj/index.js");

var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var DEFAULT_ERROR_PATH = 'value';
var NEWLINE_INDENT = '\n  ';
var v = {};
/**
 * Runners
 *
 * Take root validators and run assertion
 */

v.assert = function (rootValidator, options) {
  options = options || {};
  return function (value) {
    var message = validate(rootValidator, value); // all good

    if (!message) {
      return;
    }

    var errorMessage = processMessage(message, options);

    if (options.apiName) {
      errorMessage = options.apiName + ': ' + errorMessage;
    }

    throw new Error(errorMessage);
  };
};
/**
 * Higher Order Validators
 *
 * validators which take other validators as input
 * and output a new validator
 */


v.shape = function shape(validatorObj) {
  var validators = objectEntries(validatorObj);
  return function shapeValidator(value) {
    var validationResult = validate(v.plainObject, value);

    if (validationResult) {
      return validationResult;
    }

    var key, validator;
    var errorMessages = [];

    for (var i = 0; i < validators.length; i++) {
      key = validators[i].key;
      validator = validators[i].value;
      validationResult = validate(validator, value[key]);

      if (validationResult) {
        // return [key].concat(validationResult);
        errorMessages.push([key].concat(validationResult));
      }
    }

    if (errorMessages.length < 2) {
      return errorMessages[0];
    } // enumerate all the error messages


    return function (options) {
      errorMessages = errorMessages.map(function (message) {
        var key = message[0];
        var renderedMessage = processMessage(message, options).split('\n').join(NEWLINE_INDENT); // indents any inner nesting

        return '- ' + key + ': ' + renderedMessage;
      });
      var objectId = options.path.join('.');
      var ofPhrase = objectId === DEFAULT_ERROR_PATH ? '' : ' of ' + objectId;
      return 'The following properties' + ofPhrase + ' have invalid values:' + NEWLINE_INDENT + errorMessages.join(NEWLINE_INDENT);
    };
  };
};

v.strictShape = function strictShape(validatorObj) {
  var shapeValidator = v.shape(validatorObj);
  return function strictShapeValidator(value) {
    var shapeResult = shapeValidator(value);

    if (shapeResult) {
      return shapeResult;
    }

    var invalidKeys = Object.keys(value).reduce(function (memo, valueKey) {
      if (validatorObj[valueKey] === undefined) {
        memo.push(valueKey);
      }

      return memo;
    }, []);

    if (invalidKeys.length !== 0) {
      return function () {
        return 'The following keys are invalid: ' + invalidKeys.join(', ');
      };
    }
  };
};

v.arrayOf = function arrayOf(validator) {
  return createArrayValidator(validator);
};

v.tuple = function tuple() {
  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  return createArrayValidator(validators);
}; // Currently array validation fails when the first invalid item is found.


function createArrayValidator(validators) {
  var validatingTuple = Array.isArray(validators);

  var getValidator = function (index) {
    if (validatingTuple) {
      return validators[index];
    }

    return validators;
  };

  return function arrayValidator(value) {
    var validationResult = validate(v.plainArray, value);

    if (validationResult) {
      return validationResult;
    }

    if (validatingTuple && value.length !== validators.length) {
      return 'an array with ' + validators.length + ' items';
    }

    for (var i = 0; i < value.length; i++) {
      validationResult = validate(getValidator(i), value[i]);

      if (validationResult) {
        return [i].concat(validationResult);
      }
    }
  };
}

v.required = function required(validator) {
  function requiredValidator(value) {
    if (value == null) {
      return function (options) {
        return formatErrorMessage(options, isArrayCulprit(options.path) ? 'cannot be undefined/null.' : 'is required.');
      };
    }

    return validator.apply(this, arguments);
  }

  requiredValidator.__required = true;
  return requiredValidator;
};

v.oneOfType = function oneOfType() {
  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  return function oneOfTypeValidator(value) {
    var messages = validators.map(function (validator) {
      return validate(validator, value);
    }).filter(Boolean); // If we don't have as many messages as no. of validators,
    // then at least one validator was ok with the value.

    if (messages.length !== validators.length) {
      return;
    } // check primitive type


    if (messages.every(function (message) {
      return message.length === 1 && typeof message[0] === 'string';
    })) {
      return orList(messages.map(function (m) {
        return m[0];
      }));
    } // Complex oneOfTypes like
    // `v.oneOftypes(v.shape({name: v.string})`, `v.shape({name: v.number}))`
    // are complex ¯\_(ツ)_/¯. For the current scope only returning the longest message.


    return messages.reduce(function (max, arr) {
      return arr.length > max.length ? arr : max;
    });
  };
};
/**
 * Meta Validators
 * which take options as argument (not validators)
 * and return a new primitive validator
 */


v.equal = function equal(compareWith) {
  return function equalValidator(value) {
    if (value !== compareWith) {
      return JSON.stringify(compareWith);
    }
  };
};

v.oneOf = function oneOf() {
  var options = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  var validators = options.map(function (value) {
    return v.equal(value);
  });
  return v.oneOfType.apply(this, validators);
};

v.range = function range(compareWith) {
  var min = compareWith[0];
  var max = compareWith[1];
  return function rangeValidator(value) {
    var validationResult = validate(v.number, value);

    if (validationResult || value < min || value > max) {
      return 'number between ' + min + ' & ' + max + ' (inclusive)';
    }
  };
};
/**
 * Primitive validators
 *
 * simple validators which return a string or undefined
 */


v.any = function any() {
  return;
};

v.boolean = function boolean(value) {
  if (typeof value !== 'boolean') {
    return 'boolean';
  }
};

v.number = function number(value) {
  if (typeof value !== 'number') {
    return 'number';
  }
};

v.plainArray = function plainArray(value) {
  if (!Array.isArray(value)) {
    return 'array';
  }
};

v.plainObject = function plainObject(value) {
  if (!isPlainObject(value)) {
    return 'object';
  }
};

v.string = function string(value) {
  if (typeof value !== 'string') {
    return 'string';
  }
};

v.func = function func(value) {
  if (typeof value !== 'function') {
    return 'function';
  }
};

function validate(validator, value) {
  // assertions are optional by default unless wrapped in v.require
  if (value == null && !validator.hasOwnProperty('__required')) {
    return;
  }

  var result = validator(value);

  if (result) {
    return Array.isArray(result) ? result : [result];
  }
}

function processMessage(message, options) {
  // message array follows the convention
  // [...path, result]
  // path is an array of object keys / array indices
  // result is output of the validator
  var len = message.length;
  var result = message[len - 1];
  var path = message.slice(0, len - 1);

  if (path.length === 0) {
    path = [DEFAULT_ERROR_PATH];
  }

  options = xtend(options, {
    path: path
  });
  return typeof result === 'function' ? result(options) // allows customization of result
  : formatErrorMessage(options, prettifyResult(result));
}

function orList(list) {
  if (list.length < 2) {
    return list[0];
  }

  if (list.length === 2) {
    return list.join(' or ');
  }

  return list.slice(0, -1).join(', ') + ', or ' + list.slice(-1);
}

function prettifyResult(result) {
  return 'must be ' + addArticle(result) + '.';
}

function addArticle(nounPhrase) {
  if (/^an? /.test(nounPhrase)) {
    return nounPhrase;
  }

  if (/^[aeiou]/i.test(nounPhrase)) {
    return 'an ' + nounPhrase;
  }

  if (/^[a-z]/i.test(nounPhrase)) {
    return 'a ' + nounPhrase;
  }

  return nounPhrase;
}

function formatErrorMessage(options, prettyResult) {
  var arrayCulprit = isArrayCulprit(options.path);
  var output = options.path.join('.') + ' ' + prettyResult;
  var prepend = arrayCulprit ? 'Item at position ' : '';
  return prepend + output;
}

function isArrayCulprit(path) {
  return typeof path[path.length - 1] == 'number' || typeof path[0] == 'number';
}

function objectEntries(obj) {
  return Object.keys(obj || {}).map(function (key) {
    return {
      key: key,
      value: obj[key]
    };
  });
}

v.validate = validate;
v.processMessage = processMessage;
module.exports = v;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var client = __webpack_require__(/*! ./lib/client */ "./node_modules/@mapbox/mapbox-sdk/lib/browser/browser-client.js");

module.exports = client;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/browser/browser-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/browser/browser-client.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var browser = __webpack_require__(/*! ./browser-layer */ "./node_modules/@mapbox/mapbox-sdk/lib/browser/browser-layer.js");

var MapiClient = __webpack_require__(/*! ../classes/mapi-client */ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-client.js");

function BrowserClient(options) {
  MapiClient.call(this, options);
}

BrowserClient.prototype = Object.create(MapiClient.prototype);
BrowserClient.prototype.constructor = BrowserClient;
BrowserClient.prototype.sendRequest = browser.browserSend;
BrowserClient.prototype.abortRequest = browser.browserAbort;
/**
 * Create a client for the browser.
 *
 * @param {Object} options
 * @param {string} options.accessToken
 * @param {string} [options.origin]
 * @returns {MapiClient}
 */

function createBrowserClient(options) {
  return new BrowserClient(options);
}

module.exports = createBrowserClient;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/browser/browser-layer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/browser/browser-layer.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var MapiResponse = __webpack_require__(/*! ../classes/mapi-response */ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-response.js");

var MapiError = __webpack_require__(/*! ../classes/mapi-error */ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-error.js");

var constants = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-sdk/lib/constants.js");

var parseHeaders = __webpack_require__(/*! ../helpers/parse-headers */ "./node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-headers.js"); // Keys are request IDs, values are XHRs.


var requestsUnderway = {};

function browserAbort(request) {
  var xhr = requestsUnderway[request.id];
  if (!xhr) return;
  xhr.abort();
  delete requestsUnderway[request.id];
}

function createResponse(request, xhr) {
  return new MapiResponse(request, {
    body: xhr.response,
    headers: parseHeaders(xhr.getAllResponseHeaders()),
    statusCode: xhr.status
  });
}

function normalizeBrowserProgressEvent(event) {
  var total = event.total;
  var transferred = event.loaded;
  var percent = 100 * transferred / total;
  return {
    total: total,
    transferred: transferred,
    percent: percent
  };
}

function sendRequestXhr(request, xhr) {
  return new Promise(function (resolve, reject) {
    xhr.onprogress = function (event) {
      request.emitter.emit(constants.EVENT_PROGRESS_DOWNLOAD, normalizeBrowserProgressEvent(event));
    };

    var file = request.file;

    if (file) {
      xhr.upload.onprogress = function (event) {
        request.emitter.emit(constants.EVENT_PROGRESS_UPLOAD, normalizeBrowserProgressEvent(event));
      };
    }

    xhr.onerror = function (error) {
      reject(error);
    };

    xhr.onabort = function () {
      var mapiError = new MapiError({
        request: request,
        type: constants.ERROR_REQUEST_ABORTED
      });
      reject(mapiError);
    };

    xhr.onload = function () {
      delete requestsUnderway[request.id];

      if (xhr.status < 200 || xhr.status >= 400) {
        var mapiError = new MapiError({
          request: request,
          body: xhr.response,
          statusCode: xhr.status
        });
        reject(mapiError);
        return;
      }

      resolve(xhr);
    };

    var body = request.body; // matching service needs to send a www-form-urlencoded request

    if (typeof body === 'string') {
      xhr.send(body);
    } else if (body) {
      xhr.send(JSON.stringify(body));
    } else if (file) {
      xhr.send(file);
    } else {
      xhr.send();
    }

    requestsUnderway[request.id] = xhr;
  }).then(function (xhr) {
    return createResponse(request, xhr);
  });
} // The accessToken argument gives this function flexibility
// for Mapbox's internal client.


function createRequestXhr(request, accessToken) {
  var url = request.url(accessToken);
  var xhr = new window.XMLHttpRequest();
  xhr.open(request.method, url);
  Object.keys(request.headers).forEach(function (key) {
    xhr.setRequestHeader(key, request.headers[key]);
  });
  return xhr;
}

function browserSend(request) {
  return Promise.resolve().then(function () {
    var xhr = createRequestXhr(request, request.client.accessToken);
    return sendRequestXhr(request, xhr);
  });
}

module.exports = {
  browserAbort: browserAbort,
  sendRequestXhr: sendRequestXhr,
  browserSend: browserSend,
  createRequestXhr: createRequestXhr
};

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-client.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-client.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var parseToken = __webpack_require__(/*! @mapbox/parse-mapbox-token */ "./node_modules/@mapbox/parse-mapbox-token/index.js");

var MapiRequest = __webpack_require__(/*! ./mapi-request */ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-request.js");

var constants = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-sdk/lib/constants.js");
/**
 * A low-level Mapbox API client. Use it to create service clients
 * that share the same configuration.
 *
 * Services and `MapiRequest`s use the underlying `MapiClient` to
 * determine how to create, send, and abort requests in a way
 * that is appropriate to the configuration and environment
 * (Node or the browser).
 *
 * @class MapiClient
 * @property {string} accessToken - The Mapbox access token assigned
 *   to this client.
 * @property {string} [origin] - The origin
 *   to use for API requests. Defaults to https://api.mapbox.com.
 */


function MapiClient(options) {
  if (!options || !options.accessToken) {
    throw new Error('Cannot create a client without an access token');
  } // Try parsing the access token to determine right away if it's valid.


  parseToken(options.accessToken);
  this.accessToken = options.accessToken;
  this.origin = options.origin || constants.API_ORIGIN;
}

MapiClient.prototype.createRequest = function createRequest(requestOptions) {
  return new MapiRequest(this, requestOptions);
};

module.exports = MapiClient;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-error.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-error.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-sdk/lib/constants.js");
/**
 * A Mapbox API error.
 *
 * If there's an error during the API transaction,
 * the Promise returned by `MapiRequest`'s [`send`](#send)
 * method should reject with a `MapiError`.
 *
 * @class MapiError
 * @hideconstructor
 * @property {MapiRequest} request - The errored request.
 * @property {string} type - The type of error. Usually this is `'HttpError'`.
 *   If the request was aborted, so the error was
 *   not sent from the server, the type will be
 *   `'RequestAbortedError'`.
 * @property {number} [statusCode] - The numeric status code of
 *   the HTTP response.
 * @property {Object | string} [body] - If the server sent a response body,
 *   this property exposes that response, parsed as JSON if possible.
 * @property {string} [message] - Whatever message could be derived from the
 *   call site and HTTP response.
 *
 * @param {MapiRequest} options.request
 * @param {number} [options.statusCode]
 * @param {string} [options.body]
 * @param {string} [options.message]
 * @param {string} [options.type]
 */


function MapiError(options) {
  var errorType = options.type || constants.ERROR_HTTP;
  var body;

  if (options.body) {
    try {
      body = JSON.parse(options.body);
    } catch (e) {
      body = options.body;
    }
  } else {
    body = null;
  }

  var message = options.message || null;

  if (!message) {
    if (typeof body === 'string') {
      message = body;
    } else if (body && typeof body.message === 'string') {
      message = body.message;
    } else if (errorType === constants.ERROR_REQUEST_ABORTED) {
      message = 'Request aborted';
    }
  }

  this.message = message;
  this.type = errorType;
  this.statusCode = options.statusCode || null;
  this.request = options.request;
  this.body = body;
}

module.exports = MapiError;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-request.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-request.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var parseToken = __webpack_require__(/*! @mapbox/parse-mapbox-token */ "./node_modules/@mapbox/parse-mapbox-token/index.js");

var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");

var urlUtils = __webpack_require__(/*! ../helpers/url-utils */ "./node_modules/@mapbox/mapbox-sdk/lib/helpers/url-utils.js");

var constants = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-sdk/lib/constants.js");

var requestId = 1;
/**
 * A Mapbox API request.
 *
 * Note that creating a `MapiRequest` does *not* send the request automatically.
 * Use the request's `send` method to send it off and get a `Promise`.
 *
 * The `emitter` property is an `EventEmitter` that emits the following events:
 *
 * - `'response'` - Listeners will be called with a `MapiResponse`.
 * - `'error'` - Listeners will be called with a `MapiError`.
 * - `'downloadProgress'` - Listeners will be called with `ProgressEvents`.
 * - `'uploadProgress'` - Listeners will be called with `ProgressEvents`.
 *   Upload events are only available when the request includes a file.
 *
 * @class MapiRequest
 * @property {EventEmitter} emitter - An event emitter. See above.
 * @property {MapiClient} client - This request's `MapiClient`.
 * @property {MapiResponse|null} response - If this request has been sent and received
 *   a response, the response is available on this property.
 * @property {MapiError|Error|null} error - If this request has been sent and
 *   received an error in response, the error is available on this property.
 * @property {boolean} aborted - If the request has been aborted
 *   (via [`abort`](#abort)), this property will be `true`.
 * @property {boolean} sent - If the request has been sent, this property will
 *   be `true`. You cannot send the same request twice, so if you need to create
 *   a new request that is the equivalent of an existing one, use
 *   [`clone`](#clone).
 * @property {string} path - The request's path, including colon-prefixed route
 *   parameters.
 * @property {string} origin - The request's origin.
 * @property {string} method - The request's HTTP method.
 * @property {Object} query - A query object, which will be transformed into
 *   a URL query string.
 * @property {Object} params - A route parameters object, whose values will
 *   be interpolated the path.
 * @property {Object} headers - The request's headers.
 * @property {Object|string|null} body - Data to send with the request.
 *   If the request has a body, it will also be sent with the header
 *   `'Content-Type: application/json'`.
 * @property {Blob|ArrayBuffer|string|ReadStream} file - A file to
 *   send with the request. The browser client accepts Blobs and ArrayBuffers;
 *   the Node client accepts strings (filepaths) and ReadStreams.
 * @property {string} encoding - The encoding of the response.
 * @property {string} sendFileAs - The method to send the `file`. Options are
 *   `data` (x-www-form-urlencoded) or `form` (multipart/form-data).
 */

/**
 * @ignore
 * @param {MapiClient} client
 * @param {Object} options
 * @param {string} options.method
 * @param {string} options.path
 * @param {Object} [options.query={}]
 * @param {Object} [options.params={}]
 * @param {string} [options.origin]
 * @param {Object} [options.headers]
 * @param {Object} [options.body=null]
 * @param {Blob|ArrayBuffer|string|ReadStream} [options.file=null]
 * @param {string} [options.encoding=utf8]
 */

function MapiRequest(client, options) {
  if (!client) {
    throw new Error('MapiRequest requires a client');
  }

  if (!options || !options.path || !options.method) {
    throw new Error('MapiRequest requires an options object with path and method properties');
  }

  var defaultHeaders = {};

  if (options.body) {
    defaultHeaders['content-type'] = 'application/json';
  }

  var headersWithDefaults = xtend(defaultHeaders, options.headers); // Disallows duplicate header names of mixed case,
  // e.g. Content-Type and content-type.

  var headers = Object.keys(headersWithDefaults).reduce(function (memo, name) {
    memo[name.toLowerCase()] = headersWithDefaults[name];
    return memo;
  }, {});
  this.id = requestId++;
  this._options = options;
  this.emitter = new EventEmitter();
  this.client = client;
  this.response = null;
  this.error = null;
  this.sent = false;
  this.aborted = false;
  this.path = options.path;
  this.method = options.method;
  this.origin = options.origin || client.origin;
  this.query = options.query || {};
  this.params = options.params || {};
  this.body = options.body || null;
  this.file = options.file || null;
  this.encoding = options.encoding || 'utf8';
  this.sendFileAs = options.sendFileAs || null;
  this.headers = headers;
}
/**
 * Get the URL of the request.
 *
 * @param {string} [accessToken] - By default, the access token of the request's
 *   client is used.
 * @return {string}
 */


MapiRequest.prototype.url = function url(accessToken) {
  var url = urlUtils.prependOrigin(this.path, this.origin);
  url = urlUtils.appendQueryObject(url, this.query);
  var routeParams = this.params;
  var actualAccessToken = accessToken == null ? this.client.accessToken : accessToken;

  if (actualAccessToken) {
    url = urlUtils.appendQueryParam(url, 'access_token', actualAccessToken);
    var accessTokenOwnerId = parseToken(actualAccessToken).user;
    routeParams = xtend({
      ownerId: accessTokenOwnerId
    }, routeParams);
  }

  url = urlUtils.interpolateRouteParams(url, routeParams);
  return url;
};
/**
 * Send the request. Returns a Promise that resolves with a `MapiResponse`.
 * You probably want to use `response.body`.
 *
 * `send` only retrieves the first page of paginated results. You can get
 * the next page by using the `MapiResponse`'s [`nextPage`](#nextpage)
 * function, or iterate through all pages using [`eachPage`](#eachpage)
 * instead of `send`.
 *
 * @returns {Promise<MapiResponse>}
 */


MapiRequest.prototype.send = function send() {
  var self = this;

  if (self.sent) {
    throw new Error('This request has already been sent. Check the response and error properties. Create a new request with clone().');
  }

  self.sent = true;
  return self.client.sendRequest(self).then(function (response) {
    self.response = response;
    self.emitter.emit(constants.EVENT_RESPONSE, response);
    return response;
  }, function (error) {
    self.error = error;
    self.emitter.emit(constants.EVENT_ERROR, error);
    throw error;
  });
};
/**
 * Abort the request.
 *
 * Any pending `Promise` returned by [`send`](#send) will be rejected with
 * an error with `type: 'RequestAbortedError'`. If you've created a request
 * that might be aborted, you need to catch and handle such errors.
 *
 * This method will also abort any requests created while fetching subsequent
 * pages via [`eachPage`](#eachpage).
 *
 * If the request has not been sent or has already been aborted, nothing
 * will happen.
 */


MapiRequest.prototype.abort = function abort() {
  if (this._nextPageRequest) {
    this._nextPageRequest.abort();

    delete this._nextPageRequest;
  }

  if (this.response || this.error || this.aborted) return;
  this.aborted = true;
  this.client.abortRequest(this);
};
/**
 * Invoke a callback for each page of a paginated API response.
 *
 * The callback should have the following signature:
 *
 * ```js
 * (
 *   error: MapiError,
 *   response: MapiResponse,
 *   next: () => void
 * ) => void
 * ```
 *
 * **The next page will not be fetched until you've invoked the
 * `next` callback**, indicating that you're ready for it.
 *
 * @param {Function} callback
 */


MapiRequest.prototype.eachPage = function eachPage(callback) {
  var self = this;

  function handleResponse(response) {
    function getNextPage() {
      delete self._nextPageRequest;
      var nextPageRequest = response.nextPage();

      if (nextPageRequest) {
        self._nextPageRequest = nextPageRequest;
        getPage(nextPageRequest);
      }
    }

    callback(null, response, getNextPage);
  }

  function handleError(error) {
    callback(error, null, function () {});
  }

  function getPage(request) {
    request.send().then(handleResponse, handleError);
  }

  getPage(this);
};
/**
 * Clone this request.
 *
 * Each request can only be sent *once*. So if you'd like to send the
 * same request again, clone it and send away.
 *
 * @returns {MapiRequest} - A new `MapiRequest` configured just like this one.
 */


MapiRequest.prototype.clone = function clone() {
  return this._extend();
};
/**
 * @ignore
 */


MapiRequest.prototype._extend = function _extend(options) {
  var extendedOptions = xtend(this._options, options);
  return new MapiRequest(this.client, extendedOptions);
};

module.exports = MapiRequest;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-response.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-response.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var parseLinkHeader = __webpack_require__(/*! ../helpers/parse-link-header */ "./node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-link-header.js");
/**
 * A Mapbox API response.
 *
 * @class MapiResponse
 * @property {Object} body - The response body, parsed as JSON.
 * @property {string} rawBody - The raw response body.
 * @property {number} statusCode - The response's status code.
 * @property {Object} headers - The parsed response headers.
 * @property {Object} links - The parsed response links.
 * @property {MapiRequest} request - The response's originating `MapiRequest`.
 */

/**
 * @ignore
 * @param {MapiRequest} request
 * @param {Object} responseData
 * @param {Object} responseData.headers
 * @param {string} responseData.body
 * @param {number} responseData.statusCode
 */


function MapiResponse(request, responseData) {
  this.request = request;
  this.headers = responseData.headers;
  this.rawBody = responseData.body;
  this.statusCode = responseData.statusCode;

  try {
    this.body = JSON.parse(responseData.body || '{}');
  } catch (parseError) {
    this.body = responseData.body;
  }

  this.links = parseLinkHeader(this.headers.link);
}
/**
 * Check if there is a next page that you can fetch.
 *
 * @returns {boolean}
 */


MapiResponse.prototype.hasNextPage = function hasNextPage() {
  return !!this.links.next;
};
/**
 * Create a request for the next page, if there is one.
 * If there is no next page, returns `null`.
 *
 * @returns {MapiRequest | null}
 */


MapiResponse.prototype.nextPage = function nextPage() {
  if (!this.hasNextPage()) return null;
  return this.request._extend({
    path: this.links.next.url
  });
};

module.exports = MapiResponse;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/constants.js ***!
  \**********************************************************/
/***/ (function(module) {

"use strict";


module.exports = {
  API_ORIGIN: 'https://api.mapbox.com',
  EVENT_PROGRESS_DOWNLOAD: 'downloadProgress',
  EVENT_PROGRESS_UPLOAD: 'uploadProgress',
  EVENT_ERROR: 'error',
  EVENT_RESPONSE: 'response',
  ERROR_HTTP: 'HttpError',
  ERROR_REQUEST_ABORTED: 'RequestAbortedError'
};

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-headers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-headers.js ***!
  \**********************************************************************/
/***/ (function(module) {

"use strict";


function parseSingleHeader(raw) {
  var boundary = raw.indexOf(':');
  var name = raw.substring(0, boundary).trim().toLowerCase();
  var value = raw.substring(boundary + 1).trim();
  return {
    name: name,
    value: value
  };
}
/**
 * Parse raw headers into an object with lowercase properties.
 * Does not fully parse headings into more complete data structure,
 * as larger libraries might do. Also does not deal with duplicate
 * headers because Node doesn't seem to deal with those well, so
 * we shouldn't let the browser either, for consistency.
 *
 * @param {string} raw
 * @returns {Object}
 */


function parseHeaders(raw) {
  var headers = {};

  if (!raw) {
    return headers;
  }

  raw.trim().split(/[\r|\n]+/).forEach(function (rawHeader) {
    var parsed = parseSingleHeader(rawHeader);
    headers[parsed.name] = parsed.value;
  });
  return headers;
}

module.exports = parseHeaders;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-link-header.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-link-header.js ***!
  \**************************************************************************/
/***/ (function(module) {

"use strict";
 // Like https://github.com/thlorenz/lib/parse-link-header but without any
// additional dependencies.

function parseParam(param) {
  var parts = param.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
  if (!parts) return null;
  return {
    key: parts[1],
    value: parts[2]
  };
}

function parseLink(link) {
  var parts = link.match(/<?([^>]*)>(.*)/);
  if (!parts) return null;
  var linkUrl = parts[1];
  var linkParams = parts[2].split(';');
  var rel = null;
  var parsedLinkParams = linkParams.reduce(function (result, param) {
    var parsed = parseParam(param);
    if (!parsed) return result;

    if (parsed.key === 'rel') {
      if (!rel) {
        rel = parsed.value;
      }

      return result;
    }

    result[parsed.key] = parsed.value;
    return result;
  }, {});
  if (!rel) return null;
  return {
    url: linkUrl,
    rel: rel,
    params: parsedLinkParams
  };
}
/**
 * Parse a Link header.
 *
 * @param {string} linkHeader
 * @returns {{
 *   [string]: {
 *     url: string,
 *     params: { [string]: string }
 *   }
 * }}
 */


function parseLinkHeader(linkHeader) {
  if (!linkHeader) return {};
  return linkHeader.split(/,\s*</).reduce(function (result, link) {
    var parsed = parseLink(link);
    if (!parsed) return result; // rel value can be multiple whitespace-separated rels.

    var splitRel = parsed.rel.split(/\s+/);
    splitRel.forEach(function (rel) {
      if (!result[rel]) {
        result[rel] = {
          url: parsed.url,
          params: parsed.params
        };
      }
    });
    return result;
  }, {});
}

module.exports = parseLinkHeader;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/lib/helpers/url-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/lib/helpers/url-utils.js ***!
  \******************************************************************/
/***/ (function(module) {

"use strict";
 // Encode each item of an array individually. The comma
// delimiters should not themselves be encoded.

function encodeArray(arrayValue) {
  return arrayValue.map(encodeURIComponent).join(',');
}

function encodeValue(value) {
  if (Array.isArray(value)) {
    return encodeArray(value);
  }

  return encodeURIComponent(String(value));
}
/**
 * Append a query parameter to a URL.
 *
 * @param {string} url
 * @param {string} key
 * @param {string|number|boolean|Array<*>>} [value] - Provide an array
 *   if the value is a list and commas between values need to be
 *   preserved, unencoded.
 * @returns {string} - Modified URL.
 */


function appendQueryParam(url, key, value) {
  if (value === false || value === null) {
    return url;
  }

  var punctuation = /\?/.test(url) ? '&' : '?';
  var query = encodeURIComponent(key);

  if (value !== undefined && value !== '' && value !== true) {
    query += '=' + encodeValue(value);
  }

  return '' + url + punctuation + query;
}
/**
 * Derive a query string from an object and append it
 * to a URL.
 *
 * @param {string} url
 * @param {Object} [queryObject] - Values should be primitives.
 * @returns {string} - Modified URL.
 */


function appendQueryObject(url, queryObject) {
  if (!queryObject) {
    return url;
  }

  var result = url;
  Object.keys(queryObject).forEach(function (key) {
    var value = queryObject[key];

    if (value === undefined) {
      return;
    }

    if (Array.isArray(value)) {
      value = value.filter(function (v) {
        return v !== null && v !== undefined;
      }).join(',');
    }

    result = appendQueryParam(result, key, value);
  });
  return result;
}
/**
 * Prepend an origin to a URL. If the URL already has an
 * origin, do nothing.
 *
 * @param {string} url
 * @param {string} origin
 * @returns {string} - Modified URL.
 */


function prependOrigin(url, origin) {
  if (!origin) {
    return url;
  }

  if (url.slice(0, 4) === 'http') {
    return url;
  }

  var delimiter = url[0] === '/' ? '' : '/';
  return '' + origin.replace(/\/$/, '') + delimiter + url;
}
/**
 * Interpolate values into a route with express-style,
 * colon-prefixed route parameters.
 *
 * @param {string} route
 * @param {Object} [params] - Values should be primitives
 *   or arrays of primitives. Provide an array if the value
 *   is a list and commas between values need to be
 *   preserved, unencoded.
 * @returns {string} - Modified URL.
 */


function interpolateRouteParams(route, params) {
  if (!params) {
    return route;
  }

  return route.replace(/\/:([a-zA-Z0-9]+)/g, function (_, paramId) {
    var value = params[paramId];

    if (value === undefined) {
      throw new Error('Unspecified route parameter ' + paramId);
    }

    var preppedValue = encodeValue(value);
    return '/' + preppedValue;
  });
}

module.exports = {
  appendQueryObject: appendQueryObject,
  appendQueryParam: appendQueryParam,
  prependOrigin: prependOrigin,
  interpolateRouteParams: interpolateRouteParams
};

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/services/geocoding.js":
/*!***************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/services/geocoding.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var v = __webpack_require__(/*! ./service-helpers/validator */ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/validator.js");

var pick = __webpack_require__(/*! ./service-helpers/pick */ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/pick.js");

var stringifyBooleans = __webpack_require__(/*! ./service-helpers/stringify-booleans */ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/stringify-booleans.js");

var createServiceFactory = __webpack_require__(/*! ./service-helpers/create-service-factory */ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/create-service-factory.js");
/**
 * Geocoding API service.
 *
 * Learn more about this service and its responses in
 * [the HTTP service documentation](https://docs.mapbox.com/api/search/#geocoding).
 */


var Geocoding = {};
var featureTypes = ['country', 'region', 'postcode', 'district', 'place', 'locality', 'neighborhood', 'address', 'poi', 'poi.landmark'];
/**
 * Search for a place.
 *
 * See the [public documentation](https://docs.mapbox.com/api/search/#forward-geocoding).
 *
 * @param {Object} config
 * @param {string} config.query - A place name.
 * @param {'mapbox.places'|'mapbox.places-permanent'} [config.mode="mapbox.places"] - Either `mapbox.places` for ephemeral geocoding, or `mapbox.places-permanent` for storing results and batch geocoding.
 * @param {Array<string>} [config.countries] - Limits results to the specified countries.
 *   Each item in the array should be an [ISO 3166 alpha 2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
 * @param {Coordinates|'ip'} [config.proximity] - Bias local results based on a provided coordinate location or a user's IP address.
 * @param {Array<'country'|'region'|'postcode'|'district'|'place'|'locality'|'neighborhood'|'address'|'poi'|'poi.landmark'>} [config.types] - Filter results by feature types.
 * @param {boolean} [config.autocomplete=true] - Return autocomplete results or not.
 * @param {BoundingBox} [config.bbox] - Limit results to a bounding box.
 * @param {number} [config.limit=5] - Limit the number of results returned.
 * @param {Array<string>} [config.language] - Specify the language to use for response text and, for forward geocoding, query result weighting.
 *  Options are [IETF language tags](https://en.wikipedia.org/wiki/IETF_language_tag) comprised of a mandatory
 *  [ISO 639-1 language code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) and optionally one or more IETF subtags for country or script.
 * @param {boolean} [config.routing=false] - Specify whether to request additional metadata about the recommended navigation destination. Only applicable for address features.
 * @param {boolean} [config.fuzzyMatch=true] - Specify whether the Geocoding API should attempt approximate, as well as exact, matching.
 * @param {String} [config.worldview="us"] - Filter results to geographic features whose characteristics are defined differently by audiences belonging to various regional, cultural, or political groups.
 * @return {MapiRequest}
 *
 * @example
 * geocodingClient.forwardGeocode({
 *   query: 'Paris, France',
 *   limit: 2
 * })
 *   .send()
 *   .then(response => {
 *     const match = response.body;
 *   });
 *
 * @example
 * // geocoding with proximity
 * geocodingClient.forwardGeocode({
 *   query: 'Paris, France',
 *   proximity: [-95.4431142, 33.6875431]
 * })
 *   .send()
 *   .then(response => {
 *     const match = response.body;
 *   });
 *
 * // geocoding with countries
 * geocodingClient.forwardGeocode({
 *   query: 'Paris, France',
 *   countries: ['fr']
 * })
 *   .send()
 *   .then(response => {
 *     const match = response.body;
 *   });
 *
 * // geocoding with bounding box
 * geocodingClient.forwardGeocode({
 *   query: 'Paris, France',
 *   bbox: [2.14, 48.72, 2.55, 48.96]
 * })
 *   .send()
 *   .then(response => {
 *     const match = response.body;
 *   });
 */

Geocoding.forwardGeocode = function (config) {
  v.assertShape({
    query: v.required(v.string),
    mode: v.oneOf('mapbox.places', 'mapbox.places-permanent'),
    countries: v.arrayOf(v.string),
    proximity: v.oneOf(v.coordinates, 'ip'),
    types: v.arrayOf(v.oneOf(featureTypes)),
    autocomplete: v.boolean,
    bbox: v.arrayOf(v.number),
    limit: v.number,
    language: v.arrayOf(v.string),
    routing: v.boolean,
    fuzzyMatch: v.boolean,
    worldview: v.string
  })(config);
  config.mode = config.mode || 'mapbox.places';
  var query = stringifyBooleans(xtend({
    country: config.countries
  }, pick(config, ['proximity', 'types', 'autocomplete', 'bbox', 'limit', 'language', 'routing', 'fuzzyMatch', 'worldview'])));
  return this.client.createRequest({
    method: 'GET',
    path: '/geocoding/v5/:mode/:query.json',
    params: pick(config, ['mode', 'query']),
    query: query
  });
};
/**
 * Search for places near coordinates.
 *
 * See the [public documentation](https://docs.mapbox.com/api/search/#reverse-geocoding).
 *
 * @param {Object} config
 * @param {Coordinates} config.query - Coordinates at which features will be searched.
 * @param {'mapbox.places'|'mapbox.places-permanent'} [config.mode="mapbox.places"] - Either `mapbox.places` for ephemeral geocoding, or `mapbox.places-permanent` for storing results and batch geocoding.
 * @param {Array<string>} [config.countries] - Limits results to the specified countries.
 *   Each item in the array should be an [ISO 3166 alpha 2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
 * @param {Array<'country'|'region'|'postcode'|'district'|'place'|'locality'|'neighborhood'|'address'|'poi'|'poi.landmark'>} [config.types] - Filter results by feature types.
 * @param {BoundingBox} [config.bbox] - Limit results to a bounding box.
 * @param {number} [config.limit=1] - Limit the number of results returned. If using this option, you must provide a single item for `types`.
 * @param {Array<string>} [config.language] - Specify the language to use for response text and, for forward geocoding, query result weighting.
 *  Options are [IETF language tags](https://en.wikipedia.org/wiki/IETF_language_tag) comprised of a mandatory
 *  [ISO 639-1 language code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) and optionally one or more IETF subtags for country or script.
 * @param {'distance'|'score'} [config.reverseMode='distance'] - Set the factors that are used to sort nearby results.
 * @param {boolean} [config.routing=false] - Specify whether to request additional metadata about the recommended navigation destination. Only applicable for address features.
 * @param {String} [config.worldview="us"] - Filter results to geographic features whose characteristics are defined differently by audiences belonging to various regional, cultural, or political groups.
 * @return {MapiRequest}
 *
 * @example
 * geocodingClient.reverseGeocode({
 *   query: [-95.4431142, 33.6875431]
 * })
 *   .send()
 *   .then(response => {
 *     // GeoJSON document with geocoding matches
 *     const match = response.body;
 *   });
 */


Geocoding.reverseGeocode = function (config) {
  v.assertShape({
    query: v.required(v.coordinates),
    mode: v.oneOf('mapbox.places', 'mapbox.places-permanent'),
    countries: v.arrayOf(v.string),
    types: v.arrayOf(v.oneOf(featureTypes)),
    bbox: v.arrayOf(v.number),
    limit: v.number,
    language: v.arrayOf(v.string),
    reverseMode: v.oneOf('distance', 'score'),
    routing: v.boolean,
    worldview: v.string
  })(config);
  config.mode = config.mode || 'mapbox.places';
  var query = stringifyBooleans(xtend({
    country: config.countries
  }, pick(config, ['country', 'types', 'bbox', 'limit', 'language', 'reverseMode', 'routing', 'worldview'])));
  return this.client.createRequest({
    method: 'GET',
    path: '/geocoding/v5/:mode/:query.json',
    params: pick(config, ['mode', 'query']),
    query: query
  });
};

module.exports = createServiceFactory(Geocoding);

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/create-service-factory.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/services/service-helpers/create-service-factory.js ***!
  \********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var MapiClient = __webpack_require__(/*! ../../lib/classes/mapi-client */ "./node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-client.js"); // This will create the environment-appropriate client.


var createClient = __webpack_require__(/*! ../../lib/client */ "./node_modules/@mapbox/mapbox-sdk/lib/browser/browser-client.js");

function createServiceFactory(ServicePrototype) {
  return function (clientOrConfig) {
    var client;

    if (MapiClient.prototype.isPrototypeOf(clientOrConfig)) {
      client = clientOrConfig;
    } else {
      client = createClient(clientOrConfig);
    }

    var service = Object.create(ServicePrototype);
    service.client = client;
    return service;
  };
}

module.exports = createServiceFactory;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/object-map.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/services/service-helpers/object-map.js ***!
  \********************************************************************************/
/***/ (function(module) {

"use strict";


function objectMap(obj, cb) {
  return Object.keys(obj).reduce(function (result, key) {
    result[key] = cb(key, obj[key]);
    return result;
  }, {});
}

module.exports = objectMap;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/pick.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/services/service-helpers/pick.js ***!
  \**************************************************************************/
/***/ (function(module) {

"use strict";

/**
 * Create a new object by picking properties off an existing object.
 * The second param can be overloaded as a callback for
 * more fine grained picking of properties.
 * @param {Object} source
 * @param {Array<string>|function(string, Object):boolean} keys
 * @returns {Object}
 */

function pick(source, keys) {
  var filter = function (key, val) {
    return keys.indexOf(key) !== -1 && val !== undefined;
  };

  if (typeof keys === 'function') {
    filter = keys;
  }

  return Object.keys(source).filter(function (key) {
    return filter(key, source[key]);
  }).reduce(function (result, key) {
    result[key] = source[key];
    return result;
  }, {});
}

module.exports = pick;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/stringify-booleans.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/services/service-helpers/stringify-booleans.js ***!
  \****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var objectMap = __webpack_require__(/*! ./object-map */ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/object-map.js");
/**
 * Stringify all the boolean values in an object, so true becomes "true".
 *
 * @param {Object} obj
 * @returns {Object}
 */


function stringifyBoolean(obj) {
  return objectMap(obj, function (_, value) {
    return typeof value === 'boolean' ? JSON.stringify(value) : value;
  });
}

module.exports = stringifyBoolean;

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-sdk/services/service-helpers/validator.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-sdk/services/service-helpers/validator.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var v = __webpack_require__(/*! @mapbox/fusspot */ "./node_modules/@mapbox/fusspot/lib/index.js");

function file(value) {
  // If we're in a browser so Blob is available, the file must be that.
  // In Node, however, it could be a filepath or a pipeable (Readable) stream.
  if (typeof window !== 'undefined') {
    if (value instanceof __webpack_require__.g.Blob || value instanceof __webpack_require__.g.ArrayBuffer) {
      return;
    }

    return 'Blob or ArrayBuffer';
  }

  if (typeof value === 'string' || value.pipe !== undefined) {
    return;
  }

  return 'Filename or Readable stream';
}

function assertShape(validatorObj, apiName) {
  return v.assert(v.strictShape(validatorObj), apiName);
}

function date(value) {
  var msg = 'date';

  if (typeof value === 'boolean') {
    return msg;
  }

  try {
    var date = new Date(value);

    if (date.getTime && isNaN(date.getTime())) {
      return msg;
    }
  } catch (e) {
    return msg;
  }
}

function coordinates(value) {
  return v.tuple(v.number, v.number)(value);
}

module.exports = xtend(v, {
  file: file,
  date: date,
  coordinates: coordinates,
  assertShape: assertShape
});

/***/ }),

/***/ "./node_modules/@mapbox/parse-mapbox-token/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mapbox/parse-mapbox-token/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var base64 = __webpack_require__(/*! base-64 */ "./node_modules/base-64/base64.js");

var tokenCache = {};

function parseToken(token) {
  if (tokenCache[token]) {
    return tokenCache[token];
  }

  var parts = token.split('.');
  var usage = parts[0];
  var rawPayload = parts[1];

  if (!rawPayload) {
    throw new Error('Invalid token');
  }

  var parsedPayload = parsePaylod(rawPayload);
  var result = {
    usage: usage,
    user: parsedPayload.u
  };
  if (has(parsedPayload, 'a')) result.authorization = parsedPayload.a;
  if (has(parsedPayload, 'exp')) result.expires = parsedPayload.exp * 1000;
  if (has(parsedPayload, 'iat')) result.created = parsedPayload.iat * 1000;
  if (has(parsedPayload, 'scopes')) result.scopes = parsedPayload.scopes;
  if (has(parsedPayload, 'client')) result.client = parsedPayload.client;
  if (has(parsedPayload, 'll')) result.lastLogin = parsedPayload.ll;
  if (has(parsedPayload, 'iu')) result.impersonator = parsedPayload.iu;
  tokenCache[token] = result;
  return result;
}

function parsePaylod(rawPayload) {
  try {
    return JSON.parse(base64.decode(rawPayload));
  } catch (parseError) {
    throw new Error('Invalid token');
  }
}

function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

module.exports = parseToken;

/***/ }),

/***/ "./node_modules/base-64/base64.js":
/*!****************************************!*\
  !*** ./node_modules/base-64/base64.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
;

(function (root) {
  // Detect free variables `exports`.
  var freeExports =  true && exports; // Detect free variable `module`.

  var freeModule =  true && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code, and use
  // it as `root`.

  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    root = freeGlobal;
  }
  /*--------------------------------------------------------------------------*/


  var InvalidCharacterError = function (message) {
    this.message = message;
  };

  InvalidCharacterError.prototype = new Error();
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  var error = function (message) {
    // Note: the error messages used throughout this file match those used by
    // the native `atob`/`btoa` implementation in Chromium.
    throw new InvalidCharacterError(message);
  };

  var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // http://whatwg.org/html/common-microsyntaxes.html#space-character

  var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g; // `decode` is designed to be fully compatible with `atob` as described in the
  // HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
  // The optimized base64-decoding algorithm used is based on @atk’s excellent
  // implementation. https://gist.github.com/atk/1020396

  var decode = function (input) {
    input = String(input).replace(REGEX_SPACE_CHARACTERS, '');
    var length = input.length;

    if (length % 4 == 0) {
      input = input.replace(/==?$/, '');
      length = input.length;
    }

    if (length % 4 == 1 || // http://whatwg.org/C#alphanumeric-ascii-characters
    /[^+a-zA-Z0-9/]/.test(input)) {
      error('Invalid character: the string to be decoded is not correctly encoded.');
    }

    var bitCounter = 0;
    var bitStorage;
    var buffer;
    var output = '';
    var position = -1;

    while (++position < length) {
      buffer = TABLE.indexOf(input.charAt(position));
      bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer; // Unless this is the first of a group of 4 characters…

      if (bitCounter++ % 4) {
        // …convert the first 8 bits to a single ASCII character.
        output += String.fromCharCode(0xFF & bitStorage >> (-2 * bitCounter & 6));
      }
    }

    return output;
  }; // `encode` is designed to be fully compatible with `btoa` as described in the
  // HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa


  var encode = function (input) {
    input = String(input);

    if (/[^\0-\xFF]/.test(input)) {
      // Note: no need to special-case astral symbols here, as surrogates are
      // matched, and the input is supposed to only contain ASCII anyway.
      error('The string to be encoded contains characters outside of the ' + 'Latin1 range.');
    }

    var padding = input.length % 3;
    var output = '';
    var position = -1;
    var a;
    var b;
    var c;
    var d;
    var buffer; // Make sure any padding is handled outside of the loop.

    var length = input.length - padding;

    while (++position < length) {
      // Read three bytes, i.e. 24 bits.
      a = input.charCodeAt(position) << 16;
      b = input.charCodeAt(++position) << 8;
      c = input.charCodeAt(++position);
      buffer = a + b + c; // Turn the 24 bits into four chunks of 6 bits each, and append the
      // matching character for each of them to the output.

      output += TABLE.charAt(buffer >> 18 & 0x3F) + TABLE.charAt(buffer >> 12 & 0x3F) + TABLE.charAt(buffer >> 6 & 0x3F) + TABLE.charAt(buffer & 0x3F);
    }

    if (padding == 2) {
      a = input.charCodeAt(position) << 8;
      b = input.charCodeAt(++position);
      buffer = a + b;
      output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 0x3F) + TABLE.charAt(buffer << 2 & 0x3F) + '=';
    } else if (padding == 1) {
      buffer = input.charCodeAt(position);
      output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 0x3F) + '==';
    }

    return output;
  };

  var base64 = {
    'encode': encode,
    'decode': decode,
    'version': '0.1.0'
  }; // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return base64;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var key; }
})(this);

/***/ }),

/***/ "./node_modules/d3-array/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/array.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "map": function() { return /* binding */ map; },
/* harmony export */   "slice": function() { return /* binding */ slice; }
/* harmony export */ });
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bisectLeft": function() { return /* binding */ bisectLeft; },
/* harmony export */   "bisectRight": function() { return /* binding */ bisectRight; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");


var ascendingBisect = (0,_bisector__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["default"] = (bisectRight);

/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function (a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }

      return lo;
    },
    right: function (a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }

      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function (d, x) {
    return (0,_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
  };
}

/***/ }),

/***/ "./node_modules/d3-array/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/constant.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function () {
    return x;
  };
}

/***/ }),

/***/ "./node_modules/d3-array/src/cross.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/cross.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;
  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__.pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

/***/ }),

/***/ "./node_modules/d3-array/src/deviation.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/deviation.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, f) {
  var v = (0,_variance__WEBPACK_IMPORTED_MODULE_0__["default"])(array, f);
  return v ? Math.sqrt(v) : v;
}

/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

/***/ }),

/***/ "./node_modules/d3-array/src/histogram.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/histogram.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-array/src/constant.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-array/src/identity.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");








/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__["default"],
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__["default"];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      tz = (0,_ticks__WEBPACK_IMPORTED_MODULE_6__.tickStep)(x0, x1, tz);
      tz = (0,_range__WEBPACK_IMPORTED_MODULE_5__["default"])(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) tz.shift(), --m;

    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x0 <= x && x <= x1) {
        bins[(0,_bisect__WEBPACK_IMPORTED_MODULE_1__["default"])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)) : (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : threshold;
  };

  return histogram;
}

/***/ }),

/***/ "./node_modules/d3-array/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/identity.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}

/***/ }),

/***/ "./node_modules/d3-array/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ascending": function() { return /* reexport safe */ _ascending__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "bisect": function() { return /* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "bisectLeft": function() { return /* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__.bisectLeft; },
/* harmony export */   "bisectRight": function() { return /* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__.bisectRight; },
/* harmony export */   "bisector": function() { return /* reexport safe */ _bisector__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "cross": function() { return /* reexport safe */ _cross__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   "descending": function() { return /* reexport safe */ _descending__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   "deviation": function() { return /* reexport safe */ _deviation__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   "extent": function() { return /* reexport safe */ _extent__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   "histogram": function() { return /* reexport safe */ _histogram__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   "max": function() { return /* reexport safe */ _max__WEBPACK_IMPORTED_MODULE_11__["default"]; },
/* harmony export */   "mean": function() { return /* reexport safe */ _mean__WEBPACK_IMPORTED_MODULE_12__["default"]; },
/* harmony export */   "median": function() { return /* reexport safe */ _median__WEBPACK_IMPORTED_MODULE_13__["default"]; },
/* harmony export */   "merge": function() { return /* reexport safe */ _merge__WEBPACK_IMPORTED_MODULE_14__["default"]; },
/* harmony export */   "min": function() { return /* reexport safe */ _min__WEBPACK_IMPORTED_MODULE_15__["default"]; },
/* harmony export */   "pairs": function() { return /* reexport safe */ _pairs__WEBPACK_IMPORTED_MODULE_16__["default"]; },
/* harmony export */   "permute": function() { return /* reexport safe */ _permute__WEBPACK_IMPORTED_MODULE_17__["default"]; },
/* harmony export */   "quantile": function() { return /* reexport safe */ _quantile__WEBPACK_IMPORTED_MODULE_18__["default"]; },
/* harmony export */   "range": function() { return /* reexport safe */ _range__WEBPACK_IMPORTED_MODULE_19__["default"]; },
/* harmony export */   "scan": function() { return /* reexport safe */ _scan__WEBPACK_IMPORTED_MODULE_20__["default"]; },
/* harmony export */   "shuffle": function() { return /* reexport safe */ _shuffle__WEBPACK_IMPORTED_MODULE_21__["default"]; },
/* harmony export */   "sum": function() { return /* reexport safe */ _sum__WEBPACK_IMPORTED_MODULE_22__["default"]; },
/* harmony export */   "thresholdFreedmanDiaconis": function() { return /* reexport safe */ _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   "thresholdScott": function() { return /* reexport safe */ _threshold_scott__WEBPACK_IMPORTED_MODULE_9__["default"]; },
/* harmony export */   "thresholdSturges": function() { return /* reexport safe */ _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__["default"]; },
/* harmony export */   "tickIncrement": function() { return /* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__.tickIncrement; },
/* harmony export */   "tickStep": function() { return /* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__.tickStep; },
/* harmony export */   "ticks": function() { return /* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__["default"]; },
/* harmony export */   "transpose": function() { return /* reexport safe */ _transpose__WEBPACK_IMPORTED_MODULE_24__["default"]; },
/* harmony export */   "variance": function() { return /* reexport safe */ _variance__WEBPACK_IMPORTED_MODULE_25__["default"]; },
/* harmony export */   "zip": function() { return /* reexport safe */ _zip__WEBPACK_IMPORTED_MODULE_26__["default"]; }
/* harmony export */ });
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ "./node_modules/d3-array/src/cross.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-array/src/descending.js");
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./deviation */ "./node_modules/d3-array/src/deviation.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./histogram */ "./node_modules/d3-array/src/histogram.js");
/* harmony import */ var _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./threshold/freedmanDiaconis */ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js");
/* harmony import */ var _threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold/scott */ "./node_modules/d3-array/src/threshold/scott.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./max */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mean */ "./node_modules/d3-array/src/mean.js");
/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./median */ "./node_modules/d3-array/src/median.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-array/src/merge.js");
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");
/* harmony import */ var _permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./permute */ "./node_modules/d3-array/src/permute.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./scan */ "./node_modules/d3-array/src/scan.js");
/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./shuffle */ "./node_modules/d3-array/src/shuffle.js");
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sum */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");
/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./zip */ "./node_modules/d3-array/src/zip.js");




























/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

/***/ }),

/***/ "./node_modules/d3-array/src/mean.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/mean.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) sum += value;else --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) sum += value;else --m;
    }
  }

  if (m) return sum / m;
}

/***/ }),

/***/ "./node_modules/d3-array/src/median.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/median.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_1__["default"])(values[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_1__["default"])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return (0,_quantile__WEBPACK_IMPORTED_MODULE_2__["default"])(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]), 0.5);
}

/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;

  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;

    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x === null ? NaN : +x;
}

/***/ }),

/***/ "./node_modules/d3-array/src/pairs.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/pairs.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "pair": function() { return /* binding */ pair; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, f) {
  if (f == null) f = pair;
  var i = 0,
      n = array.length - 1,
      p = array[0],
      pairs = new Array(n < 0 ? 0 : n);

  while (i < n) pairs[i] = f(p, p = array[++i]);

  return pairs;
}
function pair(a, b) {
  return [a, b];
}

/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, indexes) {
  var i = indexes.length,
      permutes = new Array(i);

  while (i--) permutes[i] = array[indexes[i]];

  return permutes;
}

/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

/***/ }),

/***/ "./node_modules/d3-array/src/scan.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/scan.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];
  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__["default"];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

/***/ }),

/***/ "./node_modules/d3-array/src/shuffle.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/shuffle.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "./node_modules/d3-array/src/quantile.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__.map.call(values, _number__WEBPACK_IMPORTED_MODULE_2__["default"]).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return Math.ceil((max - min) / (2 * ((0,_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.75) - (0,_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/scott.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/scott.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "./node_modules/d3-array/src/deviation.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, min, max) {
  return Math.ceil((max - min) / (3.5 * (0,_deviation__WEBPACK_IMPORTED_MODULE_0__["default"])(values) * Math.pow(values.length, -1 / 3)));
}

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/sturges.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/sturges.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "tickIncrement": function() { return /* binding */ tickIncrement; },
/* harmony export */   "tickStep": function() { return /* binding */ tickStep; }
/* harmony export */ });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));

    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

/***/ }),

/***/ "./node_modules/d3-array/src/transpose.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/transpose.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(matrix) {
  if (!(n = matrix.length)) return [];

  for (var i = -1, m = (0,_min__WEBPACK_IMPORTED_MODULE_0__["default"])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }

  return transpose;
}

function length(d) {
  return d.length;
}

/***/ }),

/***/ "./node_modules/d3-array/src/variance.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/variance.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

/***/ }),

/***/ "./node_modules/d3-array/src/zip.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/zip.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_transpose__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments);
}

/***/ }),

/***/ "./node_modules/d3-geo/index.js":
/*!**************************************!*\
  !*** ./node_modules/d3-geo/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "geoAlbers": function() { return /* reexport safe */ _src_projection_albers__WEBPACK_IMPORTED_MODULE_11__["default"]; },
/* harmony export */   "geoAlbersUsa": function() { return /* reexport safe */ _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_12__["default"]; },
/* harmony export */   "geoArea": function() { return /* reexport safe */ _src_area__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "geoAzimuthalEqualArea": function() { return /* reexport safe */ _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_13__["default"]; },
/* harmony export */   "geoAzimuthalEqualAreaRaw": function() { return /* reexport safe */ _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_13__.azimuthalEqualAreaRaw; },
/* harmony export */   "geoAzimuthalEquidistant": function() { return /* reexport safe */ _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_14__["default"]; },
/* harmony export */   "geoAzimuthalEquidistantRaw": function() { return /* reexport safe */ _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_14__.azimuthalEquidistantRaw; },
/* harmony export */   "geoBounds": function() { return /* reexport safe */ _src_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "geoCentroid": function() { return /* reexport safe */ _src_centroid__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "geoCircle": function() { return /* reexport safe */ _src_circle__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   "geoClipExtent": function() { return /* reexport safe */ _src_clip_extent__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   "geoConicConformal": function() { return /* reexport safe */ _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_15__["default"]; },
/* harmony export */   "geoConicConformalRaw": function() { return /* reexport safe */ _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_15__.conicConformalRaw; },
/* harmony export */   "geoConicEqualArea": function() { return /* reexport safe */ _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_16__["default"]; },
/* harmony export */   "geoConicEqualAreaRaw": function() { return /* reexport safe */ _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_16__.conicEqualAreaRaw; },
/* harmony export */   "geoConicEquidistant": function() { return /* reexport safe */ _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_17__["default"]; },
/* harmony export */   "geoConicEquidistantRaw": function() { return /* reexport safe */ _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_17__.conicEquidistantRaw; },
/* harmony export */   "geoContains": function() { return /* reexport safe */ _src_contains__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   "geoDistance": function() { return /* reexport safe */ _src_distance__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   "geoEquirectangular": function() { return /* reexport safe */ _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_18__["default"]; },
/* harmony export */   "geoEquirectangularRaw": function() { return /* reexport safe */ _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_18__.equirectangularRaw; },
/* harmony export */   "geoGnomonic": function() { return /* reexport safe */ _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_19__["default"]; },
/* harmony export */   "geoGnomonicRaw": function() { return /* reexport safe */ _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_19__.gnomonicRaw; },
/* harmony export */   "geoGraticule": function() { return /* reexport safe */ _src_graticule__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   "geoGraticule10": function() { return /* reexport safe */ _src_graticule__WEBPACK_IMPORTED_MODULE_7__.graticule10; },
/* harmony export */   "geoIdentity": function() { return /* reexport safe */ _src_projection_identity__WEBPACK_IMPORTED_MODULE_20__["default"]; },
/* harmony export */   "geoInterpolate": function() { return /* reexport safe */ _src_interpolate__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   "geoLength": function() { return /* reexport safe */ _src_length__WEBPACK_IMPORTED_MODULE_9__["default"]; },
/* harmony export */   "geoMercator": function() { return /* reexport safe */ _src_projection_mercator__WEBPACK_IMPORTED_MODULE_22__["default"]; },
/* harmony export */   "geoMercatorRaw": function() { return /* reexport safe */ _src_projection_mercator__WEBPACK_IMPORTED_MODULE_22__.mercatorRaw; },
/* harmony export */   "geoNaturalEarth1": function() { return /* reexport safe */ _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_23__["default"]; },
/* harmony export */   "geoNaturalEarth1Raw": function() { return /* reexport safe */ _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_23__.naturalEarth1Raw; },
/* harmony export */   "geoOrthographic": function() { return /* reexport safe */ _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_24__["default"]; },
/* harmony export */   "geoOrthographicRaw": function() { return /* reexport safe */ _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_24__.orthographicRaw; },
/* harmony export */   "geoPath": function() { return /* reexport safe */ _src_path_index__WEBPACK_IMPORTED_MODULE_10__["default"]; },
/* harmony export */   "geoProjection": function() { return /* reexport safe */ _src_projection_index__WEBPACK_IMPORTED_MODULE_21__["default"]; },
/* harmony export */   "geoProjectionMutator": function() { return /* reexport safe */ _src_projection_index__WEBPACK_IMPORTED_MODULE_21__.projectionMutator; },
/* harmony export */   "geoRotation": function() { return /* reexport safe */ _src_rotation__WEBPACK_IMPORTED_MODULE_27__["default"]; },
/* harmony export */   "geoStereographic": function() { return /* reexport safe */ _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_25__["default"]; },
/* harmony export */   "geoStereographicRaw": function() { return /* reexport safe */ _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_25__.stereographicRaw; },
/* harmony export */   "geoStream": function() { return /* reexport safe */ _src_stream__WEBPACK_IMPORTED_MODULE_28__["default"]; },
/* harmony export */   "geoTransform": function() { return /* reexport safe */ _src_transform__WEBPACK_IMPORTED_MODULE_29__["default"]; },
/* harmony export */   "geoTransverseMercator": function() { return /* reexport safe */ _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_26__["default"]; },
/* harmony export */   "geoTransverseMercatorRaw": function() { return /* reexport safe */ _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_26__.transverseMercatorRaw; }
/* harmony export */ });
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-geo/src/area.js");
/* harmony import */ var _src_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/bounds */ "./node_modules/d3-geo/src/bounds.js");
/* harmony import */ var _src_centroid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/centroid */ "./node_modules/d3-geo/src/centroid.js");
/* harmony import */ var _src_circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/circle */ "./node_modules/d3-geo/src/circle.js");
/* harmony import */ var _src_clip_extent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/clip/extent */ "./node_modules/d3-geo/src/clip/extent.js");
/* harmony import */ var _src_contains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/contains */ "./node_modules/d3-geo/src/contains.js");
/* harmony import */ var _src_distance__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/distance */ "./node_modules/d3-geo/src/distance.js");
/* harmony import */ var _src_graticule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/graticule */ "./node_modules/d3-geo/src/graticule.js");
/* harmony import */ var _src_interpolate__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/interpolate */ "./node_modules/d3-geo/src/interpolate.js");
/* harmony import */ var _src_length__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/length */ "./node_modules/d3-geo/src/length.js");
/* harmony import */ var _src_path_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/path/index */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var _src_projection_albers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/projection/albers */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/projection/albersUsa */ "./node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony import */ var _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/projection/azimuthalEqualArea */ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony import */ var _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/projection/azimuthalEquidistant */ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony import */ var _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/projection/conicConformal */ "./node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony import */ var _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/projection/conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/projection/conicEquidistant */ "./node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony import */ var _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/projection/equirectangular */ "./node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony import */ var _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/projection/gnomonic */ "./node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony import */ var _src_projection_identity__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/projection/identity */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var _src_projection_index__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/projection/index */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _src_projection_mercator__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/projection/mercator */ "./node_modules/d3-geo/src/projection/mercator.js");
/* harmony import */ var _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/projection/naturalEarth1 */ "./node_modules/d3-geo/src/projection/naturalEarth1.js");
/* harmony import */ var _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/projection/orthographic */ "./node_modules/d3-geo/src/projection/orthographic.js");
/* harmony import */ var _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/projection/stereographic */ "./node_modules/d3-geo/src/projection/stereographic.js");
/* harmony import */ var _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/projection/transverseMercator */ "./node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony import */ var _src_rotation__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _src_stream__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/transform */ "./node_modules/d3-geo/src/transform.js");




 // DEPRECATED! Use d3.geoIdentity().clipExtent(…).



























/***/ }),

/***/ "./node_modules/d3-geo/src/adder.js":
/*!******************************************!*\
  !*** ./node_modules/d3-geo/src/adder.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Adder();
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function () {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function (y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;else this.s = temp.t;
  },
  valueOf: function () {
    return this.s;
  }
};
var temp = new Adder();

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = a - av + (b - bv);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/area.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/area.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areaRingSum": function() { return /* binding */ areaRingSum; },
/* harmony export */   "areaStream": function() { return /* binding */ areaStream; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");




var areaRingSum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
var areaSum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function () {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function () {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math__WEBPACK_IMPORTED_MODULE_1__.tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  sphere: function () {
    areaSum.add(_math__WEBPACK_IMPORTED_MODULE_1__.tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_1__.radians;
  lambda0 = lambda, cosPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__.quarterPi), sinPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_1__.radians;
  phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__.quarterPi; // half the angular distance from south pole
  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).

  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      sinPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(adLambda),
      v = k * sdLambda * (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(adLambda);
  areaRingSum.add((0,_math__WEBPACK_IMPORTED_MODULE_1__.atan2)(v, u)); // Advance the previous points.

  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  areaSum.reset();
  (0,_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, areaStream);
  return areaSum * 2;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/bounds.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/bounds.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo/src/area.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");





var lambda0,
    phi0,
    lambda1,
    phi1,
    // bounds
lambda2,
    // previous lambda-coordinate
lambda00,
    phi00,
    // first point
p0,
    // previous 3D point
deltaSum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    ranges,
    range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function () {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    _area__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonStart();
  },
  polygonEnd: function () {
    _area__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area__WEBPACK_IMPORTED_MODULE_1__.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math__WEBPACK_IMPORTED_MODULE_3__.epsilon) phi1 = 90;else if (deltaSum < -_math__WEBPACK_IMPORTED_MODULE_3__.epsilon) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = (0,_cartesian__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda * _math__WEBPACK_IMPORTED_MODULE_3__.radians, phi * _math__WEBPACK_IMPORTED_MODULE_3__.radians]);

  if (p0) {
    var normal = (0,_cartesian__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = (0,_cartesian__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(equatorial, normal);
    (0,_cartesian__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(inflection);
    inflection = (0,_cartesian__WEBPACK_IMPORTED_MODULE_2__.spherical)(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math__WEBPACK_IMPORTED_MODULE_3__.degrees * sign,
        phii,
        antimeridian = (0,_math__WEBPACK_IMPORTED_MODULE_3__.abs)(delta) > 180;

    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__.degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__.degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }

  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add((0,_math__WEBPACK_IMPORTED_MODULE_3__.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }

  _area__WEBPACK_IMPORTED_MODULE_1__.areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineEnd();
  if ((0,_math__WEBPACK_IMPORTED_MODULE_3__.abs)(deltaSum) > _math__WEBPACK_IMPORTED_MODULE_3__.epsilon) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
} // Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.


function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  (0,_stream__WEBPACK_IMPORTED_MODULE_4__["default"])(feature, boundsStream); // First, sort ranges by their minimum longitudes.

  if (n = ranges.length) {
    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.

    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];

      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    } // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.


    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;
  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
}

/***/ }),

/***/ "./node_modules/d3-geo/src/cartesian.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/cartesian.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cartesian": function() { return /* binding */ cartesian; },
/* harmony export */   "cartesianAddInPlace": function() { return /* binding */ cartesianAddInPlace; },
/* harmony export */   "cartesianCross": function() { return /* binding */ cartesianCross; },
/* harmony export */   "cartesianDot": function() { return /* binding */ cartesianDot; },
/* harmony export */   "cartesianNormalizeInPlace": function() { return /* binding */ cartesianNormalizeInPlace; },
/* harmony export */   "cartesianScale": function() { return /* binding */ cartesianScale; },
/* harmony export */   "spherical": function() { return /* binding */ spherical; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

function spherical(cartesian) {
  return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}
function cartesian(spherical) {
  var lambda = spherical[0],
      phi = spherical[1],
      cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // TODO return a

function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
} // TODO return d

function cartesianNormalizeInPlace(d) {
  var l = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");



var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function () {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function () {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
}; // Arithmetic mean of Cartesian vectors.

function centroidPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_0__.radians;
  var cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_0__.radians;
  var cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  x0 = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda);
  y0 = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda);
  z0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_0__.radians;
  var cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
      x = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda),
      y = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda),
      z = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      w = (0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)((0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).


function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_0__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  x0 = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda);
  y0 = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda);
  z0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_0__.radians;
  var cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
      x = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda),
      y = cosPhi * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda),
      z = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(cx * cx + cy * cy + cz * cz),
      w = (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)(m),
      // line weight = angle
  v = m && -w / m; // area weight multiplier

  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  (0,_stream__WEBPACK_IMPORTED_MODULE_2__["default"])(object, centroidStream);
  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z; // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.

  if (m < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon2) {
    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.

    if (W1 < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z; // If the feature still has an undefined ccentroid, then return.

    if (m < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__.degrees, (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)(z / (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(m)) * _math__WEBPACK_IMPORTED_MODULE_0__.degrees];
}

/***/ }),

/***/ "./node_modules/d3-geo/src/circle.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/circle.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circleStream": function() { return /* binding */ circleStream; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation */ "./node_modules/d3-geo/src/rotation.js");



 // Generates a circle centered at [0°, 0°], with a given radius and precision.

function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(radius),
      sinRadius = (0,_math__WEBPACK_IMPORTED_MODULE_2__.sin)(radius),
      step = direction * delta;

  if (t0 == null) {
    t0 = radius + direction * _math__WEBPACK_IMPORTED_MODULE_2__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math__WEBPACK_IMPORTED_MODULE_2__.tau;
  }

  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.spherical)([cosRadius, -sinRadius * (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(t), -sinRadius * (0,_math__WEBPACK_IMPORTED_MODULE_2__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
} // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].

function circleRadius(cosRadius, point) {
  point = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math__WEBPACK_IMPORTED_MODULE_2__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math__WEBPACK_IMPORTED_MODULE_2__.tau - _math__WEBPACK_IMPORTED_MODULE_2__.epsilon) % _math__WEBPACK_IMPORTED_MODULE_2__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([0, 0]),
      radius = (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(90),
      precision = (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(6),
      ring,
      rotate,
      stream = {
    point: point
  };

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math__WEBPACK_IMPORTED_MODULE_2__.degrees, x[1] *= _math__WEBPACK_IMPORTED_MODULE_2__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__.radians,
        p = precision.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__.radians;
    ring = [];
    rotate = (0,_rotation__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math__WEBPACK_IMPORTED_MODULE_2__.radians, -c[1] * _math__WEBPACK_IMPORTED_MODULE_2__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {
      type: "Polygon",
      coordinates: [ring]
    };
    ring = rotate = null;
    return c;
  }

  circle.center = function (_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : radius;
  };

  circle.precision = function (_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : precision;
  };

  return circle;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/antimeridian.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/antimeridian.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ((0,_index__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math__WEBPACK_IMPORTED_MODULE_1__.pi, -_math__WEBPACK_IMPORTED_MODULE_1__.halfPi])); // Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.

function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function () {
      stream.lineStart();
      clean = 1;
    },
    point: function (lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__.pi : -_math__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);

      if ((0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math__WEBPACK_IMPORTED_MODULE_1__.pi) < _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math__WEBPACK_IMPORTED_MODULE_1__.pi) {
        // line crosses antimeridian
        if ((0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies

        if ((0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }

      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function () {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function () {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon ? (0,_math__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1) - (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;

  if (from == null) {
    phi = direction * _math__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math__WEBPACK_IMPORTED_MODULE_1__.pi : -_math__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function (x, y) {
      line.push([x, y]);
    },
    lineStart: function () {
      lines.push(line = []);
    },
    lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function () {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function () {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/circle.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/circle.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle */ "./node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/clip/index.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius, delta) {
  var cr = (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(radius),
      smallRadius = cr > 0,
      notHemisphere = (0,_math__WEBPACK_IMPORTED_MODULE_2__.abs)(cr) > _math__WEBPACK_IMPORTED_MODULE_2__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(lambda) * (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(phi) > cr;
  } // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.


  function clipLine(stream) {
    var point0, // previous point
    c0, // code for previous point
    v0, // visibility of previous point
    v00, // visibility of first point
    clean; // no intersections

    return {
      lineStart: function () {
        v00 = v0 = false;
        clean = 1;
      },
      point: function (lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math__WEBPACK_IMPORTED_MODULE_2__.pi : -_math__WEBPACK_IMPORTED_MODULE_2__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.
        // TODO ignore if not clipping polygons.

        if (v !== v0) {
          point2 = intersect(point0, point1);

          if (!point2 || (0,_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point2) || (0,_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point1, point2)) {
            point1[0] += _math__WEBPACK_IMPORTED_MODULE_2__.epsilon;
            point1[1] += _math__WEBPACK_IMPORTED_MODULE_2__.epsilon;
            v = visible(point1[0], point1[1]);
          }
        }

        if (v !== v0) {
          clean = 0;

          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }

          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t; // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.

          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;

            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }

        if (v && (!point0 || !(0,_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }

        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function () {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function () {
        return clean | (v00 && v0) << 1;
      }
    };
  } // Intersects the great circle between a and b with the clip circle.


  function intersect(a, b, two) {
    var pa = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesian)(a),
        pb = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesian)(b); // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).

    var n1 = [1, 0, 0],
        // normal
    n2 = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianDot)(n2, n2),
        n1n2 = n2[0],
        // cartesianDot(n1, n2),
    determinant = n2n2 - n1n2 * n1n2; // Two polar points.

    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianCross)(n1, n2),
        A = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianScale)(n1, c1),
        B = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianScale)(n2, c2);
    (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianAddInPlace)(A, B); // Solve |p(t)|^2 = 1.

    var u = n1xn2,
        w = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianDot)(A, u),
        uu = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianDot)(A, A) - 1);
    if (t2 < 0) return;
    var t = (0,_math__WEBPACK_IMPORTED_MODULE_2__.sqrt)(t2),
        q = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.spherical)(q);
    if (!two) return q; // Two intersection points.

    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta = lambda1 - lambda0,
        polar = (0,_math__WEBPACK_IMPORTED_MODULE_2__.abs)(delta - _math__WEBPACK_IMPORTED_MODULE_2__.pi) < _math__WEBPACK_IMPORTED_MODULE_2__.epsilon,
        meridian = polar || delta < _math__WEBPACK_IMPORTED_MODULE_2__.epsilon;
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.

    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0,_math__WEBPACK_IMPORTED_MODULE_2__.abs)(q[0] - lambda0) < _math__WEBPACK_IMPORTED_MODULE_2__.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math__WEBPACK_IMPORTED_MODULE_2__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.spherical)(q1)];
    }
  } // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.


  function code(lambda, phi) {
    var r = smallRadius ? radius : _math__WEBPACK_IMPORTED_MODULE_2__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right

    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above

    return code;
  }

  return (0,_index__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math__WEBPACK_IMPORTED_MODULE_2__.pi, radius - _math__WEBPACK_IMPORTED_MODULE_2__.pi]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/extent.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clipExtent": function() { return /* binding */ clipExtent; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polygon */ "./node_modules/d3-geo/src/clip/polygon.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");





var clipMax = 1e9,
    clipMin = -clipMax; // TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipExtent(x0, y0, x1, y1) {
  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0,
        a1 = 0;

    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3 : (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1 : (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }

  return function (stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__,
        y__,
        v__,
        // first point
    x_,
        y_,
        v_,
        // previous point
    first,
        clean;
    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];

          if (a1 <= y1) {
            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
          } else {
            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
          }
        }
      }

      return winding;
    } // Buffer geometry within a polygon and then clip it en masse.


    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.merge)(segments)).length;

      if (cleanInside || visible) {
        stream.polygonStart();

        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }

        if (visible) {
          (0,_polygon__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }

        stream.polygonEnd();
      }

      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    } // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.


    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }

      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);

      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;

        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];

          if ((0,_line__WEBPACK_IMPORTED_MODULE_2__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }

            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }

      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;
  return clip = {
    stream: function (stream) {
      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function (_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygon */ "./node_modules/d3-geo/src/clip/polygon.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polygonContains */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function (rotate, sink) {
    var line = clipLine(sink),
        rotatedStart = rotate.invert(start[0], start[1]),
        ringBuffer = (0,_buffer__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;
    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function () {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function () {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.merge)(segments);
        var startInside = (0,_polygonContains__WEBPACK_IMPORTED_MODULE_3__["default"])(polygon, rotatedStart);

        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_polygon__WEBPACK_IMPORTED_MODULE_1__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }

        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function () {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      var point = rotate(lambda, phi);
      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      var point = rotate(lambda, phi);
      line.point(point[0], point[1]);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      var point = rotate(lambda, phi);
      ringSink.point(point[0], point[1]);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i,
          n = ringSegments.length,
          m,
          segment,
          point;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return; // No intersections.

      if (clean & 1) {
        segment = ringSegments[0];

        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();

          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);

          sink.lineEnd();
        }

        return;
      } // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?


      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
} // Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.


function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math__WEBPACK_IMPORTED_MODULE_2__.halfPi - _math__WEBPACK_IMPORTED_MODULE_2__.epsilon : _math__WEBPACK_IMPORTED_MODULE_2__.halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math__WEBPACK_IMPORTED_MODULE_2__.halfPi - _math__WEBPACK_IMPORTED_MODULE_2__.epsilon : _math__WEBPACK_IMPORTED_MODULE_2__.halfPi - b[1]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/polygon.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/polygon.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo/src/pointEqual.js");


function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection

  this.e = entry; // is an entry?

  this.v = false; // visited

  this.n = this.p = null; // next & previous
} // A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;
  segments.forEach(function (segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n,
        p0 = segment[0],
        p1 = segment[n],
        x; // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.

    if ((0,_pointEqual__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      stream.lineStart();

      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);

      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;

    while (current.v) if ((current = current.n) === start) return;

    points = current.z;
    stream.lineStart();

    do {
      current.v = current.o.v = true;

      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }

        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;

          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }

        current = current.p;
      }

      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);

    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;

  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }

  a.n = b = array[0];
  b.p = a;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/compose.js":
/*!********************************************!*\
  !*** ./node_modules/d3-geo/src/compose.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function (x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/constant.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/constant.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function () {
    return x;
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/contains.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/contains.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _polygonContains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polygonContains */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distance */ "./node_modules/d3-geo/src/distance.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



var containsObjectType = {
  Feature: function (object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function (object, point) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;

    return false;
  }
};
var containsGeometryType = {
  Sphere: function () {
    return true;
  },
  Point: function (object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsPoint(coordinates[i], point)) return true;

    return false;
  },
  LineString: function (object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsLine(coordinates[i], point)) return true;

    return false;
  },
  Polygon: function (object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;

    return false;
  },
  GeometryCollection: function (object, point) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) if (containsGeometry(geometries[i], point)) return true;

    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
}

function containsPoint(coordinates, point) {
  return (0,_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = (0,_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[0], coordinates[1]),
      ao = (0,_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[0], point),
      ob = (0,_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(point, coordinates[1]);
  return ao + ob <= ab + _math__WEBPACK_IMPORTED_MODULE_2__.epsilon;
}

function containsPolygon(coordinates, point) {
  return !!(0,_polygonContains__WEBPACK_IMPORTED_MODULE_0__["default"])(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * _math__WEBPACK_IMPORTED_MODULE_2__.radians, point[1] * _math__WEBPACK_IMPORTED_MODULE_2__.radians];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/distance.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/distance.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length */ "./node_modules/d3-geo/src/length.js");

var coordinates = [null, null],
    object = {
  type: "LineString",
  coordinates: coordinates
};
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return (0,_length__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ graticule; },
/* harmony export */   "graticule10": function() { return /* binding */ graticule10; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)(y0, y1 - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function (x) {
    return y.map(function (y) {
      return [x, y];
    });
  };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)(x0, x1 - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function (y) {
    return x.map(function (x) {
      return [x, y];
    });
  };
}

function graticule() {
  var x1,
      x0,
      X1,
      X0,
      y1,
      y0,
      Y1,
      Y0,
      dx = 10,
      dy = dx,
      DX = 90,
      DY = 360,
      x,
      y,
      X,
      Y,
      precision = 2.5;

  function graticule() {
    return {
      type: "MultiLineString",
      coordinates: lines()
    };
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X).concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y)).concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function (x) {
      return (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }).map(x)).concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function (y) {
      return (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }).map(y));
  }

  graticule.lines = function () {
    return lines().map(function (coordinates) {
      return {
        type: "LineString",
        coordinates: coordinates
      };
    });
  };

  graticule.outline = function () {
    return {
      type: "Polygon",
      coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
    };
  };

  graticule.extent = function (_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function (_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function (_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function (_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function (_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function (_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function (_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule.extentMajor([[-180, -90 + _math__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon]]).extentMinor([[-180, -80 - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}
function graticule10() {
  return graticule()();
}

/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/interpolate.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/interpolate.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var x0 = a[0] * _math__WEBPACK_IMPORTED_MODULE_0__.radians,
      y0 = a[1] * _math__WEBPACK_IMPORTED_MODULE_0__.radians,
      x1 = b[0] * _math__WEBPACK_IMPORTED_MODULE_0__.radians,
      y1 = b[1] * _math__WEBPACK_IMPORTED_MODULE_0__.radians,
      cy0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      sy0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y0),
      cy1 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y1),
      sy1 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y1),
      kx0 = cy0 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(x0),
      ky0 = cy0 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(x0),
      kx1 = cy1 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(x1),
      ky1 = cy1 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(x1),
      d = 2 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)((0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math__WEBPACK_IMPORTED_MODULE_0__.haversin)(y1 - y0) + cy0 * cy1 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.haversin)(x1 - x0))),
      k = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(d);
  var interpolate = d ? function (t) {
    var B = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(t *= d) / k,
        A = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__.degrees, (0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(z, (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + y * y)) * _math__WEBPACK_IMPORTED_MODULE_0__.degrees];
  } : function () {
    return [x0 * _math__WEBPACK_IMPORTED_MODULE_0__.degrees, y0 * _math__WEBPACK_IMPORTED_MODULE_0__.degrees];
  };
  interpolate.distance = d;
  return interpolate;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/length.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/length.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");




var lengthSum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda0,
    sinPhi0,
    cosPhi0;
var lengthStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: lengthLineStart,
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"]
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
}

function lengthPointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_1__.radians;
  lambda0 = lambda, sinPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi), cosPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math__WEBPACK_IMPORTED_MODULE_1__.radians;
  var sinPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      delta = (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda - lambda0),
      cosDelta = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(delta),
      sinDelta = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add((0,_math__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math__WEBPACK_IMPORTED_MODULE_1__.sqrt)(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  lengthSum.reset();
  (0,_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, lengthStream);
  return +lengthSum;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": function() { return /* binding */ abs; },
/* harmony export */   "acos": function() { return /* binding */ acos; },
/* harmony export */   "asin": function() { return /* binding */ asin; },
/* harmony export */   "atan": function() { return /* binding */ atan; },
/* harmony export */   "atan2": function() { return /* binding */ atan2; },
/* harmony export */   "ceil": function() { return /* binding */ ceil; },
/* harmony export */   "cos": function() { return /* binding */ cos; },
/* harmony export */   "degrees": function() { return /* binding */ degrees; },
/* harmony export */   "epsilon": function() { return /* binding */ epsilon; },
/* harmony export */   "epsilon2": function() { return /* binding */ epsilon2; },
/* harmony export */   "exp": function() { return /* binding */ exp; },
/* harmony export */   "floor": function() { return /* binding */ floor; },
/* harmony export */   "halfPi": function() { return /* binding */ halfPi; },
/* harmony export */   "haversin": function() { return /* binding */ haversin; },
/* harmony export */   "log": function() { return /* binding */ log; },
/* harmony export */   "pi": function() { return /* binding */ pi; },
/* harmony export */   "pow": function() { return /* binding */ pow; },
/* harmony export */   "quarterPi": function() { return /* binding */ quarterPi; },
/* harmony export */   "radians": function() { return /* binding */ radians; },
/* harmony export */   "sign": function() { return /* binding */ sign; },
/* harmony export */   "sin": function() { return /* binding */ sin; },
/* harmony export */   "sqrt": function() { return /* binding */ sqrt; },
/* harmony export */   "tan": function() { return /* binding */ tan; },
/* harmony export */   "tau": function() { return /* binding */ tau; }
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function haversin(x) {
  return (x = sin(x / 2)) * x;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ noop; }
/* harmony export */ });
function noop() {}

/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");



var areaSum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    areaRingSum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    x00,
    y00,
    x0,
    y0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function () {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function () {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
    areaSum.add((0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(areaRingSum));
    areaRingSum.reset();
  },
  result: function () {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ __webpack_exports__["default"] = (areaStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");

var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function () {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (boundsStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
 // TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function () {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function () {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function () {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ __webpack_exports__["default"] = (centroidStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ PathContext; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");


function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function (_) {
    return this._radius = _, this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function (x, y) {
    switch (this._point) {
      case 0:
        {
          this._context.moveTo(x, y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._context.lineTo(x, y);

          break;
        }

      default:
        {
          this._context.moveTo(x + this._radius, y);

          this._context.arc(x, y, this._radius, 0, _math__WEBPACK_IMPORTED_MODULE_0__.tau);

          break;
        }
    }
  },
  result: _noop__WEBPACK_IMPORTED_MODULE_1__["default"]
};

/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./measure */ "./node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./string */ "./node_modules/d3-geo/src/path/string.js");








/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(contextStream));
    }

    return contextStream.result();
  }

  path.area = function (object) {
    (0,_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_area__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _area__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.measure = function (object) {
    (0,_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_measure__WEBPACK_IMPORTED_MODULE_6__["default"]));
    return _measure__WEBPACK_IMPORTED_MODULE_6__["default"].result();
  };

  path.bounds = function (object) {
    (0,_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_bounds__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function (object) {
    (0,_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_centroid__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function (_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity__WEBPACK_IMPORTED_MODULE_0__["default"]) : (projection = _).stream, path) : projection;
  };

  path.context = function (_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string__WEBPACK_IMPORTED_MODULE_7__["default"]()) : new _context__WEBPACK_IMPORTED_MODULE_5__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function (_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/path/measure.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");



var lengthSum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;
var lengthStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: function () {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function () {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  polygonStart: function () {
    lengthRing = true;
  },
  polygonEnd: function () {
    lengthRing = null;
  },
  result: function () {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math__WEBPACK_IMPORTED_MODULE_1__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (lengthStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ PathString; }
/* harmony export */ });
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function (_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function (x, y) {
    switch (this._point) {
      case 0:
        {
          this._string.push("M", x, ",", y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._string.push("L", x, ",", y);

          break;
        }

      default:
        {
          if (this._circle == null) this._circle = circle(this._radius);

          this._string.push("M", x, ",", y, this._circle);

          break;
        }
    }
  },
  result: function () {
    if (this._string.length) {
      var result = this._string.join("");

      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/polygonContains.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo/src/polygonContains.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



var sum = (0,_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [(0,_math__WEBPACK_IMPORTED_MODULE_2__.sin)(lambda), -(0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(lambda), 0],
      angle = 0,
      winding = 0;
  sum.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__.quarterPi,
        sinPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_2__.sin)(phi0),
        cosPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__.quarterPi,
          sinPhi1 = (0,_math__WEBPACK_IMPORTED_MODULE_2__.sin)(phi1),
          cosPhi1 = (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math__WEBPACK_IMPORTED_MODULE_2__.pi,
          k = sinPhi0 * sinPhi1;
      sum.add((0,_math__WEBPACK_IMPORTED_MODULE_2__.atan2)(k * sign * (0,_math__WEBPACK_IMPORTED_MODULE_2__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math__WEBPACK_IMPORTED_MODULE_2__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math__WEBPACK_IMPORTED_MODULE_2__.tau : delta; // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?

      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)((0,_cartesian__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point0), (0,_cartesian__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point1));
        (0,_cartesian__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(normal, arc);
        (0,_cartesian__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math__WEBPACK_IMPORTED_MODULE_2__.asin)(intersection[2]);

        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  } // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.


  return (angle < -_math__WEBPACK_IMPORTED_MODULE_2__.epsilon || angle < _math__WEBPACK_IMPORTED_MODULE_2__.epsilon && sum < -_math__WEBPACK_IMPORTED_MODULE_2__.epsilon) ^ winding & 1;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albers.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albers.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conicEqualArea__WEBPACK_IMPORTED_MODULE_0__["default"])().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albersUsa.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albersUsa.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _albers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./albers */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");



 // The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.

function multiplex(streams) {
  var n = streams.length;
  return {
    point: function (x, y) {
      var i = -1;

      while (++i < n) streams[i].point(x, y);
    },
    sphere: function () {
      var i = -1;

      while (++i < n) streams[i].sphere();
    },
    lineStart: function () {
      var i = -1;

      while (++i < n) streams[i].lineStart();
    },
    lineEnd: function () {
      var i = -1;

      while (++i < n) streams[i].lineEnd();
    },
    polygonStart: function () {
      var i = -1;

      while (++i < n) streams[i].polygonStart();
    },
    polygonEnd: function () {
      var i = -1;

      while (++i < n) streams[i].polygonEnd();
    }
  };
} // A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var cache,
      cacheStream,
      lower48 = (0,_albers__WEBPACK_IMPORTED_MODULE_1__["default"])(),
      lower48Point,
      alaska = (0,_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      alaskaPoint,
      // EPSG:3338
  hawaii = (0,_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      hawaiiPoint,
      // ESRI:102007
  point,
      pointStream = {
    point: function (x, y) {
      point = [x, y];
    }
  };

  function albersUsa(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function (coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };

  albersUsa.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function (_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function (_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function (_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(),
        x = +_[0],
        y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + _math__WEBPACK_IMPORTED_MODULE_0__.epsilon, y + 0.120 * k + _math__WEBPACK_IMPORTED_MODULE_0__.epsilon], [x - 0.214 * k - _math__WEBPACK_IMPORTED_MODULE_0__.epsilon, y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__.epsilon]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + _math__WEBPACK_IMPORTED_MODULE_0__.epsilon, y + 0.166 * k + _math__WEBPACK_IMPORTED_MODULE_0__.epsilon], [x - 0.115 * k - _math__WEBPACK_IMPORTED_MODULE_0__.epsilon, y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__.epsilon]]).stream(pointStream);
    return reset();
  };

  albersUsa.fitExtent = function (extent, object) {
    return (0,_fit__WEBPACK_IMPORTED_MODULE_3__.fitExtent)(albersUsa, extent, object);
  };

  albersUsa.fitSize = function (size, object) {
    return (0,_fit__WEBPACK_IMPORTED_MODULE_3__.fitSize)(albersUsa, size, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthal.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalInvert": function() { return /* binding */ azimuthalInvert; },
/* harmony export */   "azimuthalRaw": function() { return /* binding */ azimuthalRaw; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");

function azimuthalRaw(scale) {
  return function (x, y) {
    var cx = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(x),
        cy = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y),
        k = scale(cx * cy);
    return [k * cy * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(x), k * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y)];
  };
}
function azimuthalInvert(angle) {
  return function (x, y) {
    var z = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + y * y),
        c = angle(z),
        sc = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(c),
        cc = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(c);
    return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(x * sc, z * cc), (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)(z && y * sc / z)];
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEqualAreaRaw": function() { return /* binding */ azimuthalEqualAreaRaw; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



var azimuthalEqualAreaRaw = (0,_azimuthal__WEBPACK_IMPORTED_MODULE_1__.azimuthalRaw)(function (cxcy) {
  return (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = (0,_azimuthal__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(function (z) {
  return 2 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)(z / 2);
});
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEquidistantRaw": function() { return /* binding */ azimuthalEquidistantRaw; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



var azimuthalEquidistantRaw = (0,_azimuthal__WEBPACK_IMPORTED_MODULE_1__.azimuthalRaw)(function (c) {
  return (c = (0,_math__WEBPACK_IMPORTED_MODULE_0__.acos)(c)) && c / (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(c);
});
azimuthalEquidistantRaw.invert = (0,_azimuthal__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(function (z) {
  return z;
});
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conic.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conic.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicProjection": function() { return /* binding */ conicProjection; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");


function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math__WEBPACK_IMPORTED_MODULE_0__.pi / 3,
      m = (0,_index__WEBPACK_IMPORTED_MODULE_1__.projectionMutator)(projectAt),
      p = m(phi0, phi1);

  p.parallels = function (_) {
    return arguments.length ? m(phi0 = _[0] * _math__WEBPACK_IMPORTED_MODULE_0__.radians, phi1 = _[1] * _math__WEBPACK_IMPORTED_MODULE_0__.radians) : [phi0 * _math__WEBPACK_IMPORTED_MODULE_0__.degrees, phi1 * _math__WEBPACK_IMPORTED_MODULE_0__.degrees];
  };

  return p;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicConformal.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicConformal.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicConformalRaw": function() { return /* binding */ conicConformalRaw; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo/src/projection/mercator.js");




function tany(y) {
  return (0,_math__WEBPACK_IMPORTED_MODULE_0__.tan)((_math__WEBPACK_IMPORTED_MODULE_0__.halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (0,_math__WEBPACK_IMPORTED_MODULE_0__.log)(cy0 / (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (0,_math__WEBPACK_IMPORTED_MODULE_0__.log)(tany(y1) / tany(y0)),
      f = cy0 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y0), n) / n;
  if (!n) return _mercator__WEBPACK_IMPORTED_MODULE_2__.mercatorRaw;

  function project(x, y) {
    if (f > 0) {
      if (y < -_math__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = -_math__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math__WEBPACK_IMPORTED_MODULE_0__.epsilon;
    } else {
      if (y > _math__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = _math__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math__WEBPACK_IMPORTED_MODULE_0__.epsilon;
    }

    var r = f / (0,_math__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y), n);
    return [r * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(n * x), f - r * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(n * x)];
  }

  project.invert = function (x, y) {
    var fy = f - y,
        r = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + fy * fy);
    return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(fy)) / n * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sign)(fy), 2 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math__WEBPACK_IMPORTED_MODULE_0__.pow)(f / r, 1 / n)) - _math__WEBPACK_IMPORTED_MODULE_0__.halfPi];
  };

  return project;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic__WEBPACK_IMPORTED_MODULE_1__.conicProjection)(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEqualArea.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEqualAreaRaw": function() { return /* binding */ conicEqualAreaRaw; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cylindricalEqualArea */ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js");



function conicEqualAreaRaw(y0, y1) {
  var sy0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y0),
      n = (sy0 + (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y1)) / 2; // Are the parallels symmetrical around the Equator?

  if ((0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) return (0,_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__.cylindricalEqualAreaRaw)(y0);
  var c = 1 + sy0 * (2 * n - sy0),
      r0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c) / n;

  function project(x, y) {
    var r = (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c - 2 * n * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y)) / n;
    return [r * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(x *= n), r0 - r * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(x)];
  }

  project.invert = function (x, y) {
    var r0y = r0 - y;
    return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(r0y)) / n * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sign)(r0y), (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic__WEBPACK_IMPORTED_MODULE_1__.conicProjection)(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEquidistant.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEquidistantRaw": function() { return /* binding */ conicEquidistantRaw; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _equirectangular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equirectangular */ "./node_modules/d3-geo/src/projection/equirectangular.js");



function conicEquidistantRaw(y0, y1) {
  var cy0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (cy0 - (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (y1 - y0),
      g = cy0 / n + y0;
  if ((0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) return _equirectangular__WEBPACK_IMPORTED_MODULE_2__.equirectangularRaw;

  function project(x, y) {
    var gy = g - y,
        nx = n * x;
    return [gy * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(nx), g - gy * (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(nx)];
  }

  project.invert = function (x, y) {
    var gy = g - y;
    return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math__WEBPACK_IMPORTED_MODULE_0__.abs)(gy)) / n * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sign)(gy), g - (0,_math__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + gy * gy)];
  };

  return project;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic__WEBPACK_IMPORTED_MODULE_1__.conicProjection)(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cylindricalEqualAreaRaw": function() { return /* binding */ cylindricalEqualAreaRaw; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, (0,_math__WEBPACK_IMPORTED_MODULE_0__.asin)(y * cosPhi0)];
  };

  return forward;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/equirectangular.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/equirectangular.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "equirectangularRaw": function() { return /* binding */ equirectangularRaw; }
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index__WEBPACK_IMPORTED_MODULE_0__["default"])(equirectangularRaw).scale(152.63);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fitExtent": function() { return /* binding */ fitExtent; },
/* harmony export */   "fitSize": function() { return /* binding */ fitSize; }
/* harmony export */ });
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds */ "./node_modules/d3-geo/src/path/bounds.js");


function fitExtent(projection, extent, object) {
  var w = extent[1][0] - extent[0][0],
      h = extent[1][1] - extent[0][1],
      clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]));
  var b = _path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"].result(),
      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
  if (clip != null) projection.clipExtent(clip);
  return projection.scale(k * 150).translate([x, y]);
}
function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/gnomonic.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/gnomonic.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "gnomonicRaw": function() { return /* binding */ gnomonicRaw; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function gnomonicRaw(x, y) {
  var cy = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y),
      k = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}
gnomonicRaw.invert = (0,_azimuthal__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math__WEBPACK_IMPORTED_MODULE_0__.atan);
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index__WEBPACK_IMPORTED_MODULE_2__["default"])(gnomonicRaw).scale(144.049).clipAngle(60);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _clip_extent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/extent */ "./node_modules/d3-geo/src/clip/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");





function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? _identity__WEBPACK_IMPORTED_MODULE_1__["default"] : (0,_transform__WEBPACK_IMPORTED_MODULE_2__.transformer)({
    point: function (x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1,
      tx = 0,
      ty = 0,
      sx = 1,
      sy = 1,
      transform = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      // scale, translate and reflect
  x0 = null,
      y0,
      x1,
      y1,
      clip = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      // clip extent
  cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function (stream) {
      return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));
    },
    clipExtent: function (_) {
      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_1__["default"]) : (0,_clip_extent__WEBPACK_IMPORTED_MODULE_0__.clipExtent)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function (_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function (extent, object) {
      return (0,_fit__WEBPACK_IMPORTED_MODULE_3__.fitExtent)(projection, extent, object);
    },
    fitSize: function (size, object) {
      return (0,_fit__WEBPACK_IMPORTED_MODULE_3__.fitSize)(projection, size, object);
    }
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ projection; },
/* harmony export */   "projectionMutator": function() { return /* binding */ projectionMutator; }
/* harmony export */ });
/* harmony import */ var _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/antimeridian */ "./node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../clip/circle */ "./node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_extent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/extent */ "./node_modules/d3-geo/src/clip/extent.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../compose */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resample */ "./node_modules/d3-geo/src/projection/resample.js");










var transformRadians = (0,_transform__WEBPACK_IMPORTED_MODULE_7__.transformer)({
  point: function (x, y) {
    this.stream.point(x * _math__WEBPACK_IMPORTED_MODULE_5__.radians, y * _math__WEBPACK_IMPORTED_MODULE_5__.radians);
  }
});
function projection(project) {
  return projectionMutator(function () {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project,
      k = 150,
      // scale
  x = 480,
      y = 250,
      // translate
  dx,
      dy,
      lambda = 0,
      phi = 0,
      // center
  deltaLambda = 0,
      deltaPhi = 0,
      deltaGamma = 0,
      rotate,
      projectRotate,
      // rotate
  theta = null,
      preclip = _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"],
      // clip angle
  x0 = null,
      y0,
      x1,
      y1,
      postclip = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      // clip extent
  delta2 = 0.5,
      projectResample = (0,_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2),
      // precision
  cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * _math__WEBPACK_IMPORTED_MODULE_5__.radians, point[1] * _math__WEBPACK_IMPORTED_MODULE_5__.radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * _math__WEBPACK_IMPORTED_MODULE_5__.degrees, point[1] * _math__WEBPACK_IMPORTED_MODULE_5__.degrees];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
  };

  projection.clipAngle = function (_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle__WEBPACK_IMPORTED_MODULE_1__["default"])(theta = _ * _math__WEBPACK_IMPORTED_MODULE_5__.radians, 6 * _math__WEBPACK_IMPORTED_MODULE_5__.radians) : (theta = null, _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"]), reset()) : theta * _math__WEBPACK_IMPORTED_MODULE_5__.degrees;
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_4__["default"]) : (0,_clip_extent__WEBPACK_IMPORTED_MODULE_2__.clipExtent)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function (_) {
    return arguments.length ? (lambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__.radians, phi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__.radians, recenter()) : [lambda * _math__WEBPACK_IMPORTED_MODULE_5__.degrees, phi * _math__WEBPACK_IMPORTED_MODULE_5__.degrees];
  };

  projection.rotate = function (_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__.radians, deltaPhi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__.radians : 0, recenter()) : [deltaLambda * _math__WEBPACK_IMPORTED_MODULE_5__.degrees, deltaPhi * _math__WEBPACK_IMPORTED_MODULE_5__.degrees, deltaGamma * _math__WEBPACK_IMPORTED_MODULE_5__.degrees];
  };

  projection.precision = function (_) {
    return arguments.length ? (projectResample = (0,_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2 = _ * _), reset()) : (0,_math__WEBPACK_IMPORTED_MODULE_5__.sqrt)(delta2);
  };

  projection.fitExtent = function (extent, object) {
    return (0,_fit__WEBPACK_IMPORTED_MODULE_8__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return (0,_fit__WEBPACK_IMPORTED_MODULE_8__.fitSize)(projection, size, object);
  };

  function recenter() {
    projectRotate = (0,_compose__WEBPACK_IMPORTED_MODULE_3__["default"])(rotate = (0,_rotation__WEBPACK_IMPORTED_MODULE_6__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function () {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/mercator.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/mercator.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "mercatorProjection": function() { return /* binding */ mercatorProjection; },
/* harmony export */   "mercatorRaw": function() { return /* binding */ mercatorRaw; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function mercatorRaw(lambda, phi) {
  return [lambda, (0,_math__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math__WEBPACK_IMPORTED_MODULE_0__.tan)((_math__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2))];
}

mercatorRaw.invert = function (x, y) {
  return [x, 2 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math__WEBPACK_IMPORTED_MODULE_0__.exp)(y)) - _math__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return mercatorProjection(mercatorRaw).scale(961 / _math__WEBPACK_IMPORTED_MODULE_0__.tau);
}
function mercatorProjection(project) {
  var m = (0,_index__WEBPACK_IMPORTED_MODULE_2__["default"])(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null,
      y0,
      x1,
      y1; // clip extent

  m.scale = function (_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function (_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function (_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function (_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math__WEBPACK_IMPORTED_MODULE_0__.pi * scale(),
        t = m((0,_rotation__WEBPACK_IMPORTED_MODULE_1__["default"])(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/naturalEarth1.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/naturalEarth1.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "naturalEarth1Raw": function() { return /* binding */ naturalEarth1Raw; }
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");


function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2;
  return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))];
}

naturalEarth1Raw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta;

  do {
    var phi2 = phi * phi,
        phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while ((0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(delta) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon && --i > 0);

  return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index__WEBPACK_IMPORTED_MODULE_0__["default"])(naturalEarth1Raw).scale(175.295);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/orthographic.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/orthographic.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "orthographicRaw": function() { return /* binding */ orthographicRaw; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function orthographicRaw(x, y) {
  return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y) * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(x), (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y)];
}
orthographicRaw.invert = (0,_azimuthal__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math__WEBPACK_IMPORTED_MODULE_0__.asin);
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index__WEBPACK_IMPORTED_MODULE_2__["default"])(orthographicRaw).scale(249.5).clipAngle(90 + _math__WEBPACK_IMPORTED_MODULE_0__.epsilon);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/resample.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/resample.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");



var maxDepth = 16,
    // maximum depth of subdivision
cosMinDistance = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(30 * _math__WEBPACK_IMPORTED_MODULE_1__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform__WEBPACK_IMPORTED_MODULE_2__.transformer)({
    point: function (x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {
  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;

    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.asin)(c /= m),
          lambda2 = (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)((0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(c) - 1) < _math__WEBPACK_IMPORTED_MODULE_1__.epsilon || (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - lambda1) < _math__WEBPACK_IMPORTED_MODULE_1__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math__WEBPACK_IMPORTED_MODULE_1__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;

      if (dz * dz / d2 > delta2 // perpendicular projected distance
      || (0,_math__WEBPACK_IMPORTED_MODULE_1__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }

  return function (stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
    lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function () {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function () {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian__WEBPACK_IMPORTED_MODULE_0__.cartesian)([lambda, phi]),
          p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/stereographic.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/stereographic.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "stereographicRaw": function() { return /* binding */ stereographicRaw; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function stereographicRaw(x, y) {
  var cy = (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(y),
      k = 1 + (0,_math__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}
stereographicRaw.invert = (0,_azimuthal__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(function (z) {
  return 2 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.atan)(z);
});
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index__WEBPACK_IMPORTED_MODULE_2__["default"])(stereographicRaw).scale(250).clipAngle(142);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/transverseMercator.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "transverseMercatorRaw": function() { return /* binding */ transverseMercatorRaw; }
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo/src/projection/mercator.js");


function transverseMercatorRaw(lambda, phi) {
  return [(0,_math__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math__WEBPACK_IMPORTED_MODULE_0__.tan)((_math__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function (x, y) {
  return [-y, 2 * (0,_math__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math__WEBPACK_IMPORTED_MODULE_0__.exp)(x)) - _math__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var m = (0,_mercator__WEBPACK_IMPORTED_MODULE_1__.mercatorProjection)(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function (_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function (_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90]).scale(159.155);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/rotation.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/rotation.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "rotateRadians": function() { return /* binding */ rotateRadians; }
/* harmony export */ });
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [lambda > _math__WEBPACK_IMPORTED_MODULE_1__.pi ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__.tau : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__.pi ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math__WEBPACK_IMPORTED_MODULE_1__.tau) ? deltaPhi || deltaGamma ? (0,_compose__WEBPACK_IMPORTED_MODULE_0__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}

function forwardRotationLambda(deltaLambda) {
  return function (lambda, phi) {
    return lambda += deltaLambda, [lambda > _math__WEBPACK_IMPORTED_MODULE_1__.pi ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__.tau : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__.pi ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
        x = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda) * cosPhi,
        y = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda) * cosPhi,
        z = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [(0,_math__WEBPACK_IMPORTED_MODULE_1__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), (0,_math__WEBPACK_IMPORTED_MODULE_1__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)];
  }

  rotation.invert = function (lambda, phi) {
    var cosPhi = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
        x = (0,_math__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda) * cosPhi,
        y = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda) * cosPhi,
        z = (0,_math__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [(0,_math__WEBPACK_IMPORTED_MODULE_1__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), (0,_math__WEBPACK_IMPORTED_MODULE_1__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math__WEBPACK_IMPORTED_MODULE_1__.radians, rotate[1] * _math__WEBPACK_IMPORTED_MODULE_1__.radians, rotate.length > 2 ? rotate[2] * _math__WEBPACK_IMPORTED_MODULE_1__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__.radians, coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__.radians);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__.degrees, coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__.degrees, coordinates;
  }

  forward.invert = function (coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__.radians, coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__.radians);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__.degrees, coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__.degrees, coordinates;
  };

  return forward;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function (object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function (object, stream) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function (object, stream) {
    stream.sphere();
  },
  Point: function (object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function (object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function (object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function (object, stream) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1,
      n = coordinates.length - closed,
      coordinate;
  stream.lineStart();

  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);

  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1,
      n = coordinates.length;
  stream.polygonStart();

  while (++i < n) streamLine(coordinates[i], stream, 1);

  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "transformer": function() { return /* binding */ transformer; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function (stream) {
    var s = new TransformStream();

    for (var key in methods) s[key] = methods[key];

    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function (x, y) {
    this.stream.point(x, y);
  },
  sphere: function () {
    this.stream.sphere();
  },
  lineStart: function () {
    this.stream.lineStart();
  },
  lineEnd: function () {
    this.stream.lineEnd();
  },
  polygonStart: function () {
    this.stream.polygonStart();
  },
  polygonEnd: function () {
    this.stream.polygonEnd();
  }
};

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


var has = Object.prototype.hasOwnProperty,
    prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */

function Events() {} //
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//


if (Object.create) {
  Events.prototype = Object.create(null); //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //

  if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */


function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */


function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once),
      evt = prefix ? prefix + event : event;
  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
  return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */


function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */


function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */


EventEmitter.prototype.eventNames = function eventNames() {
  var names = [],
      events,
      name;
  if (this._eventsCount === 0) return names;

  for (name in events = this._events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */


EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event,
      handlers = this._events[evt];
  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */


EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event,
      listeners = this._events[evt];
  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */


EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return false;
  var listeners = this._events[evt],
      len = arguments.length,
      args,
      i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1:
        return listeners.fn.call(listeners.context), true;

      case 2:
        return listeners.fn.call(listeners.context, a1), true;

      case 3:
        return listeners.fn.call(listeners.context, a1, a2), true;

      case 4:
        return listeners.fn.call(listeners.context, a1, a2, a3), true;

      case 5:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

      case 6:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len - 1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length,
        j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1:
          listeners[i].fn.call(listeners[i].context);
          break;

        case 2:
          listeners[i].fn.call(listeners[i].context, a1);
          break;

        case 3:
          listeners[i].fn.call(listeners[i].context, a1, a2);
          break;

        case 4:
          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
          break;

        default:
          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
            args[j - 1] = arguments[j];
          }
          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return this;

  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
        events.push(listeners[i]);
      }
    } //
    // Reset the array, or remove it completely if we have no more listeners.
    //


    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
  }

  return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
}; //
// Alias methods names because people roll like that.
//


EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
// Expose the prefix.
//

EventEmitter.prefixed = prefix; //
// Allow `EventEmitter` to be imported as module namespace.
//

EventEmitter.EventEmitter = EventEmitter; //
// Expose the module.
//

if (true) {
  module.exports = EventEmitter;
}

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ (function(module) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

/***/ }),

/***/ "./node_modules/fuzzy/lib/fuzzy.js":
/*!*****************************************!*\
  !*** ./node_modules/fuzzy/lib/fuzzy.js ***!
  \*****************************************/
/***/ (function(module) {

/*
 * Fuzzy
 * https://github.com/myork/fuzzy
 *
 * Copyright (c) 2012 Matt York
 * Licensed under the MIT license.
 */
(function () {
  var root = this;
  var fuzzy = {}; // Use in node or in browser

  if (true) {
    module.exports = fuzzy;
  } else {} // Return all elements of `array` that have a fuzzy
  // match against `pattern`.


  fuzzy.simpleFilter = function (pattern, array) {
    return array.filter(function (str) {
      return fuzzy.test(pattern, str);
    });
  }; // Does `pattern` fuzzy match `str`?


  fuzzy.test = function (pattern, str) {
    return fuzzy.match(pattern, str) !== null;
  }; // If `pattern` matches `str`, wrap each matching character
  // in `opts.pre` and `opts.post`. If no match, return null


  fuzzy.match = function (pattern, str, opts) {
    opts = opts || {};
    var patternIdx = 0,
        result = [],
        len = str.length,
        totalScore = 0,
        currScore = 0 // prefix
    ,
        pre = opts.pre || '' // suffix
    ,
        post = opts.post || '' // String to compare against. This might be a lowercase version of the
    // raw string
    ,
        compareString = opts.caseSensitive && str || str.toLowerCase(),
        ch;
    pattern = opts.caseSensitive && pattern || pattern.toLowerCase(); // For each character in the string, either add it to the result
    // or wrap in template if it's the next string in the pattern

    for (var idx = 0; idx < len; idx++) {
      ch = str[idx];

      if (compareString[idx] === pattern[patternIdx]) {
        ch = pre + ch + post;
        patternIdx += 1; // consecutive characters should increase the score more than linearly

        currScore += 1 + currScore;
      } else {
        currScore = 0;
      }

      totalScore += currScore;
      result[result.length] = ch;
    } // return rendered string if we have a match for every char


    if (patternIdx === pattern.length) {
      // if the string is an exact match with pattern, totalScore should be maxed
      totalScore = compareString === pattern ? Infinity : totalScore;
      return {
        rendered: result.join(''),
        score: totalScore
      };
    }

    return null;
  }; // The normal entry point. Filters `arr` for matches against `pattern`.
  // It returns an array with matching values of the type:
  //
  //     [{
  //         string:   '<b>lah' // The rendered string
  //       , index:    2        // The index of the element in `arr`
  //       , original: 'blah'   // The original element in `arr`
  //     }]
  //
  // `opts` is an optional argument bag. Details:
  //
  //    opts = {
  //        // string to put before a matching character
  //        pre:     '<b>'
  //
  //        // string to put after matching character
  //      , post:    '</b>'
  //
  //        // Optional function. Input is an entry in the given arr`,
  //        // output should be the string to test `pattern` against.
  //        // In this example, if `arr = [{crying: 'koala'}]` we would return
  //        // 'koala'.
  //      , extract: function(arg) { return arg.crying; }
  //    }


  fuzzy.filter = function (pattern, arr, opts) {
    if (!arr || arr.length === 0) {
      return [];
    }

    if (typeof pattern !== 'string') {
      return arr;
    }

    opts = opts || {};
    return arr.reduce(function (prev, element, idx, arr) {
      var str = element;

      if (opts.extract) {
        str = opts.extract(element);
      }

      var rendered = fuzzy.match(pattern, str, opts);

      if (rendered != null) {
        prev[prev.length] = {
          string: rendered.rendered,
          score: rendered.score,
          index: idx,
          original: element
        };
      }

      return prev;
    }, []) // Sort by score. Browsers are inconsistent wrt stable/unstable
    // sorting, so force stable by using the index in the case of tie.
    // See http://ofb.net/~sethml/is-sort-stable.html
    .sort(function (a, b) {
      var compare = b.score - a.score;
      if (compare) return compare;
      return a.index - b.index;
    });
  };
})();

/***/ }),

/***/ "./node_modules/is-plain-obj/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-plain-obj/index.js ***!
  \********************************************/
/***/ (function(module) {

"use strict";


var toString = Object.prototype.toString;

module.exports = function (x) {
  var prototype;
  return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};

/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function () {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = debounce;

/***/ }),

/***/ "./node_modules/select2/dist/js/select2.js":
/*!*************************************************!*\
  !*** ./node_modules/select2/dist/js/select2.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Select2 4.1.0-rc.0
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
;

(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "jquery")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 = function () {
    // Restore the Select2 AMD loader so it can be used
    // Needed mostly in the language files, where the loader is not inserted
    if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
      var S2 = jQuery.fn.select2.amd;
    }

    var S2;

    (function () {
      if (!S2 || !S2.requirejs) {
        if (!S2) {
          S2 = {};
        } else {
          require = S2;
        }
        /**
         * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
         * Released under MIT license, http://github.com/requirejs/almond/LICENSE
         */
        //Going sloppy to avoid 'use strict' string cost, but strict practices should
        //be followed.

        /*global setTimeout: false */


        var requirejs, require, define;

        (function (undef) {
          var main,
              req,
              makeMap,
              handlers,
              defined = {},
              waiting = {},
              config = {},
              defining = {},
              hasOwn = Object.prototype.hasOwnProperty,
              aps = [].slice,
              jsSuffixRegExp = /\.js$/;

          function hasProp(obj, prop) {
            return hasOwn.call(obj, prop);
          }
          /**
           * Given a relative module name, like ./something, normalize it to
           * a real name that can be mapped to a path.
           * @param {String} name the relative name
           * @param {String} baseName a real name that the name arg is relative
           * to.
           * @returns {String} normalized name
           */


          function normalize(name, baseName) {
            var nameParts,
                nameSegment,
                mapValue,
                foundMap,
                lastIndex,
                foundI,
                foundStarMap,
                starI,
                i,
                j,
                part,
                normalizedBaseParts,
                baseParts = baseName && baseName.split("/"),
                map = config.map,
                starMap = map && map['*'] || {}; //Adjust any relative paths.

            if (name) {
              name = name.split('/');
              lastIndex = name.length - 1; // If wanting node ID compatibility, strip .js from end
              // of IDs. Have to do this here, and not in nameToUrl
              // because node allows either .js or non .js to map
              // to same file.

              if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
              } // Starts with a '.' so need the baseName


              if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
              } //start trimDots


              for (i = 0; i < name.length; i++) {
                part = name[i];

                if (part === '.') {
                  name.splice(i, 1);
                  i -= 1;
                } else if (part === '..') {
                  // If at the start, or previous value is still ..,
                  // keep them so that when converted to a path it may
                  // still work when converted to a path, even though
                  // as an ID it is less than ideal. In larger point
                  // releases, may be better to just kick out an error.
                  if (i === 0 || i === 1 && name[2] === '..' || name[i - 1] === '..') {
                    continue;
                  } else if (i > 0) {
                    name.splice(i - 1, 2);
                    i -= 2;
                  }
                }
              } //end trimDots


              name = name.join('/');
            } //Apply map config if available.


            if ((baseParts || starMap) && map) {
              nameParts = name.split('/');

              for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                  //Find the longest baseName segment match in the config.
                  //So, do joins on the biggest to smallest lengths of baseParts.
                  for (j = baseParts.length; j > 0; j -= 1) {
                    mapValue = map[baseParts.slice(0, j).join('/')]; //baseName segment has  config, find if it has one for
                    //this name.

                    if (mapValue) {
                      mapValue = mapValue[nameSegment];

                      if (mapValue) {
                        //Match, update name to the new value.
                        foundMap = mapValue;
                        foundI = i;
                        break;
                      }
                    }
                  }
                }

                if (foundMap) {
                  break;
                } //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.


                if (!foundStarMap && starMap && starMap[nameSegment]) {
                  foundStarMap = starMap[nameSegment];
                  starI = i;
                }
              }

              if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
              }

              if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
              }
            }

            return name;
          }

          function makeRequire(relName, forceSync) {
            return function () {
              //A version of a require function that passes a moduleName
              //value for items that may need to
              //look up paths relative to the moduleName
              var args = aps.call(arguments, 0); //If first arg is not require('string'), and there is only
              //one arg, it is the array form without a callback. Insert
              //a null so that the following concat is correct.

              if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
              }

              return req.apply(undef, args.concat([relName, forceSync]));
            };
          }

          function makeNormalize(relName) {
            return function (name) {
              return normalize(name, relName);
            };
          }

          function makeLoad(depName) {
            return function (value) {
              defined[depName] = value;
            };
          }

          function callDep(name) {
            if (hasProp(waiting, name)) {
              var args = waiting[name];
              delete waiting[name];
              defining[name] = true;
              main.apply(undef, args);
            }

            if (!hasProp(defined, name) && !hasProp(defining, name)) {
              throw new Error('No ' + name);
            }

            return defined[name];
          } //Turns a plugin!resource to [plugin, resource]
          //with the plugin being undefined if the name
          //did not have a plugin prefix.


          function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;

            if (index > -1) {
              prefix = name.substring(0, index);
              name = name.substring(index + 1, name.length);
            }

            return [prefix, name];
          } //Creates a parts array for a relName where first part is plugin ID,
          //second part is resource ID. Assumes relName has already been normalized.


          function makeRelParts(relName) {
            return relName ? splitPrefix(relName) : [];
          }
          /**
           * Makes a name map, normalizing the name, and using a plugin
           * for normalization if necessary. Grabs a ref to plugin
           * too, as an optimization.
           */


          makeMap = function (name, relParts) {
            var plugin,
                parts = splitPrefix(name),
                prefix = parts[0],
                relResourceName = relParts[1];
            name = parts[1];

            if (prefix) {
              prefix = normalize(prefix, relResourceName);
              plugin = callDep(prefix);
            } //Normalize according


            if (prefix) {
              if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
              } else {
                name = normalize(name, relResourceName);
              }
            } else {
              name = normalize(name, relResourceName);
              parts = splitPrefix(name);
              prefix = parts[0];
              name = parts[1];

              if (prefix) {
                plugin = callDep(prefix);
              }
            } //Using ridiculous property names for space reasons


            return {
              f: prefix ? prefix + '!' + name : name,
              //fullName
              n: name,
              pr: prefix,
              p: plugin
            };
          };

          function makeConfig(name) {
            return function () {
              return config && config.config && config.config[name] || {};
            };
          }

          handlers = {
            require: function (name) {
              return makeRequire(name);
            },
            exports: function (name) {
              var e = defined[name];

              if (typeof e !== 'undefined') {
                return e;
              } else {
                return defined[name] = {};
              }
            },
            module: function (name) {
              return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
              };
            }
          };

          main = function (name, deps, callback, relName) {
            var cjsModule,
                depName,
                ret,
                map,
                i,
                relParts,
                args = [],
                callbackType = typeof callback,
                usingExports; //Use name if no relName

            relName = relName || name;
            relParts = makeRelParts(relName); //Call the callback to define the module, if necessary.

            if (callbackType === 'undefined' || callbackType === 'function') {
              //Pull out the defined dependencies and pass the ordered
              //values to the callback.
              //Default to [require, exports, module] if no deps
              deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;

              for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f; //Fast path CommonJS standard dependencies.

                if (depName === "require") {
                  args[i] = handlers.require(name);
                } else if (depName === "exports") {
                  //CommonJS module spec 1.1
                  args[i] = handlers.exports(name);
                  usingExports = true;
                } else if (depName === "module") {
                  //CommonJS module spec 1.1
                  cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                  args[i] = callDep(depName);
                } else if (map.p) {
                  map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                  args[i] = defined[depName];
                } else {
                  throw new Error(name + ' missing ' + depName);
                }
              }

              ret = callback ? callback.apply(defined[name], args) : undefined;

              if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                  defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                  //Use the return value from the function.
                  defined[name] = ret;
                }
              }
            } else if (name) {
              //May just be an object definition for the module. Only
              //worry about defining if have a module name.
              defined[name] = callback;
            }
          };

          requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
            if (typeof deps === "string") {
              if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
              } //Just return the module wanted. In this scenario, the
              //deps arg is the module name, and second arg (if passed)
              //is just the relName.
              //Normalize module name, if it contains . or ..


              return callDep(makeMap(deps, makeRelParts(callback)).f);
            } else if (!deps.splice) {
              //deps is a config object, not an array.
              config = deps;

              if (config.deps) {
                req(config.deps, config.callback);
              }

              if (!callback) {
                return;
              }

              if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
              } else {
                deps = undef;
              }
            } //Support require(['a'])


            callback = callback || function () {}; //If relName is a function, it is an errback handler,
            //so remove it.


            if (typeof relName === 'function') {
              relName = forceSync;
              forceSync = alt;
            } //Simulate async callback;


            if (forceSync) {
              main(undef, deps, callback, relName);
            } else {
              //Using a non-zero value because of concern for what old browsers
              //do, and latest browsers "upgrade" to 4 if lower value is used:
              //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
              //If want a value immediately, use require('id') instead -- something
              //that works in almond on the global level, but not guaranteed and
              //unlikely to work in other AMD implementations.
              setTimeout(function () {
                main(undef, deps, callback, relName);
              }, 4);
            }

            return req;
          };
          /**
           * Just drops the config on the floor, but returns req in case
           * the config return value is used.
           */


          req.config = function (cfg) {
            return req(cfg);
          };
          /**
           * Expose module registry for debugging and tooling
           */


          requirejs._defined = defined;

          define = function (name, deps, callback) {
            if (typeof name !== 'string') {
              throw new Error('See almond README: incorrect module build, no module name');
            } //This module may not have dependencies


            if (!deps.splice) {
              //deps is not an array, so probably means
              //an object literal or factory function for
              //the value. Adjust args.
              callback = deps;
              deps = [];
            }

            if (!hasProp(defined, name) && !hasProp(waiting, name)) {
              waiting[name] = [name, deps, callback];
            }
          };

          define.amd = {
            jQuery: true
          };
        })();

        S2.requirejs = requirejs;
        S2.require = require;
        S2.define = define;
      }
    })();

    S2.define("almond", function () {});
    /* global jQuery:false, $:false */

    S2.define('jquery', [], function () {
      var _$ = jQuery || $;

      if (_$ == null && console && console.error) {
        console.error('Select2: An instance of jQuery or a jQuery-compatible library was not ' + 'found. Make sure that you are including jQuery before Select2 on your ' + 'web page.');
      }

      return _$;
    });
    S2.define('select2/utils', ['jquery'], function ($) {
      var Utils = {};

      Utils.Extend = function (ChildClass, SuperClass) {
        var __hasProp = {}.hasOwnProperty;

        function BaseConstructor() {
          this.constructor = ChildClass;
        }

        for (var key in SuperClass) {
          if (__hasProp.call(SuperClass, key)) {
            ChildClass[key] = SuperClass[key];
          }
        }

        BaseConstructor.prototype = SuperClass.prototype;
        ChildClass.prototype = new BaseConstructor();
        ChildClass.__super__ = SuperClass.prototype;
        return ChildClass;
      };

      function getMethods(theClass) {
        var proto = theClass.prototype;
        var methods = [];

        for (var methodName in proto) {
          var m = proto[methodName];

          if (typeof m !== 'function') {
            continue;
          }

          if (methodName === 'constructor') {
            continue;
          }

          methods.push(methodName);
        }

        return methods;
      }

      Utils.Decorate = function (SuperClass, DecoratorClass) {
        var decoratedMethods = getMethods(DecoratorClass);
        var superMethods = getMethods(SuperClass);

        function DecoratedClass() {
          var unshift = Array.prototype.unshift;
          var argCount = DecoratorClass.prototype.constructor.length;
          var calledConstructor = SuperClass.prototype.constructor;

          if (argCount > 0) {
            unshift.call(arguments, SuperClass.prototype.constructor);
            calledConstructor = DecoratorClass.prototype.constructor;
          }

          calledConstructor.apply(this, arguments);
        }

        DecoratorClass.displayName = SuperClass.displayName;

        function ctr() {
          this.constructor = DecoratedClass;
        }

        DecoratedClass.prototype = new ctr();

        for (var m = 0; m < superMethods.length; m++) {
          var superMethod = superMethods[m];
          DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
        }

        var calledMethod = function (methodName) {
          // Stub out the original method if it's not decorating an actual method
          var originalMethod = function () {};

          if (methodName in DecoratedClass.prototype) {
            originalMethod = DecoratedClass.prototype[methodName];
          }

          var decoratedMethod = DecoratorClass.prototype[methodName];
          return function () {
            var unshift = Array.prototype.unshift;
            unshift.call(arguments, originalMethod);
            return decoratedMethod.apply(this, arguments);
          };
        };

        for (var d = 0; d < decoratedMethods.length; d++) {
          var decoratedMethod = decoratedMethods[d];
          DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
        }

        return DecoratedClass;
      };

      var Observable = function () {
        this.listeners = {};
      };

      Observable.prototype.on = function (event, callback) {
        this.listeners = this.listeners || {};

        if (event in this.listeners) {
          this.listeners[event].push(callback);
        } else {
          this.listeners[event] = [callback];
        }
      };

      Observable.prototype.trigger = function (event) {
        var slice = Array.prototype.slice;
        var params = slice.call(arguments, 1);
        this.listeners = this.listeners || {}; // Params should always come in as an array

        if (params == null) {
          params = [];
        } // If there are no arguments to the event, use a temporary object


        if (params.length === 0) {
          params.push({});
        } // Set the `_type` of the first object to the event


        params[0]._type = event;

        if (event in this.listeners) {
          this.invoke(this.listeners[event], slice.call(arguments, 1));
        }

        if ('*' in this.listeners) {
          this.invoke(this.listeners['*'], arguments);
        }
      };

      Observable.prototype.invoke = function (listeners, params) {
        for (var i = 0, len = listeners.length; i < len; i++) {
          listeners[i].apply(this, params);
        }
      };

      Utils.Observable = Observable;

      Utils.generateChars = function (length) {
        var chars = '';

        for (var i = 0; i < length; i++) {
          var randomChar = Math.floor(Math.random() * 36);
          chars += randomChar.toString(36);
        }

        return chars;
      };

      Utils.bind = function (func, context) {
        return function () {
          func.apply(context, arguments);
        };
      };

      Utils._convertData = function (data) {
        for (var originalKey in data) {
          var keys = originalKey.split('-');
          var dataLevel = data;

          if (keys.length === 1) {
            continue;
          }

          for (var k = 0; k < keys.length; k++) {
            var key = keys[k]; // Lowercase the first letter
            // By default, dash-separated becomes camelCase

            key = key.substring(0, 1).toLowerCase() + key.substring(1);

            if (!(key in dataLevel)) {
              dataLevel[key] = {};
            }

            if (k == keys.length - 1) {
              dataLevel[key] = data[originalKey];
            }

            dataLevel = dataLevel[key];
          }

          delete data[originalKey];
        }

        return data;
      };

      Utils.hasScroll = function (index, el) {
        // Adapted from the function created by @ShadowScripter
        // and adapted by @BillBarry on the Stack Exchange Code Review website.
        // The original code can be found at
        // http://codereview.stackexchange.com/q/13338
        // and was designed to be used with the Sizzle selector engine.
        var $el = $(el);
        var overflowX = el.style.overflowX;
        var overflowY = el.style.overflowY; //Check both x and y declarations

        if (overflowX === overflowY && (overflowY === 'hidden' || overflowY === 'visible')) {
          return false;
        }

        if (overflowX === 'scroll' || overflowY === 'scroll') {
          return true;
        }

        return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
      };

      Utils.escapeMarkup = function (markup) {
        var replaceMap = {
          '\\': '&#92;',
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          '\'': '&#39;',
          '/': '&#47;'
        }; // Do not try to escape the markup if it's not a string

        if (typeof markup !== 'string') {
          return markup;
        }

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
          return replaceMap[match];
        });
      }; // Cache objects in Utils.__cache instead of $.data (see #4346)


      Utils.__cache = {};
      var id = 0;

      Utils.GetUniqueElementId = function (element) {
        // Get a unique element Id. If element has no id,
        // creates a new unique number, stores it in the id
        // attribute and returns the new id with a prefix.
        // If an id already exists, it simply returns it with a prefix.
        var select2Id = element.getAttribute('data-select2-id');

        if (select2Id != null) {
          return select2Id;
        } // If element has id, use it.


        if (element.id) {
          select2Id = 'select2-data-' + element.id;
        } else {
          select2Id = 'select2-data-' + (++id).toString() + '-' + Utils.generateChars(4);
        }

        element.setAttribute('data-select2-id', select2Id);
        return select2Id;
      };

      Utils.StoreData = function (element, name, value) {
        // Stores an item in the cache for a specified element.
        // name is the cache key.
        var id = Utils.GetUniqueElementId(element);

        if (!Utils.__cache[id]) {
          Utils.__cache[id] = {};
        }

        Utils.__cache[id][name] = value;
      };

      Utils.GetData = function (element, name) {
        // Retrieves a value from the cache by its key (name)
        // name is optional. If no name specified, return
        // all cache items for the specified element.
        // and for a specified element.
        var id = Utils.GetUniqueElementId(element);

        if (name) {
          if (Utils.__cache[id]) {
            if (Utils.__cache[id][name] != null) {
              return Utils.__cache[id][name];
            }

            return $(element).data(name); // Fallback to HTML5 data attribs.
          }

          return $(element).data(name); // Fallback to HTML5 data attribs.
        } else {
          return Utils.__cache[id];
        }
      };

      Utils.RemoveData = function (element) {
        // Removes all cached items for a specified element.
        var id = Utils.GetUniqueElementId(element);

        if (Utils.__cache[id] != null) {
          delete Utils.__cache[id];
        }

        element.removeAttribute('data-select2-id');
      };

      Utils.copyNonInternalCssClasses = function (dest, src) {
        var classes;
        var destinationClasses = dest.getAttribute('class').trim().split(/\s+/);
        destinationClasses = destinationClasses.filter(function (clazz) {
          // Save all Select2 classes
          return clazz.indexOf('select2-') === 0;
        });
        var sourceClasses = src.getAttribute('class').trim().split(/\s+/);
        sourceClasses = sourceClasses.filter(function (clazz) {
          // Only copy non-Select2 classes
          return clazz.indexOf('select2-') !== 0;
        });
        var replacements = destinationClasses.concat(sourceClasses);
        dest.setAttribute('class', replacements.join(' '));
      };

      return Utils;
    });
    S2.define('select2/results', ['jquery', './utils'], function ($, Utils) {
      function Results($element, options, dataAdapter) {
        this.$element = $element;
        this.data = dataAdapter;
        this.options = options;

        Results.__super__.constructor.call(this);
      }

      Utils.Extend(Results, Utils.Observable);

      Results.prototype.render = function () {
        var $results = $('<ul class="select2-results__options" role="listbox"></ul>');

        if (this.options.get('multiple')) {
          $results.attr('aria-multiselectable', 'true');
        }

        this.$results = $results;
        return $results;
      };

      Results.prototype.clear = function () {
        this.$results.empty();
      };

      Results.prototype.displayMessage = function (params) {
        var escapeMarkup = this.options.get('escapeMarkup');
        this.clear();
        this.hideLoading();
        var $message = $('<li role="alert" aria-live="assertive"' + ' class="select2-results__option"></li>');
        var message = this.options.get('translations').get(params.message);
        $message.append(escapeMarkup(message(params.args)));
        $message[0].className += ' select2-results__message';
        this.$results.append($message);
      };

      Results.prototype.hideMessages = function () {
        this.$results.find('.select2-results__message').remove();
      };

      Results.prototype.append = function (data) {
        this.hideLoading();
        var $options = [];

        if (data.results == null || data.results.length === 0) {
          if (this.$results.children().length === 0) {
            this.trigger('results:message', {
              message: 'noResults'
            });
          }

          return;
        }

        data.results = this.sort(data.results);

        for (var d = 0; d < data.results.length; d++) {
          var item = data.results[d];
          var $option = this.option(item);
          $options.push($option);
        }

        this.$results.append($options);
      };

      Results.prototype.position = function ($results, $dropdown) {
        var $resultsContainer = $dropdown.find('.select2-results');
        $resultsContainer.append($results);
      };

      Results.prototype.sort = function (data) {
        var sorter = this.options.get('sorter');
        return sorter(data);
      };

      Results.prototype.highlightFirstItem = function () {
        var $options = this.$results.find('.select2-results__option--selectable');
        var $selected = $options.filter('.select2-results__option--selected'); // Check if there are any selected options

        if ($selected.length > 0) {
          // If there are selected options, highlight the first
          $selected.first().trigger('mouseenter');
        } else {
          // If there are no selected options, highlight the first option
          // in the dropdown
          $options.first().trigger('mouseenter');
        }

        this.ensureHighlightVisible();
      };

      Results.prototype.setClasses = function () {
        var self = this;
        this.data.current(function (selected) {
          var selectedIds = selected.map(function (s) {
            return s.id.toString();
          });
          var $options = self.$results.find('.select2-results__option--selectable');
          $options.each(function () {
            var $option = $(this);
            var item = Utils.GetData(this, 'data'); // id needs to be converted to a string when comparing

            var id = '' + item.id;

            if (item.element != null && item.element.selected || item.element == null && selectedIds.indexOf(id) > -1) {
              this.classList.add('select2-results__option--selected');
              $option.attr('aria-selected', 'true');
            } else {
              this.classList.remove('select2-results__option--selected');
              $option.attr('aria-selected', 'false');
            }
          });
        });
      };

      Results.prototype.showLoading = function (params) {
        this.hideLoading();
        var loadingMore = this.options.get('translations').get('searching');
        var loading = {
          disabled: true,
          loading: true,
          text: loadingMore(params)
        };
        var $loading = this.option(loading);
        $loading.className += ' loading-results';
        this.$results.prepend($loading);
      };

      Results.prototype.hideLoading = function () {
        this.$results.find('.loading-results').remove();
      };

      Results.prototype.option = function (data) {
        var option = document.createElement('li');
        option.classList.add('select2-results__option');
        option.classList.add('select2-results__option--selectable');
        var attrs = {
          'role': 'option'
        };
        var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;

        if (data.element != null && matches.call(data.element, ':disabled') || data.element == null && data.disabled) {
          attrs['aria-disabled'] = 'true';
          option.classList.remove('select2-results__option--selectable');
          option.classList.add('select2-results__option--disabled');
        }

        if (data.id == null) {
          option.classList.remove('select2-results__option--selectable');
        }

        if (data._resultId != null) {
          option.id = data._resultId;
        }

        if (data.title) {
          option.title = data.title;
        }

        if (data.children) {
          attrs.role = 'group';
          attrs['aria-label'] = data.text;
          option.classList.remove('select2-results__option--selectable');
          option.classList.add('select2-results__option--group');
        }

        for (var attr in attrs) {
          var val = attrs[attr];
          option.setAttribute(attr, val);
        }

        if (data.children) {
          var $option = $(option);
          var label = document.createElement('strong');
          label.className = 'select2-results__group';
          this.template(data, label);
          var $children = [];

          for (var c = 0; c < data.children.length; c++) {
            var child = data.children[c];
            var $child = this.option(child);
            $children.push($child);
          }

          var $childrenContainer = $('<ul></ul>', {
            'class': 'select2-results__options select2-results__options--nested',
            'role': 'none'
          });
          $childrenContainer.append($children);
          $option.append(label);
          $option.append($childrenContainer);
        } else {
          this.template(data, option);
        }

        Utils.StoreData(option, 'data', data);
        return option;
      };

      Results.prototype.bind = function (container, $container) {
        var self = this;
        var id = container.id + '-results';
        this.$results.attr('id', id);
        container.on('results:all', function (params) {
          self.clear();
          self.append(params.data);

          if (container.isOpen()) {
            self.setClasses();
            self.highlightFirstItem();
          }
        });
        container.on('results:append', function (params) {
          self.append(params.data);

          if (container.isOpen()) {
            self.setClasses();
          }
        });
        container.on('query', function (params) {
          self.hideMessages();
          self.showLoading(params);
        });
        container.on('select', function () {
          if (!container.isOpen()) {
            return;
          }

          self.setClasses();

          if (self.options.get('scrollAfterSelect')) {
            self.highlightFirstItem();
          }
        });
        container.on('unselect', function () {
          if (!container.isOpen()) {
            return;
          }

          self.setClasses();

          if (self.options.get('scrollAfterSelect')) {
            self.highlightFirstItem();
          }
        });
        container.on('open', function () {
          // When the dropdown is open, aria-expended="true"
          self.$results.attr('aria-expanded', 'true');
          self.$results.attr('aria-hidden', 'false');
          self.setClasses();
          self.ensureHighlightVisible();
        });
        container.on('close', function () {
          // When the dropdown is closed, aria-expended="false"
          self.$results.attr('aria-expanded', 'false');
          self.$results.attr('aria-hidden', 'true');
          self.$results.removeAttr('aria-activedescendant');
        });
        container.on('results:toggle', function () {
          var $highlighted = self.getHighlightedResults();

          if ($highlighted.length === 0) {
            return;
          }

          $highlighted.trigger('mouseup');
        });
        container.on('results:select', function () {
          var $highlighted = self.getHighlightedResults();

          if ($highlighted.length === 0) {
            return;
          }

          var data = Utils.GetData($highlighted[0], 'data');

          if ($highlighted.hasClass('select2-results__option--selected')) {
            self.trigger('close', {});
          } else {
            self.trigger('select', {
              data: data
            });
          }
        });
        container.on('results:previous', function () {
          var $highlighted = self.getHighlightedResults();
          var $options = self.$results.find('.select2-results__option--selectable');
          var currentIndex = $options.index($highlighted); // If we are already at the top, don't move further
          // If no options, currentIndex will be -1

          if (currentIndex <= 0) {
            return;
          }

          var nextIndex = currentIndex - 1; // If none are highlighted, highlight the first

          if ($highlighted.length === 0) {
            nextIndex = 0;
          }

          var $next = $options.eq(nextIndex);
          $next.trigger('mouseenter');
          var currentOffset = self.$results.offset().top;
          var nextTop = $next.offset().top;
          var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextTop - currentOffset < 0) {
            self.$results.scrollTop(nextOffset);
          }
        });
        container.on('results:next', function () {
          var $highlighted = self.getHighlightedResults();
          var $options = self.$results.find('.select2-results__option--selectable');
          var currentIndex = $options.index($highlighted);
          var nextIndex = currentIndex + 1; // If we are at the last option, stay there

          if (nextIndex >= $options.length) {
            return;
          }

          var $next = $options.eq(nextIndex);
          $next.trigger('mouseenter');
          var currentOffset = self.$results.offset().top + self.$results.outerHeight(false);
          var nextBottom = $next.offset().top + $next.outerHeight(false);
          var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextBottom > currentOffset) {
            self.$results.scrollTop(nextOffset);
          }
        });
        container.on('results:focus', function (params) {
          params.element[0].classList.add('select2-results__option--highlighted');
          params.element[0].setAttribute('aria-selected', 'true');
        });
        container.on('results:message', function (params) {
          self.displayMessage(params);
        });

        if ($.fn.mousewheel) {
          this.$results.on('mousewheel', function (e) {
            var top = self.$results.scrollTop();
            var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
            var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
            var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

            if (isAtTop) {
              self.$results.scrollTop(0);
              e.preventDefault();
              e.stopPropagation();
            } else if (isAtBottom) {
              self.$results.scrollTop(self.$results.get(0).scrollHeight - self.$results.height());
              e.preventDefault();
              e.stopPropagation();
            }
          });
        }

        this.$results.on('mouseup', '.select2-results__option--selectable', function (evt) {
          var $this = $(this);
          var data = Utils.GetData(this, 'data');

          if ($this.hasClass('select2-results__option--selected')) {
            if (self.options.get('multiple')) {
              self.trigger('unselect', {
                originalEvent: evt,
                data: data
              });
            } else {
              self.trigger('close', {});
            }

            return;
          }

          self.trigger('select', {
            originalEvent: evt,
            data: data
          });
        });
        this.$results.on('mouseenter', '.select2-results__option--selectable', function (evt) {
          var data = Utils.GetData(this, 'data');
          self.getHighlightedResults().removeClass('select2-results__option--highlighted').attr('aria-selected', 'false');
          self.trigger('results:focus', {
            data: data,
            element: $(this)
          });
        });
      };

      Results.prototype.getHighlightedResults = function () {
        var $highlighted = this.$results.find('.select2-results__option--highlighted');
        return $highlighted;
      };

      Results.prototype.destroy = function () {
        this.$results.remove();
      };

      Results.prototype.ensureHighlightVisible = function () {
        var $highlighted = this.getHighlightedResults();

        if ($highlighted.length === 0) {
          return;
        }

        var $options = this.$results.find('.select2-results__option--selectable');
        var currentIndex = $options.index($highlighted);
        var currentOffset = this.$results.offset().top;
        var nextTop = $highlighted.offset().top;
        var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
        var offsetDelta = nextTop - currentOffset;
        nextOffset -= $highlighted.outerHeight(false) * 2;

        if (currentIndex <= 2) {
          this.$results.scrollTop(0);
        } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
          this.$results.scrollTop(nextOffset);
        }
      };

      Results.prototype.template = function (result, container) {
        var template = this.options.get('templateResult');
        var escapeMarkup = this.options.get('escapeMarkup');
        var content = template(result, container);

        if (content == null) {
          container.style.display = 'none';
        } else if (typeof content === 'string') {
          container.innerHTML = escapeMarkup(content);
        } else {
          $(container).append(content);
        }
      };

      return Results;
    });
    S2.define('select2/keys', [], function () {
      var KEYS = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        ESC: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        DELETE: 46
      };
      return KEYS;
    });
    S2.define('select2/selection/base', ['jquery', '../utils', '../keys'], function ($, Utils, KEYS) {
      function BaseSelection($element, options) {
        this.$element = $element;
        this.options = options;

        BaseSelection.__super__.constructor.call(this);
      }

      Utils.Extend(BaseSelection, Utils.Observable);

      BaseSelection.prototype.render = function () {
        var $selection = $('<span class="select2-selection" role="combobox" ' + ' aria-haspopup="true" aria-expanded="false">' + '</span>');
        this._tabindex = 0;

        if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {
          this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');
        } else if (this.$element.attr('tabindex') != null) {
          this._tabindex = this.$element.attr('tabindex');
        }

        $selection.attr('title', this.$element.attr('title'));
        $selection.attr('tabindex', this._tabindex);
        $selection.attr('aria-disabled', 'false');
        this.$selection = $selection;
        return $selection;
      };

      BaseSelection.prototype.bind = function (container, $container) {
        var self = this;
        var resultsId = container.id + '-results';
        this.container = container;
        this.$selection.on('focus', function (evt) {
          self.trigger('focus', evt);
        });
        this.$selection.on('blur', function (evt) {
          self._handleBlur(evt);
        });
        this.$selection.on('keydown', function (evt) {
          self.trigger('keypress', evt);

          if (evt.which === KEYS.SPACE) {
            evt.preventDefault();
          }
        });
        container.on('results:focus', function (params) {
          self.$selection.attr('aria-activedescendant', params.data._resultId);
        });
        container.on('selection:update', function (params) {
          self.update(params.data);
        });
        container.on('open', function () {
          // When the dropdown is open, aria-expanded="true"
          self.$selection.attr('aria-expanded', 'true');
          self.$selection.attr('aria-owns', resultsId);

          self._attachCloseHandler(container);
        });
        container.on('close', function () {
          // When the dropdown is closed, aria-expanded="false"
          self.$selection.attr('aria-expanded', 'false');
          self.$selection.removeAttr('aria-activedescendant');
          self.$selection.removeAttr('aria-owns');
          self.$selection.trigger('focus');

          self._detachCloseHandler(container);
        });
        container.on('enable', function () {
          self.$selection.attr('tabindex', self._tabindex);
          self.$selection.attr('aria-disabled', 'false');
        });
        container.on('disable', function () {
          self.$selection.attr('tabindex', '-1');
          self.$selection.attr('aria-disabled', 'true');
        });
      };

      BaseSelection.prototype._handleBlur = function (evt) {
        var self = this; // This needs to be delayed as the active element is the body when the tab
        // key is pressed, possibly along with others.

        window.setTimeout(function () {
          // Don't trigger `blur` if the focus is still in the selection
          if (document.activeElement == self.$selection[0] || $.contains(self.$selection[0], document.activeElement)) {
            return;
          }

          self.trigger('blur', evt);
        }, 1);
      };

      BaseSelection.prototype._attachCloseHandler = function (container) {
        $(document.body).on('mousedown.select2.' + container.id, function (e) {
          var $target = $(e.target);
          var $select = $target.closest('.select2');
          var $all = $('.select2.select2-container--open');
          $all.each(function () {
            if (this == $select[0]) {
              return;
            }

            var $element = Utils.GetData(this, 'element');
            $element.select2('close');
          });
        });
      };

      BaseSelection.prototype._detachCloseHandler = function (container) {
        $(document.body).off('mousedown.select2.' + container.id);
      };

      BaseSelection.prototype.position = function ($selection, $container) {
        var $selectionContainer = $container.find('.selection');
        $selectionContainer.append($selection);
      };

      BaseSelection.prototype.destroy = function () {
        this._detachCloseHandler(this.container);
      };

      BaseSelection.prototype.update = function (data) {
        throw new Error('The `update` method must be defined in child classes.');
      };
      /**
       * Helper method to abstract the "enabled" (not "disabled") state of this
       * object.
       *
       * @return {true} if the instance is not disabled.
       * @return {false} if the instance is disabled.
       */


      BaseSelection.prototype.isEnabled = function () {
        return !this.isDisabled();
      };
      /**
       * Helper method to abstract the "disabled" state of this object.
       *
       * @return {true} if the disabled option is true.
       * @return {false} if the disabled option is false.
       */


      BaseSelection.prototype.isDisabled = function () {
        return this.options.get('disabled');
      };

      return BaseSelection;
    });
    S2.define('select2/selection/single', ['jquery', './base', '../utils', '../keys'], function ($, BaseSelection, Utils, KEYS) {
      function SingleSelection() {
        SingleSelection.__super__.constructor.apply(this, arguments);
      }

      Utils.Extend(SingleSelection, BaseSelection);

      SingleSelection.prototype.render = function () {
        var $selection = SingleSelection.__super__.render.call(this);

        $selection[0].classList.add('select2-selection--single');
        $selection.html('<span class="select2-selection__rendered"></span>' + '<span class="select2-selection__arrow" role="presentation">' + '<b role="presentation"></b>' + '</span>');
        return $selection;
      };

      SingleSelection.prototype.bind = function (container, $container) {
        var self = this;

        SingleSelection.__super__.bind.apply(this, arguments);

        var id = container.id + '-container';
        this.$selection.find('.select2-selection__rendered').attr('id', id).attr('role', 'textbox').attr('aria-readonly', 'true');
        this.$selection.attr('aria-labelledby', id);
        this.$selection.attr('aria-controls', id);
        this.$selection.on('mousedown', function (evt) {
          // Only respond to left clicks
          if (evt.which !== 1) {
            return;
          }

          self.trigger('toggle', {
            originalEvent: evt
          });
        });
        this.$selection.on('focus', function (evt) {// User focuses on the container
        });
        this.$selection.on('blur', function (evt) {// User exits the container
        });
        container.on('focus', function (evt) {
          if (!container.isOpen()) {
            self.$selection.trigger('focus');
          }
        });
      };

      SingleSelection.prototype.clear = function () {
        var $rendered = this.$selection.find('.select2-selection__rendered');
        $rendered.empty();
        $rendered.removeAttr('title'); // clear tooltip on empty
      };

      SingleSelection.prototype.display = function (data, container) {
        var template = this.options.get('templateSelection');
        var escapeMarkup = this.options.get('escapeMarkup');
        return escapeMarkup(template(data, container));
      };

      SingleSelection.prototype.selectionContainer = function () {
        return $('<span></span>');
      };

      SingleSelection.prototype.update = function (data) {
        if (data.length === 0) {
          this.clear();
          return;
        }

        var selection = data[0];
        var $rendered = this.$selection.find('.select2-selection__rendered');
        var formatted = this.display(selection, $rendered);
        $rendered.empty().append(formatted);
        var title = selection.title || selection.text;

        if (title) {
          $rendered.attr('title', title);
        } else {
          $rendered.removeAttr('title');
        }
      };

      return SingleSelection;
    });
    S2.define('select2/selection/multiple', ['jquery', './base', '../utils'], function ($, BaseSelection, Utils) {
      function MultipleSelection($element, options) {
        MultipleSelection.__super__.constructor.apply(this, arguments);
      }

      Utils.Extend(MultipleSelection, BaseSelection);

      MultipleSelection.prototype.render = function () {
        var $selection = MultipleSelection.__super__.render.call(this);

        $selection[0].classList.add('select2-selection--multiple');
        $selection.html('<ul class="select2-selection__rendered"></ul>');
        return $selection;
      };

      MultipleSelection.prototype.bind = function (container, $container) {
        var self = this;

        MultipleSelection.__super__.bind.apply(this, arguments);

        var id = container.id + '-container';
        this.$selection.find('.select2-selection__rendered').attr('id', id);
        this.$selection.on('click', function (evt) {
          self.trigger('toggle', {
            originalEvent: evt
          });
        });
        this.$selection.on('click', '.select2-selection__choice__remove', function (evt) {
          // Ignore the event if it is disabled
          if (self.isDisabled()) {
            return;
          }

          var $remove = $(this);
          var $selection = $remove.parent();
          var data = Utils.GetData($selection[0], 'data');
          self.trigger('unselect', {
            originalEvent: evt,
            data: data
          });
        });
        this.$selection.on('keydown', '.select2-selection__choice__remove', function (evt) {
          // Ignore the event if it is disabled
          if (self.isDisabled()) {
            return;
          }

          evt.stopPropagation();
        });
      };

      MultipleSelection.prototype.clear = function () {
        var $rendered = this.$selection.find('.select2-selection__rendered');
        $rendered.empty();
        $rendered.removeAttr('title');
      };

      MultipleSelection.prototype.display = function (data, container) {
        var template = this.options.get('templateSelection');
        var escapeMarkup = this.options.get('escapeMarkup');
        return escapeMarkup(template(data, container));
      };

      MultipleSelection.prototype.selectionContainer = function () {
        var $container = $('<li class="select2-selection__choice">' + '<button type="button" class="select2-selection__choice__remove" ' + 'tabindex="-1">' + '<span aria-hidden="true">&times;</span>' + '</button>' + '<span class="select2-selection__choice__display"></span>' + '</li>');
        return $container;
      };

      MultipleSelection.prototype.update = function (data) {
        this.clear();

        if (data.length === 0) {
          return;
        }

        var $selections = [];
        var selectionIdPrefix = this.$selection.find('.select2-selection__rendered').attr('id') + '-choice-';

        for (var d = 0; d < data.length; d++) {
          var selection = data[d];
          var $selection = this.selectionContainer();
          var formatted = this.display(selection, $selection);
          var selectionId = selectionIdPrefix + Utils.generateChars(4) + '-';

          if (selection.id) {
            selectionId += selection.id;
          } else {
            selectionId += Utils.generateChars(4);
          }

          $selection.find('.select2-selection__choice__display').append(formatted).attr('id', selectionId);
          var title = selection.title || selection.text;

          if (title) {
            $selection.attr('title', title);
          }

          var removeItem = this.options.get('translations').get('removeItem');
          var $remove = $selection.find('.select2-selection__choice__remove');
          $remove.attr('title', removeItem());
          $remove.attr('aria-label', removeItem());
          $remove.attr('aria-describedby', selectionId);
          Utils.StoreData($selection[0], 'data', selection);
          $selections.push($selection);
        }

        var $rendered = this.$selection.find('.select2-selection__rendered');
        $rendered.append($selections);
      };

      return MultipleSelection;
    });
    S2.define('select2/selection/placeholder', [], function () {
      function Placeholder(decorated, $element, options) {
        this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
        decorated.call(this, $element, options);
      }

      Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
        if (typeof placeholder === 'string') {
          placeholder = {
            id: '',
            text: placeholder
          };
        }

        return placeholder;
      };

      Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
        var $placeholder = this.selectionContainer();
        $placeholder.html(this.display(placeholder));
        $placeholder[0].classList.add('select2-selection__placeholder');
        $placeholder[0].classList.remove('select2-selection__choice');
        var placeholderTitle = placeholder.title || placeholder.text || $placeholder.text();
        this.$selection.find('.select2-selection__rendered').attr('title', placeholderTitle);
        return $placeholder;
      };

      Placeholder.prototype.update = function (decorated, data) {
        var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
        var multipleSelections = data.length > 1;

        if (multipleSelections || singlePlaceholder) {
          return decorated.call(this, data);
        }

        this.clear();
        var $placeholder = this.createPlaceholder(this.placeholder);
        this.$selection.find('.select2-selection__rendered').append($placeholder);
      };

      return Placeholder;
    });
    S2.define('select2/selection/allowClear', ['jquery', '../keys', '../utils'], function ($, KEYS, Utils) {
      function AllowClear() {}

      AllowClear.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);

        if (this.placeholder == null) {
          if (this.options.get('debug') && window.console && console.error) {
            console.error('Select2: The `allowClear` option should be used in combination ' + 'with the `placeholder` option.');
          }
        }

        this.$selection.on('mousedown', '.select2-selection__clear', function (evt) {
          self._handleClear(evt);
        });
        container.on('keypress', function (evt) {
          self._handleKeyboardClear(evt, container);
        });
      };

      AllowClear.prototype._handleClear = function (_, evt) {
        // Ignore the event if it is disabled
        if (this.isDisabled()) {
          return;
        }

        var $clear = this.$selection.find('.select2-selection__clear'); // Ignore the event if nothing has been selected

        if ($clear.length === 0) {
          return;
        }

        evt.stopPropagation();
        var data = Utils.GetData($clear[0], 'data');
        var previousVal = this.$element.val();
        this.$element.val(this.placeholder.id);
        var unselectData = {
          data: data
        };
        this.trigger('clear', unselectData);

        if (unselectData.prevented) {
          this.$element.val(previousVal);
          return;
        }

        for (var d = 0; d < data.length; d++) {
          unselectData = {
            data: data[d]
          }; // Trigger the `unselect` event, so people can prevent it from being
          // cleared.

          this.trigger('unselect', unselectData); // If the event was prevented, don't clear it out.

          if (unselectData.prevented) {
            this.$element.val(previousVal);
            return;
          }
        }

        this.$element.trigger('input').trigger('change');
        this.trigger('toggle', {});
      };

      AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
        if (container.isOpen()) {
          return;
        }

        if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
          this._handleClear(evt);
        }
      };

      AllowClear.prototype.update = function (decorated, data) {
        decorated.call(this, data);
        this.$selection.find('.select2-selection__clear').remove();
        this.$selection[0].classList.remove('select2-selection--clearable');

        if (this.$selection.find('.select2-selection__placeholder').length > 0 || data.length === 0) {
          return;
        }

        var selectionId = this.$selection.find('.select2-selection__rendered').attr('id');
        var removeAll = this.options.get('translations').get('removeAllItems');
        var $remove = $('<button type="button" class="select2-selection__clear" tabindex="-1">' + '<span aria-hidden="true">&times;</span>' + '</button>');
        $remove.attr('title', removeAll());
        $remove.attr('aria-label', removeAll());
        $remove.attr('aria-describedby', selectionId);
        Utils.StoreData($remove[0], 'data', data);
        this.$selection.prepend($remove);
        this.$selection[0].classList.add('select2-selection--clearable');
      };

      return AllowClear;
    });
    S2.define('select2/selection/search', ['jquery', '../utils', '../keys'], function ($, Utils, KEYS) {
      function Search(decorated, $element, options) {
        decorated.call(this, $element, options);
      }

      Search.prototype.render = function (decorated) {
        var searchLabel = this.options.get('translations').get('search');
        var $search = $('<span class="select2-search select2-search--inline">' + '<textarea class="select2-search__field"' + ' type="search" tabindex="-1"' + ' autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" >' + '</textarea>' + '</span>');
        this.$searchContainer = $search;
        this.$search = $search.find('textarea');
        this.$search.prop('autocomplete', this.options.get('autocomplete'));
        this.$search.attr('aria-label', searchLabel());
        var $rendered = decorated.call(this);

        this._transferTabIndex();

        $rendered.append(this.$searchContainer);
        return $rendered;
      };

      Search.prototype.bind = function (decorated, container, $container) {
        var self = this;
        var resultsId = container.id + '-results';
        var selectionId = container.id + '-container';
        decorated.call(this, container, $container);
        self.$search.attr('aria-describedby', selectionId);
        container.on('open', function () {
          self.$search.attr('aria-controls', resultsId);
          self.$search.trigger('focus');
        });
        container.on('close', function () {
          self.$search.val('');
          self.resizeSearch();
          self.$search.removeAttr('aria-controls');
          self.$search.removeAttr('aria-activedescendant');
          self.$search.trigger('focus');
        });
        container.on('enable', function () {
          self.$search.prop('disabled', false);

          self._transferTabIndex();
        });
        container.on('disable', function () {
          self.$search.prop('disabled', true);
        });
        container.on('focus', function (evt) {
          self.$search.trigger('focus');
        });
        container.on('results:focus', function (params) {
          if (params.data._resultId) {
            self.$search.attr('aria-activedescendant', params.data._resultId);
          } else {
            self.$search.removeAttr('aria-activedescendant');
          }
        });
        this.$selection.on('focusin', '.select2-search--inline', function (evt) {
          self.trigger('focus', evt);
        });
        this.$selection.on('focusout', '.select2-search--inline', function (evt) {
          self._handleBlur(evt);
        });
        this.$selection.on('keydown', '.select2-search--inline', function (evt) {
          evt.stopPropagation();
          self.trigger('keypress', evt);
          self._keyUpPrevented = evt.isDefaultPrevented();
          var key = evt.which;

          if (key === KEYS.BACKSPACE && self.$search.val() === '') {
            var $previousChoice = self.$selection.find('.select2-selection__choice').last();

            if ($previousChoice.length > 0) {
              var item = Utils.GetData($previousChoice[0], 'data');
              self.searchRemoveChoice(item);
              evt.preventDefault();
            }
          }
        });
        this.$selection.on('click', '.select2-search--inline', function (evt) {
          if (self.$search.val()) {
            evt.stopPropagation();
          }
        }); // Try to detect the IE version should the `documentMode` property that
        // is stored on the document. This is only implemented in IE and is
        // slightly cleaner than doing a user agent check.
        // This property is not available in Edge, but Edge also doesn't have
        // this bug.

        var msie = document.documentMode;
        var disableInputEvents = msie && msie <= 11; // Workaround for browsers which do not support the `input` event
        // This will prevent double-triggering of events for browsers which support
        // both the `keyup` and `input` events.

        this.$selection.on('input.searchcheck', '.select2-search--inline', function (evt) {
          // IE will trigger the `input` event when a placeholder is used on a
          // search box. To get around this issue, we are forced to ignore all
          // `input` events in IE and keep using `keyup`.
          if (disableInputEvents) {
            self.$selection.off('input.search input.searchcheck');
            return;
          } // Unbind the duplicated `keyup` event


          self.$selection.off('keyup.search');
        });
        this.$selection.on('keyup.search input.search', '.select2-search--inline', function (evt) {
          // IE will trigger the `input` event when a placeholder is used on a
          // search box. To get around this issue, we are forced to ignore all
          // `input` events in IE and keep using `keyup`.
          if (disableInputEvents && evt.type === 'input') {
            self.$selection.off('input.search input.searchcheck');
            return;
          }

          var key = evt.which; // We can freely ignore events from modifier keys

          if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
            return;
          } // Tabbing will be handled during the `keydown` phase


          if (key == KEYS.TAB) {
            return;
          }

          self.handleSearch(evt);
        });
      };
      /**
       * This method will transfer the tabindex attribute from the rendered
       * selection to the search box. This allows for the search box to be used as
       * the primary focus instead of the selection container.
       *
       * @private
       */


      Search.prototype._transferTabIndex = function (decorated) {
        this.$search.attr('tabindex', this.$selection.attr('tabindex'));
        this.$selection.attr('tabindex', '-1');
      };

      Search.prototype.createPlaceholder = function (decorated, placeholder) {
        this.$search.attr('placeholder', placeholder.text);
      };

      Search.prototype.update = function (decorated, data) {
        var searchHadFocus = this.$search[0] == document.activeElement;
        this.$search.attr('placeholder', '');
        decorated.call(this, data);
        this.resizeSearch();

        if (searchHadFocus) {
          this.$search.trigger('focus');
        }
      };

      Search.prototype.handleSearch = function () {
        this.resizeSearch();

        if (!this._keyUpPrevented) {
          var input = this.$search.val();
          this.trigger('query', {
            term: input
          });
        }

        this._keyUpPrevented = false;
      };

      Search.prototype.searchRemoveChoice = function (decorated, item) {
        this.trigger('unselect', {
          data: item
        });
        this.$search.val(item.text);
        this.handleSearch();
      };

      Search.prototype.resizeSearch = function () {
        this.$search.css('width', '25px');
        var width = '100%';

        if (this.$search.attr('placeholder') === '') {
          var minimumWidth = this.$search.val().length + 1;
          width = minimumWidth * 0.75 + 'em';
        }

        this.$search.css('width', width);
      };

      return Search;
    });
    S2.define('select2/selection/selectionCss', ['../utils'], function (Utils) {
      function SelectionCSS() {}

      SelectionCSS.prototype.render = function (decorated) {
        var $selection = decorated.call(this);
        var selectionCssClass = this.options.get('selectionCssClass') || '';

        if (selectionCssClass.indexOf(':all:') !== -1) {
          selectionCssClass = selectionCssClass.replace(':all:', '');
          Utils.copyNonInternalCssClasses($selection[0], this.$element[0]);
        }

        $selection.addClass(selectionCssClass);
        return $selection;
      };

      return SelectionCSS;
    });
    S2.define('select2/selection/eventRelay', ['jquery'], function ($) {
      function EventRelay() {}

      EventRelay.prototype.bind = function (decorated, container, $container) {
        var self = this;
        var relayEvents = ['open', 'opening', 'close', 'closing', 'select', 'selecting', 'unselect', 'unselecting', 'clear', 'clearing'];
        var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting', 'clearing'];
        decorated.call(this, container, $container);
        container.on('*', function (name, params) {
          // Ignore events that should not be relayed
          if (relayEvents.indexOf(name) === -1) {
            return;
          } // The parameters should always be an object


          params = params || {}; // Generate the jQuery event for the Select2 event

          var evt = $.Event('select2:' + name, {
            params: params
          });
          self.$element.trigger(evt); // Only handle preventable events if it was one

          if (preventableEvents.indexOf(name) === -1) {
            return;
          }

          params.prevented = evt.isDefaultPrevented();
        });
      };

      return EventRelay;
    });
    S2.define('select2/translation', ['jquery', 'require'], function ($, require) {
      function Translation(dict) {
        this.dict = dict || {};
      }

      Translation.prototype.all = function () {
        return this.dict;
      };

      Translation.prototype.get = function (key) {
        return this.dict[key];
      };

      Translation.prototype.extend = function (translation) {
        this.dict = $.extend({}, translation.all(), this.dict);
      }; // Static functions


      Translation._cache = {};

      Translation.loadPath = function (path) {
        if (!(path in Translation._cache)) {
          var translations = require(path);

          Translation._cache[path] = translations;
        }

        return new Translation(Translation._cache[path]);
      };

      return Translation;
    });
    S2.define('select2/diacritics', [], function () {
      var diacritics = {
        '\u24B6': 'A',
        '\uFF21': 'A',
        '\u00C0': 'A',
        '\u00C1': 'A',
        '\u00C2': 'A',
        '\u1EA6': 'A',
        '\u1EA4': 'A',
        '\u1EAA': 'A',
        '\u1EA8': 'A',
        '\u00C3': 'A',
        '\u0100': 'A',
        '\u0102': 'A',
        '\u1EB0': 'A',
        '\u1EAE': 'A',
        '\u1EB4': 'A',
        '\u1EB2': 'A',
        '\u0226': 'A',
        '\u01E0': 'A',
        '\u00C4': 'A',
        '\u01DE': 'A',
        '\u1EA2': 'A',
        '\u00C5': 'A',
        '\u01FA': 'A',
        '\u01CD': 'A',
        '\u0200': 'A',
        '\u0202': 'A',
        '\u1EA0': 'A',
        '\u1EAC': 'A',
        '\u1EB6': 'A',
        '\u1E00': 'A',
        '\u0104': 'A',
        '\u023A': 'A',
        '\u2C6F': 'A',
        '\uA732': 'AA',
        '\u00C6': 'AE',
        '\u01FC': 'AE',
        '\u01E2': 'AE',
        '\uA734': 'AO',
        '\uA736': 'AU',
        '\uA738': 'AV',
        '\uA73A': 'AV',
        '\uA73C': 'AY',
        '\u24B7': 'B',
        '\uFF22': 'B',
        '\u1E02': 'B',
        '\u1E04': 'B',
        '\u1E06': 'B',
        '\u0243': 'B',
        '\u0182': 'B',
        '\u0181': 'B',
        '\u24B8': 'C',
        '\uFF23': 'C',
        '\u0106': 'C',
        '\u0108': 'C',
        '\u010A': 'C',
        '\u010C': 'C',
        '\u00C7': 'C',
        '\u1E08': 'C',
        '\u0187': 'C',
        '\u023B': 'C',
        '\uA73E': 'C',
        '\u24B9': 'D',
        '\uFF24': 'D',
        '\u1E0A': 'D',
        '\u010E': 'D',
        '\u1E0C': 'D',
        '\u1E10': 'D',
        '\u1E12': 'D',
        '\u1E0E': 'D',
        '\u0110': 'D',
        '\u018B': 'D',
        '\u018A': 'D',
        '\u0189': 'D',
        '\uA779': 'D',
        '\u01F1': 'DZ',
        '\u01C4': 'DZ',
        '\u01F2': 'Dz',
        '\u01C5': 'Dz',
        '\u24BA': 'E',
        '\uFF25': 'E',
        '\u00C8': 'E',
        '\u00C9': 'E',
        '\u00CA': 'E',
        '\u1EC0': 'E',
        '\u1EBE': 'E',
        '\u1EC4': 'E',
        '\u1EC2': 'E',
        '\u1EBC': 'E',
        '\u0112': 'E',
        '\u1E14': 'E',
        '\u1E16': 'E',
        '\u0114': 'E',
        '\u0116': 'E',
        '\u00CB': 'E',
        '\u1EBA': 'E',
        '\u011A': 'E',
        '\u0204': 'E',
        '\u0206': 'E',
        '\u1EB8': 'E',
        '\u1EC6': 'E',
        '\u0228': 'E',
        '\u1E1C': 'E',
        '\u0118': 'E',
        '\u1E18': 'E',
        '\u1E1A': 'E',
        '\u0190': 'E',
        '\u018E': 'E',
        '\u24BB': 'F',
        '\uFF26': 'F',
        '\u1E1E': 'F',
        '\u0191': 'F',
        '\uA77B': 'F',
        '\u24BC': 'G',
        '\uFF27': 'G',
        '\u01F4': 'G',
        '\u011C': 'G',
        '\u1E20': 'G',
        '\u011E': 'G',
        '\u0120': 'G',
        '\u01E6': 'G',
        '\u0122': 'G',
        '\u01E4': 'G',
        '\u0193': 'G',
        '\uA7A0': 'G',
        '\uA77D': 'G',
        '\uA77E': 'G',
        '\u24BD': 'H',
        '\uFF28': 'H',
        '\u0124': 'H',
        '\u1E22': 'H',
        '\u1E26': 'H',
        '\u021E': 'H',
        '\u1E24': 'H',
        '\u1E28': 'H',
        '\u1E2A': 'H',
        '\u0126': 'H',
        '\u2C67': 'H',
        '\u2C75': 'H',
        '\uA78D': 'H',
        '\u24BE': 'I',
        '\uFF29': 'I',
        '\u00CC': 'I',
        '\u00CD': 'I',
        '\u00CE': 'I',
        '\u0128': 'I',
        '\u012A': 'I',
        '\u012C': 'I',
        '\u0130': 'I',
        '\u00CF': 'I',
        '\u1E2E': 'I',
        '\u1EC8': 'I',
        '\u01CF': 'I',
        '\u0208': 'I',
        '\u020A': 'I',
        '\u1ECA': 'I',
        '\u012E': 'I',
        '\u1E2C': 'I',
        '\u0197': 'I',
        '\u24BF': 'J',
        '\uFF2A': 'J',
        '\u0134': 'J',
        '\u0248': 'J',
        '\u24C0': 'K',
        '\uFF2B': 'K',
        '\u1E30': 'K',
        '\u01E8': 'K',
        '\u1E32': 'K',
        '\u0136': 'K',
        '\u1E34': 'K',
        '\u0198': 'K',
        '\u2C69': 'K',
        '\uA740': 'K',
        '\uA742': 'K',
        '\uA744': 'K',
        '\uA7A2': 'K',
        '\u24C1': 'L',
        '\uFF2C': 'L',
        '\u013F': 'L',
        '\u0139': 'L',
        '\u013D': 'L',
        '\u1E36': 'L',
        '\u1E38': 'L',
        '\u013B': 'L',
        '\u1E3C': 'L',
        '\u1E3A': 'L',
        '\u0141': 'L',
        '\u023D': 'L',
        '\u2C62': 'L',
        '\u2C60': 'L',
        '\uA748': 'L',
        '\uA746': 'L',
        '\uA780': 'L',
        '\u01C7': 'LJ',
        '\u01C8': 'Lj',
        '\u24C2': 'M',
        '\uFF2D': 'M',
        '\u1E3E': 'M',
        '\u1E40': 'M',
        '\u1E42': 'M',
        '\u2C6E': 'M',
        '\u019C': 'M',
        '\u24C3': 'N',
        '\uFF2E': 'N',
        '\u01F8': 'N',
        '\u0143': 'N',
        '\u00D1': 'N',
        '\u1E44': 'N',
        '\u0147': 'N',
        '\u1E46': 'N',
        '\u0145': 'N',
        '\u1E4A': 'N',
        '\u1E48': 'N',
        '\u0220': 'N',
        '\u019D': 'N',
        '\uA790': 'N',
        '\uA7A4': 'N',
        '\u01CA': 'NJ',
        '\u01CB': 'Nj',
        '\u24C4': 'O',
        '\uFF2F': 'O',
        '\u00D2': 'O',
        '\u00D3': 'O',
        '\u00D4': 'O',
        '\u1ED2': 'O',
        '\u1ED0': 'O',
        '\u1ED6': 'O',
        '\u1ED4': 'O',
        '\u00D5': 'O',
        '\u1E4C': 'O',
        '\u022C': 'O',
        '\u1E4E': 'O',
        '\u014C': 'O',
        '\u1E50': 'O',
        '\u1E52': 'O',
        '\u014E': 'O',
        '\u022E': 'O',
        '\u0230': 'O',
        '\u00D6': 'O',
        '\u022A': 'O',
        '\u1ECE': 'O',
        '\u0150': 'O',
        '\u01D1': 'O',
        '\u020C': 'O',
        '\u020E': 'O',
        '\u01A0': 'O',
        '\u1EDC': 'O',
        '\u1EDA': 'O',
        '\u1EE0': 'O',
        '\u1EDE': 'O',
        '\u1EE2': 'O',
        '\u1ECC': 'O',
        '\u1ED8': 'O',
        '\u01EA': 'O',
        '\u01EC': 'O',
        '\u00D8': 'O',
        '\u01FE': 'O',
        '\u0186': 'O',
        '\u019F': 'O',
        '\uA74A': 'O',
        '\uA74C': 'O',
        '\u0152': 'OE',
        '\u01A2': 'OI',
        '\uA74E': 'OO',
        '\u0222': 'OU',
        '\u24C5': 'P',
        '\uFF30': 'P',
        '\u1E54': 'P',
        '\u1E56': 'P',
        '\u01A4': 'P',
        '\u2C63': 'P',
        '\uA750': 'P',
        '\uA752': 'P',
        '\uA754': 'P',
        '\u24C6': 'Q',
        '\uFF31': 'Q',
        '\uA756': 'Q',
        '\uA758': 'Q',
        '\u024A': 'Q',
        '\u24C7': 'R',
        '\uFF32': 'R',
        '\u0154': 'R',
        '\u1E58': 'R',
        '\u0158': 'R',
        '\u0210': 'R',
        '\u0212': 'R',
        '\u1E5A': 'R',
        '\u1E5C': 'R',
        '\u0156': 'R',
        '\u1E5E': 'R',
        '\u024C': 'R',
        '\u2C64': 'R',
        '\uA75A': 'R',
        '\uA7A6': 'R',
        '\uA782': 'R',
        '\u24C8': 'S',
        '\uFF33': 'S',
        '\u1E9E': 'S',
        '\u015A': 'S',
        '\u1E64': 'S',
        '\u015C': 'S',
        '\u1E60': 'S',
        '\u0160': 'S',
        '\u1E66': 'S',
        '\u1E62': 'S',
        '\u1E68': 'S',
        '\u0218': 'S',
        '\u015E': 'S',
        '\u2C7E': 'S',
        '\uA7A8': 'S',
        '\uA784': 'S',
        '\u24C9': 'T',
        '\uFF34': 'T',
        '\u1E6A': 'T',
        '\u0164': 'T',
        '\u1E6C': 'T',
        '\u021A': 'T',
        '\u0162': 'T',
        '\u1E70': 'T',
        '\u1E6E': 'T',
        '\u0166': 'T',
        '\u01AC': 'T',
        '\u01AE': 'T',
        '\u023E': 'T',
        '\uA786': 'T',
        '\uA728': 'TZ',
        '\u24CA': 'U',
        '\uFF35': 'U',
        '\u00D9': 'U',
        '\u00DA': 'U',
        '\u00DB': 'U',
        '\u0168': 'U',
        '\u1E78': 'U',
        '\u016A': 'U',
        '\u1E7A': 'U',
        '\u016C': 'U',
        '\u00DC': 'U',
        '\u01DB': 'U',
        '\u01D7': 'U',
        '\u01D5': 'U',
        '\u01D9': 'U',
        '\u1EE6': 'U',
        '\u016E': 'U',
        '\u0170': 'U',
        '\u01D3': 'U',
        '\u0214': 'U',
        '\u0216': 'U',
        '\u01AF': 'U',
        '\u1EEA': 'U',
        '\u1EE8': 'U',
        '\u1EEE': 'U',
        '\u1EEC': 'U',
        '\u1EF0': 'U',
        '\u1EE4': 'U',
        '\u1E72': 'U',
        '\u0172': 'U',
        '\u1E76': 'U',
        '\u1E74': 'U',
        '\u0244': 'U',
        '\u24CB': 'V',
        '\uFF36': 'V',
        '\u1E7C': 'V',
        '\u1E7E': 'V',
        '\u01B2': 'V',
        '\uA75E': 'V',
        '\u0245': 'V',
        '\uA760': 'VY',
        '\u24CC': 'W',
        '\uFF37': 'W',
        '\u1E80': 'W',
        '\u1E82': 'W',
        '\u0174': 'W',
        '\u1E86': 'W',
        '\u1E84': 'W',
        '\u1E88': 'W',
        '\u2C72': 'W',
        '\u24CD': 'X',
        '\uFF38': 'X',
        '\u1E8A': 'X',
        '\u1E8C': 'X',
        '\u24CE': 'Y',
        '\uFF39': 'Y',
        '\u1EF2': 'Y',
        '\u00DD': 'Y',
        '\u0176': 'Y',
        '\u1EF8': 'Y',
        '\u0232': 'Y',
        '\u1E8E': 'Y',
        '\u0178': 'Y',
        '\u1EF6': 'Y',
        '\u1EF4': 'Y',
        '\u01B3': 'Y',
        '\u024E': 'Y',
        '\u1EFE': 'Y',
        '\u24CF': 'Z',
        '\uFF3A': 'Z',
        '\u0179': 'Z',
        '\u1E90': 'Z',
        '\u017B': 'Z',
        '\u017D': 'Z',
        '\u1E92': 'Z',
        '\u1E94': 'Z',
        '\u01B5': 'Z',
        '\u0224': 'Z',
        '\u2C7F': 'Z',
        '\u2C6B': 'Z',
        '\uA762': 'Z',
        '\u24D0': 'a',
        '\uFF41': 'a',
        '\u1E9A': 'a',
        '\u00E0': 'a',
        '\u00E1': 'a',
        '\u00E2': 'a',
        '\u1EA7': 'a',
        '\u1EA5': 'a',
        '\u1EAB': 'a',
        '\u1EA9': 'a',
        '\u00E3': 'a',
        '\u0101': 'a',
        '\u0103': 'a',
        '\u1EB1': 'a',
        '\u1EAF': 'a',
        '\u1EB5': 'a',
        '\u1EB3': 'a',
        '\u0227': 'a',
        '\u01E1': 'a',
        '\u00E4': 'a',
        '\u01DF': 'a',
        '\u1EA3': 'a',
        '\u00E5': 'a',
        '\u01FB': 'a',
        '\u01CE': 'a',
        '\u0201': 'a',
        '\u0203': 'a',
        '\u1EA1': 'a',
        '\u1EAD': 'a',
        '\u1EB7': 'a',
        '\u1E01': 'a',
        '\u0105': 'a',
        '\u2C65': 'a',
        '\u0250': 'a',
        '\uA733': 'aa',
        '\u00E6': 'ae',
        '\u01FD': 'ae',
        '\u01E3': 'ae',
        '\uA735': 'ao',
        '\uA737': 'au',
        '\uA739': 'av',
        '\uA73B': 'av',
        '\uA73D': 'ay',
        '\u24D1': 'b',
        '\uFF42': 'b',
        '\u1E03': 'b',
        '\u1E05': 'b',
        '\u1E07': 'b',
        '\u0180': 'b',
        '\u0183': 'b',
        '\u0253': 'b',
        '\u24D2': 'c',
        '\uFF43': 'c',
        '\u0107': 'c',
        '\u0109': 'c',
        '\u010B': 'c',
        '\u010D': 'c',
        '\u00E7': 'c',
        '\u1E09': 'c',
        '\u0188': 'c',
        '\u023C': 'c',
        '\uA73F': 'c',
        '\u2184': 'c',
        '\u24D3': 'd',
        '\uFF44': 'd',
        '\u1E0B': 'd',
        '\u010F': 'd',
        '\u1E0D': 'd',
        '\u1E11': 'd',
        '\u1E13': 'd',
        '\u1E0F': 'd',
        '\u0111': 'd',
        '\u018C': 'd',
        '\u0256': 'd',
        '\u0257': 'd',
        '\uA77A': 'd',
        '\u01F3': 'dz',
        '\u01C6': 'dz',
        '\u24D4': 'e',
        '\uFF45': 'e',
        '\u00E8': 'e',
        '\u00E9': 'e',
        '\u00EA': 'e',
        '\u1EC1': 'e',
        '\u1EBF': 'e',
        '\u1EC5': 'e',
        '\u1EC3': 'e',
        '\u1EBD': 'e',
        '\u0113': 'e',
        '\u1E15': 'e',
        '\u1E17': 'e',
        '\u0115': 'e',
        '\u0117': 'e',
        '\u00EB': 'e',
        '\u1EBB': 'e',
        '\u011B': 'e',
        '\u0205': 'e',
        '\u0207': 'e',
        '\u1EB9': 'e',
        '\u1EC7': 'e',
        '\u0229': 'e',
        '\u1E1D': 'e',
        '\u0119': 'e',
        '\u1E19': 'e',
        '\u1E1B': 'e',
        '\u0247': 'e',
        '\u025B': 'e',
        '\u01DD': 'e',
        '\u24D5': 'f',
        '\uFF46': 'f',
        '\u1E1F': 'f',
        '\u0192': 'f',
        '\uA77C': 'f',
        '\u24D6': 'g',
        '\uFF47': 'g',
        '\u01F5': 'g',
        '\u011D': 'g',
        '\u1E21': 'g',
        '\u011F': 'g',
        '\u0121': 'g',
        '\u01E7': 'g',
        '\u0123': 'g',
        '\u01E5': 'g',
        '\u0260': 'g',
        '\uA7A1': 'g',
        '\u1D79': 'g',
        '\uA77F': 'g',
        '\u24D7': 'h',
        '\uFF48': 'h',
        '\u0125': 'h',
        '\u1E23': 'h',
        '\u1E27': 'h',
        '\u021F': 'h',
        '\u1E25': 'h',
        '\u1E29': 'h',
        '\u1E2B': 'h',
        '\u1E96': 'h',
        '\u0127': 'h',
        '\u2C68': 'h',
        '\u2C76': 'h',
        '\u0265': 'h',
        '\u0195': 'hv',
        '\u24D8': 'i',
        '\uFF49': 'i',
        '\u00EC': 'i',
        '\u00ED': 'i',
        '\u00EE': 'i',
        '\u0129': 'i',
        '\u012B': 'i',
        '\u012D': 'i',
        '\u00EF': 'i',
        '\u1E2F': 'i',
        '\u1EC9': 'i',
        '\u01D0': 'i',
        '\u0209': 'i',
        '\u020B': 'i',
        '\u1ECB': 'i',
        '\u012F': 'i',
        '\u1E2D': 'i',
        '\u0268': 'i',
        '\u0131': 'i',
        '\u24D9': 'j',
        '\uFF4A': 'j',
        '\u0135': 'j',
        '\u01F0': 'j',
        '\u0249': 'j',
        '\u24DA': 'k',
        '\uFF4B': 'k',
        '\u1E31': 'k',
        '\u01E9': 'k',
        '\u1E33': 'k',
        '\u0137': 'k',
        '\u1E35': 'k',
        '\u0199': 'k',
        '\u2C6A': 'k',
        '\uA741': 'k',
        '\uA743': 'k',
        '\uA745': 'k',
        '\uA7A3': 'k',
        '\u24DB': 'l',
        '\uFF4C': 'l',
        '\u0140': 'l',
        '\u013A': 'l',
        '\u013E': 'l',
        '\u1E37': 'l',
        '\u1E39': 'l',
        '\u013C': 'l',
        '\u1E3D': 'l',
        '\u1E3B': 'l',
        '\u017F': 'l',
        '\u0142': 'l',
        '\u019A': 'l',
        '\u026B': 'l',
        '\u2C61': 'l',
        '\uA749': 'l',
        '\uA781': 'l',
        '\uA747': 'l',
        '\u01C9': 'lj',
        '\u24DC': 'm',
        '\uFF4D': 'm',
        '\u1E3F': 'm',
        '\u1E41': 'm',
        '\u1E43': 'm',
        '\u0271': 'm',
        '\u026F': 'm',
        '\u24DD': 'n',
        '\uFF4E': 'n',
        '\u01F9': 'n',
        '\u0144': 'n',
        '\u00F1': 'n',
        '\u1E45': 'n',
        '\u0148': 'n',
        '\u1E47': 'n',
        '\u0146': 'n',
        '\u1E4B': 'n',
        '\u1E49': 'n',
        '\u019E': 'n',
        '\u0272': 'n',
        '\u0149': 'n',
        '\uA791': 'n',
        '\uA7A5': 'n',
        '\u01CC': 'nj',
        '\u24DE': 'o',
        '\uFF4F': 'o',
        '\u00F2': 'o',
        '\u00F3': 'o',
        '\u00F4': 'o',
        '\u1ED3': 'o',
        '\u1ED1': 'o',
        '\u1ED7': 'o',
        '\u1ED5': 'o',
        '\u00F5': 'o',
        '\u1E4D': 'o',
        '\u022D': 'o',
        '\u1E4F': 'o',
        '\u014D': 'o',
        '\u1E51': 'o',
        '\u1E53': 'o',
        '\u014F': 'o',
        '\u022F': 'o',
        '\u0231': 'o',
        '\u00F6': 'o',
        '\u022B': 'o',
        '\u1ECF': 'o',
        '\u0151': 'o',
        '\u01D2': 'o',
        '\u020D': 'o',
        '\u020F': 'o',
        '\u01A1': 'o',
        '\u1EDD': 'o',
        '\u1EDB': 'o',
        '\u1EE1': 'o',
        '\u1EDF': 'o',
        '\u1EE3': 'o',
        '\u1ECD': 'o',
        '\u1ED9': 'o',
        '\u01EB': 'o',
        '\u01ED': 'o',
        '\u00F8': 'o',
        '\u01FF': 'o',
        '\u0254': 'o',
        '\uA74B': 'o',
        '\uA74D': 'o',
        '\u0275': 'o',
        '\u0153': 'oe',
        '\u01A3': 'oi',
        '\u0223': 'ou',
        '\uA74F': 'oo',
        '\u24DF': 'p',
        '\uFF50': 'p',
        '\u1E55': 'p',
        '\u1E57': 'p',
        '\u01A5': 'p',
        '\u1D7D': 'p',
        '\uA751': 'p',
        '\uA753': 'p',
        '\uA755': 'p',
        '\u24E0': 'q',
        '\uFF51': 'q',
        '\u024B': 'q',
        '\uA757': 'q',
        '\uA759': 'q',
        '\u24E1': 'r',
        '\uFF52': 'r',
        '\u0155': 'r',
        '\u1E59': 'r',
        '\u0159': 'r',
        '\u0211': 'r',
        '\u0213': 'r',
        '\u1E5B': 'r',
        '\u1E5D': 'r',
        '\u0157': 'r',
        '\u1E5F': 'r',
        '\u024D': 'r',
        '\u027D': 'r',
        '\uA75B': 'r',
        '\uA7A7': 'r',
        '\uA783': 'r',
        '\u24E2': 's',
        '\uFF53': 's',
        '\u00DF': 's',
        '\u015B': 's',
        '\u1E65': 's',
        '\u015D': 's',
        '\u1E61': 's',
        '\u0161': 's',
        '\u1E67': 's',
        '\u1E63': 's',
        '\u1E69': 's',
        '\u0219': 's',
        '\u015F': 's',
        '\u023F': 's',
        '\uA7A9': 's',
        '\uA785': 's',
        '\u1E9B': 's',
        '\u24E3': 't',
        '\uFF54': 't',
        '\u1E6B': 't',
        '\u1E97': 't',
        '\u0165': 't',
        '\u1E6D': 't',
        '\u021B': 't',
        '\u0163': 't',
        '\u1E71': 't',
        '\u1E6F': 't',
        '\u0167': 't',
        '\u01AD': 't',
        '\u0288': 't',
        '\u2C66': 't',
        '\uA787': 't',
        '\uA729': 'tz',
        '\u24E4': 'u',
        '\uFF55': 'u',
        '\u00F9': 'u',
        '\u00FA': 'u',
        '\u00FB': 'u',
        '\u0169': 'u',
        '\u1E79': 'u',
        '\u016B': 'u',
        '\u1E7B': 'u',
        '\u016D': 'u',
        '\u00FC': 'u',
        '\u01DC': 'u',
        '\u01D8': 'u',
        '\u01D6': 'u',
        '\u01DA': 'u',
        '\u1EE7': 'u',
        '\u016F': 'u',
        '\u0171': 'u',
        '\u01D4': 'u',
        '\u0215': 'u',
        '\u0217': 'u',
        '\u01B0': 'u',
        '\u1EEB': 'u',
        '\u1EE9': 'u',
        '\u1EEF': 'u',
        '\u1EED': 'u',
        '\u1EF1': 'u',
        '\u1EE5': 'u',
        '\u1E73': 'u',
        '\u0173': 'u',
        '\u1E77': 'u',
        '\u1E75': 'u',
        '\u0289': 'u',
        '\u24E5': 'v',
        '\uFF56': 'v',
        '\u1E7D': 'v',
        '\u1E7F': 'v',
        '\u028B': 'v',
        '\uA75F': 'v',
        '\u028C': 'v',
        '\uA761': 'vy',
        '\u24E6': 'w',
        '\uFF57': 'w',
        '\u1E81': 'w',
        '\u1E83': 'w',
        '\u0175': 'w',
        '\u1E87': 'w',
        '\u1E85': 'w',
        '\u1E98': 'w',
        '\u1E89': 'w',
        '\u2C73': 'w',
        '\u24E7': 'x',
        '\uFF58': 'x',
        '\u1E8B': 'x',
        '\u1E8D': 'x',
        '\u24E8': 'y',
        '\uFF59': 'y',
        '\u1EF3': 'y',
        '\u00FD': 'y',
        '\u0177': 'y',
        '\u1EF9': 'y',
        '\u0233': 'y',
        '\u1E8F': 'y',
        '\u00FF': 'y',
        '\u1EF7': 'y',
        '\u1E99': 'y',
        '\u1EF5': 'y',
        '\u01B4': 'y',
        '\u024F': 'y',
        '\u1EFF': 'y',
        '\u24E9': 'z',
        '\uFF5A': 'z',
        '\u017A': 'z',
        '\u1E91': 'z',
        '\u017C': 'z',
        '\u017E': 'z',
        '\u1E93': 'z',
        '\u1E95': 'z',
        '\u01B6': 'z',
        '\u0225': 'z',
        '\u0240': 'z',
        '\u2C6C': 'z',
        '\uA763': 'z',
        '\u0386': '\u0391',
        '\u0388': '\u0395',
        '\u0389': '\u0397',
        '\u038A': '\u0399',
        '\u03AA': '\u0399',
        '\u038C': '\u039F',
        '\u038E': '\u03A5',
        '\u03AB': '\u03A5',
        '\u038F': '\u03A9',
        '\u03AC': '\u03B1',
        '\u03AD': '\u03B5',
        '\u03AE': '\u03B7',
        '\u03AF': '\u03B9',
        '\u03CA': '\u03B9',
        '\u0390': '\u03B9',
        '\u03CC': '\u03BF',
        '\u03CD': '\u03C5',
        '\u03CB': '\u03C5',
        '\u03B0': '\u03C5',
        '\u03CE': '\u03C9',
        '\u03C2': '\u03C3',
        '\u2019': '\''
      };
      return diacritics;
    });
    S2.define('select2/data/base', ['../utils'], function (Utils) {
      function BaseAdapter($element, options) {
        BaseAdapter.__super__.constructor.call(this);
      }

      Utils.Extend(BaseAdapter, Utils.Observable);

      BaseAdapter.prototype.current = function (callback) {
        throw new Error('The `current` method must be defined in child classes.');
      };

      BaseAdapter.prototype.query = function (params, callback) {
        throw new Error('The `query` method must be defined in child classes.');
      };

      BaseAdapter.prototype.bind = function (container, $container) {// Can be implemented in subclasses
      };

      BaseAdapter.prototype.destroy = function () {// Can be implemented in subclasses
      };

      BaseAdapter.prototype.generateResultId = function (container, data) {
        var id = container.id + '-result-';
        id += Utils.generateChars(4);

        if (data.id != null) {
          id += '-' + data.id.toString();
        } else {
          id += '-' + Utils.generateChars(4);
        }

        return id;
      };

      return BaseAdapter;
    });
    S2.define('select2/data/select', ['./base', '../utils', 'jquery'], function (BaseAdapter, Utils, $) {
      function SelectAdapter($element, options) {
        this.$element = $element;
        this.options = options;

        SelectAdapter.__super__.constructor.call(this);
      }

      Utils.Extend(SelectAdapter, BaseAdapter);

      SelectAdapter.prototype.current = function (callback) {
        var self = this;
        var data = Array.prototype.map.call(this.$element[0].querySelectorAll(':checked'), function (selectedElement) {
          return self.item($(selectedElement));
        });
        callback(data);
      };

      SelectAdapter.prototype.select = function (data) {
        var self = this;
        data.selected = true; // If data.element is a DOM node, use it instead

        if (data.element != null && data.element.tagName.toLowerCase() === 'option') {
          data.element.selected = true;
          this.$element.trigger('input').trigger('change');
          return;
        }

        if (this.$element.prop('multiple')) {
          this.current(function (currentData) {
            var val = [];
            data = [data];
            data.push.apply(data, currentData);

            for (var d = 0; d < data.length; d++) {
              var id = data[d].id;

              if (val.indexOf(id) === -1) {
                val.push(id);
              }
            }

            self.$element.val(val);
            self.$element.trigger('input').trigger('change');
          });
        } else {
          var val = data.id;
          this.$element.val(val);
          this.$element.trigger('input').trigger('change');
        }
      };

      SelectAdapter.prototype.unselect = function (data) {
        var self = this;

        if (!this.$element.prop('multiple')) {
          return;
        }

        data.selected = false;

        if (data.element != null && data.element.tagName.toLowerCase() === 'option') {
          data.element.selected = false;
          this.$element.trigger('input').trigger('change');
          return;
        }

        this.current(function (currentData) {
          var val = [];

          for (var d = 0; d < currentData.length; d++) {
            var id = currentData[d].id;

            if (id !== data.id && val.indexOf(id) === -1) {
              val.push(id);
            }
          }

          self.$element.val(val);
          self.$element.trigger('input').trigger('change');
        });
      };

      SelectAdapter.prototype.bind = function (container, $container) {
        var self = this;
        this.container = container;
        container.on('select', function (params) {
          self.select(params.data);
        });
        container.on('unselect', function (params) {
          self.unselect(params.data);
        });
      };

      SelectAdapter.prototype.destroy = function () {
        // Remove anything added to child elements
        this.$element.find('*').each(function () {
          // Remove any custom data set by Select2
          Utils.RemoveData(this);
        });
      };

      SelectAdapter.prototype.query = function (params, callback) {
        var data = [];
        var self = this;
        var $options = this.$element.children();
        $options.each(function () {
          if (this.tagName.toLowerCase() !== 'option' && this.tagName.toLowerCase() !== 'optgroup') {
            return;
          }

          var $option = $(this);
          var option = self.item($option);
          var matches = self.matches(params, option);

          if (matches !== null) {
            data.push(matches);
          }
        });
        callback({
          results: data
        });
      };

      SelectAdapter.prototype.addOptions = function ($options) {
        this.$element.append($options);
      };

      SelectAdapter.prototype.option = function (data) {
        var option;

        if (data.children) {
          option = document.createElement('optgroup');
          option.label = data.text;
        } else {
          option = document.createElement('option');

          if (option.textContent !== undefined) {
            option.textContent = data.text;
          } else {
            option.innerText = data.text;
          }
        }

        if (data.id !== undefined) {
          option.value = data.id;
        }

        if (data.disabled) {
          option.disabled = true;
        }

        if (data.selected) {
          option.selected = true;
        }

        if (data.title) {
          option.title = data.title;
        }

        var normalizedData = this._normalizeItem(data);

        normalizedData.element = option; // Override the option's data with the combined data

        Utils.StoreData(option, 'data', normalizedData);
        return $(option);
      };

      SelectAdapter.prototype.item = function ($option) {
        var data = {};
        data = Utils.GetData($option[0], 'data');

        if (data != null) {
          return data;
        }

        var option = $option[0];

        if (option.tagName.toLowerCase() === 'option') {
          data = {
            id: $option.val(),
            text: $option.text(),
            disabled: $option.prop('disabled'),
            selected: $option.prop('selected'),
            title: $option.prop('title')
          };
        } else if (option.tagName.toLowerCase() === 'optgroup') {
          data = {
            text: $option.prop('label'),
            children: [],
            title: $option.prop('title')
          };
          var $children = $option.children('option');
          var children = [];

          for (var c = 0; c < $children.length; c++) {
            var $child = $($children[c]);
            var child = this.item($child);
            children.push(child);
          }

          data.children = children;
        }

        data = this._normalizeItem(data);
        data.element = $option[0];
        Utils.StoreData($option[0], 'data', data);
        return data;
      };

      SelectAdapter.prototype._normalizeItem = function (item) {
        if (item !== Object(item)) {
          item = {
            id: item,
            text: item
          };
        }

        item = $.extend({}, {
          text: ''
        }, item);
        var defaults = {
          selected: false,
          disabled: false
        };

        if (item.id != null) {
          item.id = item.id.toString();
        }

        if (item.text != null) {
          item.text = item.text.toString();
        }

        if (item._resultId == null && item.id && this.container != null) {
          item._resultId = this.generateResultId(this.container, item);
        }

        return $.extend({}, defaults, item);
      };

      SelectAdapter.prototype.matches = function (params, data) {
        var matcher = this.options.get('matcher');
        return matcher(params, data);
      };

      return SelectAdapter;
    });
    S2.define('select2/data/array', ['./select', '../utils', 'jquery'], function (SelectAdapter, Utils, $) {
      function ArrayAdapter($element, options) {
        this._dataToConvert = options.get('data') || [];

        ArrayAdapter.__super__.constructor.call(this, $element, options);
      }

      Utils.Extend(ArrayAdapter, SelectAdapter);

      ArrayAdapter.prototype.bind = function (container, $container) {
        ArrayAdapter.__super__.bind.call(this, container, $container);

        this.addOptions(this.convertToOptions(this._dataToConvert));
      };

      ArrayAdapter.prototype.select = function (data) {
        var $option = this.$element.find('option').filter(function (i, elm) {
          return elm.value == data.id.toString();
        });

        if ($option.length === 0) {
          $option = this.option(data);
          this.addOptions($option);
        }

        ArrayAdapter.__super__.select.call(this, data);
      };

      ArrayAdapter.prototype.convertToOptions = function (data) {
        var self = this;
        var $existing = this.$element.find('option');
        var existingIds = $existing.map(function () {
          return self.item($(this)).id;
        }).get();
        var $options = []; // Filter out all items except for the one passed in the argument

        function onlyItem(item) {
          return function () {
            return $(this).val() == item.id;
          };
        }

        for (var d = 0; d < data.length; d++) {
          var item = this._normalizeItem(data[d]); // Skip items which were pre-loaded, only merge the data


          if (existingIds.indexOf(item.id) >= 0) {
            var $existingOption = $existing.filter(onlyItem(item));
            var existingData = this.item($existingOption);
            var newData = $.extend(true, {}, item, existingData);
            var $newOption = this.option(newData);
            $existingOption.replaceWith($newOption);
            continue;
          }

          var $option = this.option(item);

          if (item.children) {
            var $children = this.convertToOptions(item.children);
            $option.append($children);
          }

          $options.push($option);
        }

        return $options;
      };

      return ArrayAdapter;
    });
    S2.define('select2/data/ajax', ['./array', '../utils', 'jquery'], function (ArrayAdapter, Utils, $) {
      function AjaxAdapter($element, options) {
        this.ajaxOptions = this._applyDefaults(options.get('ajax'));

        if (this.ajaxOptions.processResults != null) {
          this.processResults = this.ajaxOptions.processResults;
        }

        AjaxAdapter.__super__.constructor.call(this, $element, options);
      }

      Utils.Extend(AjaxAdapter, ArrayAdapter);

      AjaxAdapter.prototype._applyDefaults = function (options) {
        var defaults = {
          data: function (params) {
            return $.extend({}, params, {
              q: params.term
            });
          },
          transport: function (params, success, failure) {
            var $request = $.ajax(params);
            $request.then(success);
            $request.fail(failure);
            return $request;
          }
        };
        return $.extend({}, defaults, options, true);
      };

      AjaxAdapter.prototype.processResults = function (results) {
        return results;
      };

      AjaxAdapter.prototype.query = function (params, callback) {
        var matches = [];
        var self = this;

        if (this._request != null) {
          // JSONP requests cannot always be aborted
          if (typeof this._request.abort === 'function') {
            this._request.abort();
          }

          this._request = null;
        }

        var options = $.extend({
          type: 'GET'
        }, this.ajaxOptions);

        if (typeof options.url === 'function') {
          options.url = options.url.call(this.$element, params);
        }

        if (typeof options.data === 'function') {
          options.data = options.data.call(this.$element, params);
        }

        function request() {
          var $request = options.transport(options, function (data) {
            var results = self.processResults(data, params);

            if (self.options.get('debug') && window.console && console.error) {
              // Check to make sure that the response included a `results` key.
              if (!results || !results.results || !Array.isArray(results.results)) {
                console.error('Select2: The AJAX results did not return an array in the ' + '`results` key of the response.');
              }
            }

            callback(results);
          }, function () {
            // Attempt to detect if a request was aborted
            // Only works if the transport exposes a status property
            if ('status' in $request && ($request.status === 0 || $request.status === '0')) {
              return;
            }

            self.trigger('results:message', {
              message: 'errorLoading'
            });
          });
          self._request = $request;
        }

        if (this.ajaxOptions.delay && params.term != null) {
          if (this._queryTimeout) {
            window.clearTimeout(this._queryTimeout);
          }

          this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
        } else {
          request();
        }
      };

      return AjaxAdapter;
    });
    S2.define('select2/data/tags', ['jquery'], function ($) {
      function Tags(decorated, $element, options) {
        var tags = options.get('tags');
        var createTag = options.get('createTag');

        if (createTag !== undefined) {
          this.createTag = createTag;
        }

        var insertTag = options.get('insertTag');

        if (insertTag !== undefined) {
          this.insertTag = insertTag;
        }

        decorated.call(this, $element, options);

        if (Array.isArray(tags)) {
          for (var t = 0; t < tags.length; t++) {
            var tag = tags[t];

            var item = this._normalizeItem(tag);

            var $option = this.option(item);
            this.$element.append($option);
          }
        }
      }

      Tags.prototype.query = function (decorated, params, callback) {
        var self = this;

        this._removeOldTags();

        if (params.term == null || params.page != null) {
          decorated.call(this, params, callback);
          return;
        }

        function wrapper(obj, child) {
          var data = obj.results;

          for (var i = 0; i < data.length; i++) {
            var option = data[i];
            var checkChildren = option.children != null && !wrapper({
              results: option.children
            }, true);
            var optionText = (option.text || '').toUpperCase();
            var paramsTerm = (params.term || '').toUpperCase();
            var checkText = optionText === paramsTerm;

            if (checkText || checkChildren) {
              if (child) {
                return false;
              }

              obj.data = data;
              callback(obj);
              return;
            }
          }

          if (child) {
            return true;
          }

          var tag = self.createTag(params);

          if (tag != null) {
            var $option = self.option(tag);
            $option.attr('data-select2-tag', 'true');
            self.addOptions([$option]);
            self.insertTag(data, tag);
          }

          obj.results = data;
          callback(obj);
        }

        decorated.call(this, params, wrapper);
      };

      Tags.prototype.createTag = function (decorated, params) {
        if (params.term == null) {
          return null;
        }

        var term = params.term.trim();

        if (term === '') {
          return null;
        }

        return {
          id: term,
          text: term
        };
      };

      Tags.prototype.insertTag = function (_, data, tag) {
        data.unshift(tag);
      };

      Tags.prototype._removeOldTags = function (_) {
        var $options = this.$element.find('option[data-select2-tag]');
        $options.each(function () {
          if (this.selected) {
            return;
          }

          $(this).remove();
        });
      };

      return Tags;
    });
    S2.define('select2/data/tokenizer', ['jquery'], function ($) {
      function Tokenizer(decorated, $element, options) {
        var tokenizer = options.get('tokenizer');

        if (tokenizer !== undefined) {
          this.tokenizer = tokenizer;
        }

        decorated.call(this, $element, options);
      }

      Tokenizer.prototype.bind = function (decorated, container, $container) {
        decorated.call(this, container, $container);
        this.$search = container.dropdown.$search || container.selection.$search || $container.find('.select2-search__field');
      };

      Tokenizer.prototype.query = function (decorated, params, callback) {
        var self = this;

        function createAndSelect(data) {
          // Normalize the data object so we can use it for checks
          var item = self._normalizeItem(data); // Check if the data object already exists as a tag
          // Select it if it doesn't


          var $existingOptions = self.$element.find('option').filter(function () {
            return $(this).val() === item.id;
          }); // If an existing option wasn't found for it, create the option

          if (!$existingOptions.length) {
            var $option = self.option(item);
            $option.attr('data-select2-tag', true);

            self._removeOldTags();

            self.addOptions([$option]);
          } // Select the item, now that we know there is an option for it


          select(item);
        }

        function select(data) {
          self.trigger('select', {
            data: data
          });
        }

        params.term = params.term || '';
        var tokenData = this.tokenizer(params, this.options, createAndSelect);

        if (tokenData.term !== params.term) {
          // Replace the search term if we have the search box
          if (this.$search.length) {
            this.$search.val(tokenData.term);
            this.$search.trigger('focus');
          }

          params.term = tokenData.term;
        }

        decorated.call(this, params, callback);
      };

      Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
        var separators = options.get('tokenSeparators') || [];
        var term = params.term;
        var i = 0;

        var createTag = this.createTag || function (params) {
          return {
            id: params.term,
            text: params.term
          };
        };

        while (i < term.length) {
          var termChar = term[i];

          if (separators.indexOf(termChar) === -1) {
            i++;
            continue;
          }

          var part = term.substr(0, i);
          var partParams = $.extend({}, params, {
            term: part
          });
          var data = createTag(partParams);

          if (data == null) {
            i++;
            continue;
          }

          callback(data); // Reset the term to not include the tokenized portion

          term = term.substr(i + 1) || '';
          i = 0;
        }

        return {
          term: term
        };
      };

      return Tokenizer;
    });
    S2.define('select2/data/minimumInputLength', [], function () {
      function MinimumInputLength(decorated, $e, options) {
        this.minimumInputLength = options.get('minimumInputLength');
        decorated.call(this, $e, options);
      }

      MinimumInputLength.prototype.query = function (decorated, params, callback) {
        params.term = params.term || '';

        if (params.term.length < this.minimumInputLength) {
          this.trigger('results:message', {
            message: 'inputTooShort',
            args: {
              minimum: this.minimumInputLength,
              input: params.term,
              params: params
            }
          });
          return;
        }

        decorated.call(this, params, callback);
      };

      return MinimumInputLength;
    });
    S2.define('select2/data/maximumInputLength', [], function () {
      function MaximumInputLength(decorated, $e, options) {
        this.maximumInputLength = options.get('maximumInputLength');
        decorated.call(this, $e, options);
      }

      MaximumInputLength.prototype.query = function (decorated, params, callback) {
        params.term = params.term || '';

        if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
          this.trigger('results:message', {
            message: 'inputTooLong',
            args: {
              maximum: this.maximumInputLength,
              input: params.term,
              params: params
            }
          });
          return;
        }

        decorated.call(this, params, callback);
      };

      return MaximumInputLength;
    });
    S2.define('select2/data/maximumSelectionLength', [], function () {
      function MaximumSelectionLength(decorated, $e, options) {
        this.maximumSelectionLength = options.get('maximumSelectionLength');
        decorated.call(this, $e, options);
      }

      MaximumSelectionLength.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('select', function () {
          self._checkIfMaximumSelected();
        });
      };

      MaximumSelectionLength.prototype.query = function (decorated, params, callback) {
        var self = this;

        this._checkIfMaximumSelected(function () {
          decorated.call(self, params, callback);
        });
      };

      MaximumSelectionLength.prototype._checkIfMaximumSelected = function (_, successCallback) {
        var self = this;
        this.current(function (currentData) {
          var count = currentData != null ? currentData.length : 0;

          if (self.maximumSelectionLength > 0 && count >= self.maximumSelectionLength) {
            self.trigger('results:message', {
              message: 'maximumSelected',
              args: {
                maximum: self.maximumSelectionLength
              }
            });
            return;
          }

          if (successCallback) {
            successCallback();
          }
        });
      };

      return MaximumSelectionLength;
    });
    S2.define('select2/dropdown', ['jquery', './utils'], function ($, Utils) {
      function Dropdown($element, options) {
        this.$element = $element;
        this.options = options;

        Dropdown.__super__.constructor.call(this);
      }

      Utils.Extend(Dropdown, Utils.Observable);

      Dropdown.prototype.render = function () {
        var $dropdown = $('<span class="select2-dropdown">' + '<span class="select2-results"></span>' + '</span>');
        $dropdown.attr('dir', this.options.get('dir'));
        this.$dropdown = $dropdown;
        return $dropdown;
      };

      Dropdown.prototype.bind = function () {// Should be implemented in subclasses
      };

      Dropdown.prototype.position = function ($dropdown, $container) {// Should be implemented in subclasses
      };

      Dropdown.prototype.destroy = function () {
        // Remove the dropdown from the DOM
        this.$dropdown.remove();
      };

      return Dropdown;
    });
    S2.define('select2/dropdown/search', ['jquery'], function ($) {
      function Search() {}

      Search.prototype.render = function (decorated) {
        var $rendered = decorated.call(this);
        var searchLabel = this.options.get('translations').get('search');
        var $search = $('<span class="select2-search select2-search--dropdown">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' + '</span>');
        this.$searchContainer = $search;
        this.$search = $search.find('input');
        this.$search.prop('autocomplete', this.options.get('autocomplete'));
        this.$search.attr('aria-label', searchLabel());
        $rendered.prepend($search);
        return $rendered;
      };

      Search.prototype.bind = function (decorated, container, $container) {
        var self = this;
        var resultsId = container.id + '-results';
        decorated.call(this, container, $container);
        this.$search.on('keydown', function (evt) {
          self.trigger('keypress', evt);
          self._keyUpPrevented = evt.isDefaultPrevented();
        }); // Workaround for browsers which do not support the `input` event
        // This will prevent double-triggering of events for browsers which support
        // both the `keyup` and `input` events.

        this.$search.on('input', function (evt) {
          // Unbind the duplicated `keyup` event
          $(this).off('keyup');
        });
        this.$search.on('keyup input', function (evt) {
          self.handleSearch(evt);
        });
        container.on('open', function () {
          self.$search.attr('tabindex', 0);
          self.$search.attr('aria-controls', resultsId);
          self.$search.trigger('focus');
          window.setTimeout(function () {
            self.$search.trigger('focus');
          }, 0);
        });
        container.on('close', function () {
          self.$search.attr('tabindex', -1);
          self.$search.removeAttr('aria-controls');
          self.$search.removeAttr('aria-activedescendant');
          self.$search.val('');
          self.$search.trigger('blur');
        });
        container.on('focus', function () {
          if (!container.isOpen()) {
            self.$search.trigger('focus');
          }
        });
        container.on('results:all', function (params) {
          if (params.query.term == null || params.query.term === '') {
            var showSearch = self.showSearch(params);

            if (showSearch) {
              self.$searchContainer[0].classList.remove('select2-search--hide');
            } else {
              self.$searchContainer[0].classList.add('select2-search--hide');
            }
          }
        });
        container.on('results:focus', function (params) {
          if (params.data._resultId) {
            self.$search.attr('aria-activedescendant', params.data._resultId);
          } else {
            self.$search.removeAttr('aria-activedescendant');
          }
        });
      };

      Search.prototype.handleSearch = function (evt) {
        if (!this._keyUpPrevented) {
          var input = this.$search.val();
          this.trigger('query', {
            term: input
          });
        }

        this._keyUpPrevented = false;
      };

      Search.prototype.showSearch = function (_, params) {
        return true;
      };

      return Search;
    });
    S2.define('select2/dropdown/hidePlaceholder', [], function () {
      function HidePlaceholder(decorated, $element, options, dataAdapter) {
        this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
        decorated.call(this, $element, options, dataAdapter);
      }

      HidePlaceholder.prototype.append = function (decorated, data) {
        data.results = this.removePlaceholder(data.results);
        decorated.call(this, data);
      };

      HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
        if (typeof placeholder === 'string') {
          placeholder = {
            id: '',
            text: placeholder
          };
        }

        return placeholder;
      };

      HidePlaceholder.prototype.removePlaceholder = function (_, data) {
        var modifiedData = data.slice(0);

        for (var d = data.length - 1; d >= 0; d--) {
          var item = data[d];

          if (this.placeholder.id === item.id) {
            modifiedData.splice(d, 1);
          }
        }

        return modifiedData;
      };

      return HidePlaceholder;
    });
    S2.define('select2/dropdown/infiniteScroll', ['jquery'], function ($) {
      function InfiniteScroll(decorated, $element, options, dataAdapter) {
        this.lastParams = {};
        decorated.call(this, $element, options, dataAdapter);
        this.$loadingMore = this.createLoadingMore();
        this.loading = false;
      }

      InfiniteScroll.prototype.append = function (decorated, data) {
        this.$loadingMore.remove();
        this.loading = false;
        decorated.call(this, data);

        if (this.showLoadingMore(data)) {
          this.$results.append(this.$loadingMore);
          this.loadMoreIfNeeded();
        }
      };

      InfiniteScroll.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('query', function (params) {
          self.lastParams = params;
          self.loading = true;
        });
        container.on('query:append', function (params) {
          self.lastParams = params;
          self.loading = true;
        });
        this.$results.on('scroll', this.loadMoreIfNeeded.bind(this));
      };

      InfiniteScroll.prototype.loadMoreIfNeeded = function () {
        var isLoadMoreVisible = $.contains(document.documentElement, this.$loadingMore[0]);

        if (this.loading || !isLoadMoreVisible) {
          return;
        }

        var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
        var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);

        if (currentOffset + 50 >= loadingMoreOffset) {
          this.loadMore();
        }
      };

      InfiniteScroll.prototype.loadMore = function () {
        this.loading = true;
        var params = $.extend({}, {
          page: 1
        }, this.lastParams);
        params.page++;
        this.trigger('query:append', params);
      };

      InfiniteScroll.prototype.showLoadingMore = function (_, data) {
        return data.pagination && data.pagination.more;
      };

      InfiniteScroll.prototype.createLoadingMore = function () {
        var $option = $('<li ' + 'class="select2-results__option select2-results__option--load-more"' + 'role="option" aria-disabled="true"></li>');
        var message = this.options.get('translations').get('loadingMore');
        $option.html(message(this.lastParams));
        return $option;
      };

      return InfiniteScroll;
    });
    S2.define('select2/dropdown/attachBody', ['jquery', '../utils'], function ($, Utils) {
      function AttachBody(decorated, $element, options) {
        this.$dropdownParent = $(options.get('dropdownParent') || document.body);
        decorated.call(this, $element, options);
      }

      AttachBody.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('open', function () {
          self._showDropdown();

          self._attachPositioningHandler(container); // Must bind after the results handlers to ensure correct sizing


          self._bindContainerResultHandlers(container);
        });
        container.on('close', function () {
          self._hideDropdown();

          self._detachPositioningHandler(container);
        });
        this.$dropdownContainer.on('mousedown', function (evt) {
          evt.stopPropagation();
        });
      };

      AttachBody.prototype.destroy = function (decorated) {
        decorated.call(this);
        this.$dropdownContainer.remove();
      };

      AttachBody.prototype.position = function (decorated, $dropdown, $container) {
        // Clone all of the container classes
        $dropdown.attr('class', $container.attr('class'));
        $dropdown[0].classList.remove('select2');
        $dropdown[0].classList.add('select2-container--open');
        $dropdown.css({
          position: 'absolute',
          top: -999999
        });
        this.$container = $container;
      };

      AttachBody.prototype.render = function (decorated) {
        var $container = $('<span></span>');
        var $dropdown = decorated.call(this);
        $container.append($dropdown);
        this.$dropdownContainer = $container;
        return $container;
      };

      AttachBody.prototype._hideDropdown = function (decorated) {
        this.$dropdownContainer.detach();
      };

      AttachBody.prototype._bindContainerResultHandlers = function (decorated, container) {
        // These should only be bound once
        if (this._containerResultsHandlersBound) {
          return;
        }

        var self = this;
        container.on('results:all', function () {
          self._positionDropdown();

          self._resizeDropdown();
        });
        container.on('results:append', function () {
          self._positionDropdown();

          self._resizeDropdown();
        });
        container.on('results:message', function () {
          self._positionDropdown();

          self._resizeDropdown();
        });
        container.on('select', function () {
          self._positionDropdown();

          self._resizeDropdown();
        });
        container.on('unselect', function () {
          self._positionDropdown();

          self._resizeDropdown();
        });
        this._containerResultsHandlersBound = true;
      };

      AttachBody.prototype._attachPositioningHandler = function (decorated, container) {
        var self = this;
        var scrollEvent = 'scroll.select2.' + container.id;
        var resizeEvent = 'resize.select2.' + container.id;
        var orientationEvent = 'orientationchange.select2.' + container.id;
        var $watchers = this.$container.parents().filter(Utils.hasScroll);
        $watchers.each(function () {
          Utils.StoreData(this, 'select2-scroll-position', {
            x: $(this).scrollLeft(),
            y: $(this).scrollTop()
          });
        });
        $watchers.on(scrollEvent, function (ev) {
          var position = Utils.GetData(this, 'select2-scroll-position');
          $(this).scrollTop(position.y);
        });
        $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent, function (e) {
          self._positionDropdown();

          self._resizeDropdown();
        });
      };

      AttachBody.prototype._detachPositioningHandler = function (decorated, container) {
        var scrollEvent = 'scroll.select2.' + container.id;
        var resizeEvent = 'resize.select2.' + container.id;
        var orientationEvent = 'orientationchange.select2.' + container.id;
        var $watchers = this.$container.parents().filter(Utils.hasScroll);
        $watchers.off(scrollEvent);
        $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
      };

      AttachBody.prototype._positionDropdown = function () {
        var $window = $(window);
        var isCurrentlyAbove = this.$dropdown[0].classList.contains('select2-dropdown--above');
        var isCurrentlyBelow = this.$dropdown[0].classList.contains('select2-dropdown--below');
        var newDirection = null;
        var offset = this.$container.offset();
        offset.bottom = offset.top + this.$container.outerHeight(false);
        var container = {
          height: this.$container.outerHeight(false)
        };
        container.top = offset.top;
        container.bottom = offset.top + container.height;
        var dropdown = {
          height: this.$dropdown.outerHeight(false)
        };
        var viewport = {
          top: $window.scrollTop(),
          bottom: $window.scrollTop() + $window.height()
        };
        var enoughRoomAbove = viewport.top < offset.top - dropdown.height;
        var enoughRoomBelow = viewport.bottom > offset.bottom + dropdown.height;
        var css = {
          left: offset.left,
          top: container.bottom
        }; // Determine what the parent element is to use for calculating the offset

        var $offsetParent = this.$dropdownParent; // For statically positioned elements, we need to get the element
        // that is determining the offset

        if ($offsetParent.css('position') === 'static') {
          $offsetParent = $offsetParent.offsetParent();
        }

        var parentOffset = {
          top: 0,
          left: 0
        };

        if ($.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
          parentOffset = $offsetParent.offset();
        }

        css.top -= parentOffset.top;
        css.left -= parentOffset.left;

        if (!isCurrentlyAbove && !isCurrentlyBelow) {
          newDirection = 'below';
        }

        if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
          newDirection = 'above';
        } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
          newDirection = 'below';
        }

        if (newDirection == 'above' || isCurrentlyAbove && newDirection !== 'below') {
          css.top = container.top - parentOffset.top - dropdown.height;
        }

        if (newDirection != null) {
          this.$dropdown[0].classList.remove('select2-dropdown--below');
          this.$dropdown[0].classList.remove('select2-dropdown--above');
          this.$dropdown[0].classList.add('select2-dropdown--' + newDirection);
          this.$container[0].classList.remove('select2-container--below');
          this.$container[0].classList.remove('select2-container--above');
          this.$container[0].classList.add('select2-container--' + newDirection);
        }

        this.$dropdownContainer.css(css);
      };

      AttachBody.prototype._resizeDropdown = function () {
        var css = {
          width: this.$container.outerWidth(false) + 'px'
        };

        if (this.options.get('dropdownAutoWidth')) {
          css.minWidth = css.width;
          css.position = 'relative';
          css.width = 'auto';
        }

        this.$dropdown.css(css);
      };

      AttachBody.prototype._showDropdown = function (decorated) {
        this.$dropdownContainer.appendTo(this.$dropdownParent);

        this._positionDropdown();

        this._resizeDropdown();
      };

      return AttachBody;
    });
    S2.define('select2/dropdown/minimumResultsForSearch', [], function () {
      function countResults(data) {
        var count = 0;

        for (var d = 0; d < data.length; d++) {
          var item = data[d];

          if (item.children) {
            count += countResults(item.children);
          } else {
            count++;
          }
        }

        return count;
      }

      function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
        this.minimumResultsForSearch = options.get('minimumResultsForSearch');

        if (this.minimumResultsForSearch < 0) {
          this.minimumResultsForSearch = Infinity;
        }

        decorated.call(this, $element, options, dataAdapter);
      }

      MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
        if (countResults(params.data.results) < this.minimumResultsForSearch) {
          return false;
        }

        return decorated.call(this, params);
      };

      return MinimumResultsForSearch;
    });
    S2.define('select2/dropdown/selectOnClose', ['../utils'], function (Utils) {
      function SelectOnClose() {}

      SelectOnClose.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('close', function (params) {
          self._handleSelectOnClose(params);
        });
      };

      SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
        if (params && params.originalSelect2Event != null) {
          var event = params.originalSelect2Event; // Don't select an item if the close event was triggered from a select or
          // unselect event

          if (event._type === 'select' || event._type === 'unselect') {
            return;
          }
        }

        var $highlightedResults = this.getHighlightedResults(); // Only select highlighted results

        if ($highlightedResults.length < 1) {
          return;
        }

        var data = Utils.GetData($highlightedResults[0], 'data'); // Don't re-select already selected resulte

        if (data.element != null && data.element.selected || data.element == null && data.selected) {
          return;
        }

        this.trigger('select', {
          data: data
        });
      };

      return SelectOnClose;
    });
    S2.define('select2/dropdown/closeOnSelect', [], function () {
      function CloseOnSelect() {}

      CloseOnSelect.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('select', function (evt) {
          self._selectTriggered(evt);
        });
        container.on('unselect', function (evt) {
          self._selectTriggered(evt);
        });
      };

      CloseOnSelect.prototype._selectTriggered = function (_, evt) {
        var originalEvent = evt.originalEvent; // Don't close if the control key is being held

        if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
          return;
        }

        this.trigger('close', {
          originalEvent: originalEvent,
          originalSelect2Event: evt
        });
      };

      return CloseOnSelect;
    });
    S2.define('select2/dropdown/dropdownCss', ['../utils'], function (Utils) {
      function DropdownCSS() {}

      DropdownCSS.prototype.render = function (decorated) {
        var $dropdown = decorated.call(this);
        var dropdownCssClass = this.options.get('dropdownCssClass') || '';

        if (dropdownCssClass.indexOf(':all:') !== -1) {
          dropdownCssClass = dropdownCssClass.replace(':all:', '');
          Utils.copyNonInternalCssClasses($dropdown[0], this.$element[0]);
        }

        $dropdown.addClass(dropdownCssClass);
        return $dropdown;
      };

      return DropdownCSS;
    });
    S2.define('select2/dropdown/tagsSearchHighlight', ['../utils'], function (Utils) {
      function TagsSearchHighlight() {}

      TagsSearchHighlight.prototype.highlightFirstItem = function (decorated) {
        var $options = this.$results.find('.select2-results__option--selectable' + ':not(.select2-results__option--selected)');

        if ($options.length > 0) {
          var $firstOption = $options.first();
          var data = Utils.GetData($firstOption[0], 'data');
          var firstElement = data.element;

          if (firstElement && firstElement.getAttribute) {
            if (firstElement.getAttribute('data-select2-tag') === 'true') {
              $firstOption.trigger('mouseenter');
              return;
            }
          }
        }

        decorated.call(this);
      };

      return TagsSearchHighlight;
    });
    S2.define('select2/i18n/en', [], function () {
      // English
      return {
        errorLoading: function () {
          return 'The results could not be loaded.';
        },
        inputTooLong: function (args) {
          var overChars = args.input.length - args.maximum;
          var message = 'Please delete ' + overChars + ' character';

          if (overChars != 1) {
            message += 's';
          }

          return message;
        },
        inputTooShort: function (args) {
          var remainingChars = args.minimum - args.input.length;
          var message = 'Please enter ' + remainingChars + ' or more characters';
          return message;
        },
        loadingMore: function () {
          return 'Loading more results…';
        },
        maximumSelected: function (args) {
          var message = 'You can only select ' + args.maximum + ' item';

          if (args.maximum != 1) {
            message += 's';
          }

          return message;
        },
        noResults: function () {
          return 'No results found';
        },
        searching: function () {
          return 'Searching…';
        },
        removeAllItems: function () {
          return 'Remove all items';
        },
        removeItem: function () {
          return 'Remove item';
        },
        search: function () {
          return 'Search';
        }
      };
    });
    S2.define('select2/defaults', ['jquery', './results', './selection/single', './selection/multiple', './selection/placeholder', './selection/allowClear', './selection/search', './selection/selectionCss', './selection/eventRelay', './utils', './translation', './diacritics', './data/select', './data/array', './data/ajax', './data/tags', './data/tokenizer', './data/minimumInputLength', './data/maximumInputLength', './data/maximumSelectionLength', './dropdown', './dropdown/search', './dropdown/hidePlaceholder', './dropdown/infiniteScroll', './dropdown/attachBody', './dropdown/minimumResultsForSearch', './dropdown/selectOnClose', './dropdown/closeOnSelect', './dropdown/dropdownCss', './dropdown/tagsSearchHighlight', './i18n/en'], function ($, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, SelectionCSS, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, DropdownCSS, TagsSearchHighlight, EnglishTranslation) {
      function Defaults() {
        this.reset();
      }

      Defaults.prototype.apply = function (options) {
        options = $.extend(true, {}, this.defaults, options);

        if (options.dataAdapter == null) {
          if (options.ajax != null) {
            options.dataAdapter = AjaxData;
          } else if (options.data != null) {
            options.dataAdapter = ArrayData;
          } else {
            options.dataAdapter = SelectData;
          }

          if (options.minimumInputLength > 0) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, MinimumInputLength);
          }

          if (options.maximumInputLength > 0) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumInputLength);
          }

          if (options.maximumSelectionLength > 0) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumSelectionLength);
          }

          if (options.tags) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
          }

          if (options.tokenSeparators != null || options.tokenizer != null) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, Tokenizer);
          }
        }

        if (options.resultsAdapter == null) {
          options.resultsAdapter = ResultsList;

          if (options.ajax != null) {
            options.resultsAdapter = Utils.Decorate(options.resultsAdapter, InfiniteScroll);
          }

          if (options.placeholder != null) {
            options.resultsAdapter = Utils.Decorate(options.resultsAdapter, HidePlaceholder);
          }

          if (options.selectOnClose) {
            options.resultsAdapter = Utils.Decorate(options.resultsAdapter, SelectOnClose);
          }

          if (options.tags) {
            options.resultsAdapter = Utils.Decorate(options.resultsAdapter, TagsSearchHighlight);
          }
        }

        if (options.dropdownAdapter == null) {
          if (options.multiple) {
            options.dropdownAdapter = Dropdown;
          } else {
            var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
            options.dropdownAdapter = SearchableDropdown;
          }

          if (options.minimumResultsForSearch !== 0) {
            options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, MinimumResultsForSearch);
          }

          if (options.closeOnSelect) {
            options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, CloseOnSelect);
          }

          if (options.dropdownCssClass != null) {
            options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, DropdownCSS);
          }

          options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, AttachBody);
        }

        if (options.selectionAdapter == null) {
          if (options.multiple) {
            options.selectionAdapter = MultipleSelection;
          } else {
            options.selectionAdapter = SingleSelection;
          } // Add the placeholder mixin if a placeholder was specified


          if (options.placeholder != null) {
            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, Placeholder);
          }

          if (options.allowClear) {
            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, AllowClear);
          }

          if (options.multiple) {
            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionSearch);
          }

          if (options.selectionCssClass != null) {
            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionCSS);
          }

          options.selectionAdapter = Utils.Decorate(options.selectionAdapter, EventRelay);
        } // If the defaults were not previously applied from an element, it is
        // possible for the language option to have not been resolved


        options.language = this._resolveLanguage(options.language); // Always fall back to English since it will always be complete

        options.language.push('en');
        var uniqueLanguages = [];

        for (var l = 0; l < options.language.length; l++) {
          var language = options.language[l];

          if (uniqueLanguages.indexOf(language) === -1) {
            uniqueLanguages.push(language);
          }
        }

        options.language = uniqueLanguages;
        options.translations = this._processTranslations(options.language, options.debug);
        return options;
      };

      Defaults.prototype.reset = function () {
        function stripDiacritics(text) {
          // Used 'uni range + named function' from http://jsperf.com/diacritics/18
          function match(a) {
            return DIACRITICS[a] || a;
          }

          return text.replace(/[^\u0000-\u007E]/g, match);
        }

        function matcher(params, data) {
          // Always return the object if there is nothing to compare
          if (params.term == null || params.term.trim() === '') {
            return data;
          } // Do a recursive check for options with children


          if (data.children && data.children.length > 0) {
            // Clone the data object if there are children
            // This is required as we modify the object to remove any non-matches
            var match = $.extend(true, {}, data); // Check each child of the option

            for (var c = data.children.length - 1; c >= 0; c--) {
              var child = data.children[c];
              var matches = matcher(params, child); // If there wasn't a match, remove the object in the array

              if (matches == null) {
                match.children.splice(c, 1);
              }
            } // If any children matched, return the new object


            if (match.children.length > 0) {
              return match;
            } // If there were no matching children, check just the plain object


            return matcher(params, match);
          }

          var original = stripDiacritics(data.text).toUpperCase();
          var term = stripDiacritics(params.term).toUpperCase(); // Check if the text contains the term

          if (original.indexOf(term) > -1) {
            return data;
          } // If it doesn't contain the term, don't return anything


          return null;
        }

        this.defaults = {
          amdLanguageBase: './i18n/',
          autocomplete: 'off',
          closeOnSelect: true,
          debug: false,
          dropdownAutoWidth: false,
          escapeMarkup: Utils.escapeMarkup,
          language: {},
          matcher: matcher,
          minimumInputLength: 0,
          maximumInputLength: 0,
          maximumSelectionLength: 0,
          minimumResultsForSearch: 0,
          selectOnClose: false,
          scrollAfterSelect: false,
          sorter: function (data) {
            return data;
          },
          templateResult: function (result) {
            return result.text;
          },
          templateSelection: function (selection) {
            return selection.text;
          },
          theme: 'default',
          width: 'resolve'
        };
      };

      Defaults.prototype.applyFromElement = function (options, $element) {
        var optionLanguage = options.language;
        var defaultLanguage = this.defaults.language;
        var elementLanguage = $element.prop('lang');
        var parentLanguage = $element.closest('[lang]').prop('lang');
        var languages = Array.prototype.concat.call(this._resolveLanguage(elementLanguage), this._resolveLanguage(optionLanguage), this._resolveLanguage(defaultLanguage), this._resolveLanguage(parentLanguage));
        options.language = languages;
        return options;
      };

      Defaults.prototype._resolveLanguage = function (language) {
        if (!language) {
          return [];
        }

        if ($.isEmptyObject(language)) {
          return [];
        }

        if ($.isPlainObject(language)) {
          return [language];
        }

        var languages;

        if (!Array.isArray(language)) {
          languages = [language];
        } else {
          languages = language;
        }

        var resolvedLanguages = [];

        for (var l = 0; l < languages.length; l++) {
          resolvedLanguages.push(languages[l]);

          if (typeof languages[l] === 'string' && languages[l].indexOf('-') > 0) {
            // Extract the region information if it is included
            var languageParts = languages[l].split('-');
            var baseLanguage = languageParts[0];
            resolvedLanguages.push(baseLanguage);
          }
        }

        return resolvedLanguages;
      };

      Defaults.prototype._processTranslations = function (languages, debug) {
        var translations = new Translation();

        for (var l = 0; l < languages.length; l++) {
          var languageData = new Translation();
          var language = languages[l];

          if (typeof language === 'string') {
            try {
              // Try to load it with the original name
              languageData = Translation.loadPath(language);
            } catch (e) {
              try {
                // If we couldn't load it, check if it wasn't the full path
                language = this.defaults.amdLanguageBase + language;
                languageData = Translation.loadPath(language);
              } catch (ex) {
                // The translation could not be loaded at all. Sometimes this is
                // because of a configuration problem, other times this can be
                // because of how Select2 helps load all possible translation files
                if (debug && window.console && console.warn) {
                  console.warn('Select2: The language file for "' + language + '" could ' + 'not be automatically loaded. A fallback will be used instead.');
                }
              }
            }
          } else if ($.isPlainObject(language)) {
            languageData = new Translation(language);
          } else {
            languageData = language;
          }

          translations.extend(languageData);
        }

        return translations;
      };

      Defaults.prototype.set = function (key, value) {
        var camelKey = $.camelCase(key);
        var data = {};
        data[camelKey] = value;

        var convertedData = Utils._convertData(data);

        $.extend(true, this.defaults, convertedData);
      };

      var defaults = new Defaults();
      return defaults;
    });
    S2.define('select2/options', ['jquery', './defaults', './utils'], function ($, Defaults, Utils) {
      function Options(options, $element) {
        this.options = options;

        if ($element != null) {
          this.fromElement($element);
        }

        if ($element != null) {
          this.options = Defaults.applyFromElement(this.options, $element);
        }

        this.options = Defaults.apply(this.options);
      }

      Options.prototype.fromElement = function ($e) {
        var excludedData = ['select2'];

        if (this.options.multiple == null) {
          this.options.multiple = $e.prop('multiple');
        }

        if (this.options.disabled == null) {
          this.options.disabled = $e.prop('disabled');
        }

        if (this.options.autocomplete == null && $e.prop('autocomplete')) {
          this.options.autocomplete = $e.prop('autocomplete');
        }

        if (this.options.dir == null) {
          if ($e.prop('dir')) {
            this.options.dir = $e.prop('dir');
          } else if ($e.closest('[dir]').prop('dir')) {
            this.options.dir = $e.closest('[dir]').prop('dir');
          } else {
            this.options.dir = 'ltr';
          }
        }

        $e.prop('disabled', this.options.disabled);
        $e.prop('multiple', this.options.multiple);

        if (Utils.GetData($e[0], 'select2Tags')) {
          if (this.options.debug && window.console && console.warn) {
            console.warn('Select2: The `data-select2-tags` attribute has been changed to ' + 'use the `data-data` and `data-tags="true"` attributes and will be ' + 'removed in future versions of Select2.');
          }

          Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));
          Utils.StoreData($e[0], 'tags', true);
        }

        if (Utils.GetData($e[0], 'ajaxUrl')) {
          if (this.options.debug && window.console && console.warn) {
            console.warn('Select2: The `data-ajax-url` attribute has been changed to ' + '`data-ajax--url` and support for the old attribute will be removed' + ' in future versions of Select2.');
          }

          $e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));
          Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));
        }

        var dataset = {};

        function upperCaseLetter(_, letter) {
          return letter.toUpperCase();
        } // Pre-load all of the attributes which are prefixed with `data-`


        for (var attr = 0; attr < $e[0].attributes.length; attr++) {
          var attributeName = $e[0].attributes[attr].name;
          var prefix = 'data-';

          if (attributeName.substr(0, prefix.length) == prefix) {
            // Get the contents of the attribute after `data-`
            var dataName = attributeName.substring(prefix.length); // Get the data contents from the consistent source
            // This is more than likely the jQuery data helper

            var dataValue = Utils.GetData($e[0], dataName); // camelCase the attribute name to match the spec

            var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter); // Store the data attribute contents into the dataset since

            dataset[camelDataName] = dataValue;
          }
        } // Prefer the element's `dataset` attribute if it exists
        // jQuery 1.x does not correctly handle data attributes with multiple dashes


        if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
          dataset = $.extend(true, {}, $e[0].dataset, dataset);
        } // Prefer our internal data cache if it exists


        var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);
        data = Utils._convertData(data);

        for (var key in data) {
          if (excludedData.indexOf(key) > -1) {
            continue;
          }

          if ($.isPlainObject(this.options[key])) {
            $.extend(this.options[key], data[key]);
          } else {
            this.options[key] = data[key];
          }
        }

        return this;
      };

      Options.prototype.get = function (key) {
        return this.options[key];
      };

      Options.prototype.set = function (key, val) {
        this.options[key] = val;
      };

      return Options;
    });
    S2.define('select2/core', ['jquery', './options', './utils', './keys'], function ($, Options, Utils, KEYS) {
      var Select2 = function ($element, options) {
        if (Utils.GetData($element[0], 'select2') != null) {
          Utils.GetData($element[0], 'select2').destroy();
        }

        this.$element = $element;
        this.id = this._generateId($element);
        options = options || {};
        this.options = new Options(options, $element);

        Select2.__super__.constructor.call(this); // Set up the tabindex


        var tabindex = $element.attr('tabindex') || 0;
        Utils.StoreData($element[0], 'old-tabindex', tabindex);
        $element.attr('tabindex', '-1'); // Set up containers and adapters

        var DataAdapter = this.options.get('dataAdapter');
        this.dataAdapter = new DataAdapter($element, this.options);
        var $container = this.render();

        this._placeContainer($container);

        var SelectionAdapter = this.options.get('selectionAdapter');
        this.selection = new SelectionAdapter($element, this.options);
        this.$selection = this.selection.render();
        this.selection.position(this.$selection, $container);
        var DropdownAdapter = this.options.get('dropdownAdapter');
        this.dropdown = new DropdownAdapter($element, this.options);
        this.$dropdown = this.dropdown.render();
        this.dropdown.position(this.$dropdown, $container);
        var ResultsAdapter = this.options.get('resultsAdapter');
        this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
        this.$results = this.results.render();
        this.results.position(this.$results, this.$dropdown); // Bind events

        var self = this; // Bind the container to all of the adapters

        this._bindAdapters(); // Register any DOM event handlers


        this._registerDomEvents(); // Register any internal event handlers


        this._registerDataEvents();

        this._registerSelectionEvents();

        this._registerDropdownEvents();

        this._registerResultsEvents();

        this._registerEvents(); // Set the initial state


        this.dataAdapter.current(function (initialData) {
          self.trigger('selection:update', {
            data: initialData
          });
        }); // Hide the original select

        $element[0].classList.add('select2-hidden-accessible');
        $element.attr('aria-hidden', 'true'); // Synchronize any monitored attributes

        this._syncAttributes();

        Utils.StoreData($element[0], 'select2', this); // Ensure backwards compatibility with $element.data('select2').

        $element.data('select2', this);
      };

      Utils.Extend(Select2, Utils.Observable);

      Select2.prototype._generateId = function ($element) {
        var id = '';

        if ($element.attr('id') != null) {
          id = $element.attr('id');
        } else if ($element.attr('name') != null) {
          id = $element.attr('name') + '-' + Utils.generateChars(2);
        } else {
          id = Utils.generateChars(4);
        }

        id = id.replace(/(:|\.|\[|\]|,)/g, '');
        id = 'select2-' + id;
        return id;
      };

      Select2.prototype._placeContainer = function ($container) {
        $container.insertAfter(this.$element);

        var width = this._resolveWidth(this.$element, this.options.get('width'));

        if (width != null) {
          $container.css('width', width);
        }
      };

      Select2.prototype._resolveWidth = function ($element, method) {
        var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

        if (method == 'resolve') {
          var styleWidth = this._resolveWidth($element, 'style');

          if (styleWidth != null) {
            return styleWidth;
          }

          return this._resolveWidth($element, 'element');
        }

        if (method == 'element') {
          var elementWidth = $element.outerWidth(false);

          if (elementWidth <= 0) {
            return 'auto';
          }

          return elementWidth + 'px';
        }

        if (method == 'style') {
          var style = $element.attr('style');

          if (typeof style !== 'string') {
            return null;
          }

          var attrs = style.split(';');

          for (var i = 0, l = attrs.length; i < l; i = i + 1) {
            var attr = attrs[i].replace(/\s/g, '');
            var matches = attr.match(WIDTH);

            if (matches !== null && matches.length >= 1) {
              return matches[1];
            }
          }

          return null;
        }

        if (method == 'computedstyle') {
          var computedStyle = window.getComputedStyle($element[0]);
          return computedStyle.width;
        }

        return method;
      };

      Select2.prototype._bindAdapters = function () {
        this.dataAdapter.bind(this, this.$container);
        this.selection.bind(this, this.$container);
        this.dropdown.bind(this, this.$container);
        this.results.bind(this, this.$container);
      };

      Select2.prototype._registerDomEvents = function () {
        var self = this;
        this.$element.on('change.select2', function () {
          self.dataAdapter.current(function (data) {
            self.trigger('selection:update', {
              data: data
            });
          });
        });
        this.$element.on('focus.select2', function (evt) {
          self.trigger('focus', evt);
        });
        this._syncA = Utils.bind(this._syncAttributes, this);
        this._syncS = Utils.bind(this._syncSubtree, this);
        this._observer = new window.MutationObserver(function (mutations) {
          self._syncA();

          self._syncS(mutations);
        });

        this._observer.observe(this.$element[0], {
          attributes: true,
          childList: true,
          subtree: false
        });
      };

      Select2.prototype._registerDataEvents = function () {
        var self = this;
        this.dataAdapter.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };

      Select2.prototype._registerSelectionEvents = function () {
        var self = this;
        var nonRelayEvents = ['toggle', 'focus'];
        this.selection.on('toggle', function () {
          self.toggleDropdown();
        });
        this.selection.on('focus', function (params) {
          self.focus(params);
        });
        this.selection.on('*', function (name, params) {
          if (nonRelayEvents.indexOf(name) !== -1) {
            return;
          }

          self.trigger(name, params);
        });
      };

      Select2.prototype._registerDropdownEvents = function () {
        var self = this;
        this.dropdown.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };

      Select2.prototype._registerResultsEvents = function () {
        var self = this;
        this.results.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };

      Select2.prototype._registerEvents = function () {
        var self = this;
        this.on('open', function () {
          self.$container[0].classList.add('select2-container--open');
        });
        this.on('close', function () {
          self.$container[0].classList.remove('select2-container--open');
        });
        this.on('enable', function () {
          self.$container[0].classList.remove('select2-container--disabled');
        });
        this.on('disable', function () {
          self.$container[0].classList.add('select2-container--disabled');
        });
        this.on('blur', function () {
          self.$container[0].classList.remove('select2-container--focus');
        });
        this.on('query', function (params) {
          if (!self.isOpen()) {
            self.trigger('open', {});
          }

          this.dataAdapter.query(params, function (data) {
            self.trigger('results:all', {
              data: data,
              query: params
            });
          });
        });
        this.on('query:append', function (params) {
          this.dataAdapter.query(params, function (data) {
            self.trigger('results:append', {
              data: data,
              query: params
            });
          });
        });
        this.on('keypress', function (evt) {
          var key = evt.which;

          if (self.isOpen()) {
            if (key === KEYS.ESC || key === KEYS.UP && evt.altKey) {
              self.close(evt);
              evt.preventDefault();
            } else if (key === KEYS.ENTER || key === KEYS.TAB) {
              self.trigger('results:select', {});
              evt.preventDefault();
            } else if (key === KEYS.SPACE && evt.ctrlKey) {
              self.trigger('results:toggle', {});
              evt.preventDefault();
            } else if (key === KEYS.UP) {
              self.trigger('results:previous', {});
              evt.preventDefault();
            } else if (key === KEYS.DOWN) {
              self.trigger('results:next', {});
              evt.preventDefault();
            }
          } else {
            if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
              self.open();
              evt.preventDefault();
            }
          }
        });
      };

      Select2.prototype._syncAttributes = function () {
        this.options.set('disabled', this.$element.prop('disabled'));

        if (this.isDisabled()) {
          if (this.isOpen()) {
            this.close();
          }

          this.trigger('disable', {});
        } else {
          this.trigger('enable', {});
        }
      };

      Select2.prototype._isChangeMutation = function (mutations) {
        var self = this;

        if (mutations.addedNodes && mutations.addedNodes.length > 0) {
          for (var n = 0; n < mutations.addedNodes.length; n++) {
            var node = mutations.addedNodes[n];

            if (node.selected) {
              return true;
            }
          }
        } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
          return true;
        } else if (Array.isArray(mutations)) {
          return mutations.some(function (mutation) {
            return self._isChangeMutation(mutation);
          });
        }

        return false;
      };

      Select2.prototype._syncSubtree = function (mutations) {
        var changed = this._isChangeMutation(mutations);

        var self = this; // Only re-pull the data if we think there is a change

        if (changed) {
          this.dataAdapter.current(function (currentData) {
            self.trigger('selection:update', {
              data: currentData
            });
          });
        }
      };
      /**
       * Override the trigger method to automatically trigger pre-events when
       * there are events that can be prevented.
       */


      Select2.prototype.trigger = function (name, args) {
        var actualTrigger = Select2.__super__.trigger;
        var preTriggerMap = {
          'open': 'opening',
          'close': 'closing',
          'select': 'selecting',
          'unselect': 'unselecting',
          'clear': 'clearing'
        };

        if (args === undefined) {
          args = {};
        }

        if (name in preTriggerMap) {
          var preTriggerName = preTriggerMap[name];
          var preTriggerArgs = {
            prevented: false,
            name: name,
            args: args
          };
          actualTrigger.call(this, preTriggerName, preTriggerArgs);

          if (preTriggerArgs.prevented) {
            args.prevented = true;
            return;
          }
        }

        actualTrigger.call(this, name, args);
      };

      Select2.prototype.toggleDropdown = function () {
        if (this.isDisabled()) {
          return;
        }

        if (this.isOpen()) {
          this.close();
        } else {
          this.open();
        }
      };

      Select2.prototype.open = function () {
        if (this.isOpen()) {
          return;
        }

        if (this.isDisabled()) {
          return;
        }

        this.trigger('query', {});
      };

      Select2.prototype.close = function (evt) {
        if (!this.isOpen()) {
          return;
        }

        this.trigger('close', {
          originalEvent: evt
        });
      };
      /**
       * Helper method to abstract the "enabled" (not "disabled") state of this
       * object.
       *
       * @return {true} if the instance is not disabled.
       * @return {false} if the instance is disabled.
       */


      Select2.prototype.isEnabled = function () {
        return !this.isDisabled();
      };
      /**
       * Helper method to abstract the "disabled" state of this object.
       *
       * @return {true} if the disabled option is true.
       * @return {false} if the disabled option is false.
       */


      Select2.prototype.isDisabled = function () {
        return this.options.get('disabled');
      };

      Select2.prototype.isOpen = function () {
        return this.$container[0].classList.contains('select2-container--open');
      };

      Select2.prototype.hasFocus = function () {
        return this.$container[0].classList.contains('select2-container--focus');
      };

      Select2.prototype.focus = function (data) {
        // No need to re-trigger focus events if we are already focused
        if (this.hasFocus()) {
          return;
        }

        this.$container[0].classList.add('select2-container--focus');
        this.trigger('focus', {});
      };

      Select2.prototype.enable = function (args) {
        if (this.options.get('debug') && window.console && console.warn) {
          console.warn('Select2: The `select2("enable")` method has been deprecated and will' + ' be removed in later Select2 versions. Use $element.prop("disabled")' + ' instead.');
        }

        if (args == null || args.length === 0) {
          args = [true];
        }

        var disabled = !args[0];
        this.$element.prop('disabled', disabled);
      };

      Select2.prototype.data = function () {
        if (this.options.get('debug') && arguments.length > 0 && window.console && console.warn) {
          console.warn('Select2: Data can no longer be set using `select2("data")`. You ' + 'should consider setting the value instead using `$element.val()`.');
        }

        var data = [];
        this.dataAdapter.current(function (currentData) {
          data = currentData;
        });
        return data;
      };

      Select2.prototype.val = function (args) {
        if (this.options.get('debug') && window.console && console.warn) {
          console.warn('Select2: The `select2("val")` method has been deprecated and will be' + ' removed in later Select2 versions. Use $element.val() instead.');
        }

        if (args == null || args.length === 0) {
          return this.$element.val();
        }

        var newVal = args[0];

        if (Array.isArray(newVal)) {
          newVal = newVal.map(function (obj) {
            return obj.toString();
          });
        }

        this.$element.val(newVal).trigger('input').trigger('change');
      };

      Select2.prototype.destroy = function () {
        Utils.RemoveData(this.$container[0]);
        this.$container.remove();

        this._observer.disconnect();

        this._observer = null;
        this._syncA = null;
        this._syncS = null;
        this.$element.off('.select2');
        this.$element.attr('tabindex', Utils.GetData(this.$element[0], 'old-tabindex'));
        this.$element[0].classList.remove('select2-hidden-accessible');
        this.$element.attr('aria-hidden', 'false');
        Utils.RemoveData(this.$element[0]);
        this.$element.removeData('select2');
        this.dataAdapter.destroy();
        this.selection.destroy();
        this.dropdown.destroy();
        this.results.destroy();
        this.dataAdapter = null;
        this.selection = null;
        this.dropdown = null;
        this.results = null;
      };

      Select2.prototype.render = function () {
        var $container = $('<span class="select2 select2-container">' + '<span class="selection"></span>' + '<span class="dropdown-wrapper" aria-hidden="true"></span>' + '</span>');
        $container.attr('dir', this.options.get('dir'));
        this.$container = $container;
        this.$container[0].classList.add('select2-container--' + this.options.get('theme'));
        Utils.StoreData($container[0], 'element', this.$element);
        return $container;
      };

      return Select2;
    });
    S2.define('jquery-mousewheel', ['jquery'], function ($) {
      // Used to shim jQuery.mousewheel for non-full builds.
      return $;
    });
    S2.define('jquery.select2', ['jquery', 'jquery-mousewheel', './select2/core', './select2/defaults', './select2/utils'], function ($, _, Select2, Defaults, Utils) {
      if ($.fn.select2 == null) {
        // All methods that should return the element
        var thisMethods = ['open', 'close', 'destroy'];

        $.fn.select2 = function (options) {
          options = options || {};

          if (typeof options === 'object') {
            this.each(function () {
              var instanceOptions = $.extend(true, {}, options);
              var instance = new Select2($(this), instanceOptions);
            });
            return this;
          } else if (typeof options === 'string') {
            var ret;
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function () {
              var instance = Utils.GetData(this, 'select2');

              if (instance == null && window.console && console.error) {
                console.error('The select2(\'' + options + '\') method was called on an ' + 'element that is not using Select2.');
              }

              ret = instance[options].apply(instance, args);
            }); // Check if we should be returning `this`

            if (thisMethods.indexOf(options) > -1) {
              return this;
            }

            return ret;
          } else {
            throw new Error('Invalid arguments for Select2: ' + options);
          }
        };
      }

      if ($.fn.select2.defaults == null) {
        $.fn.select2.defaults = Defaults;
      }

      return Select2;
    }); // Return the AMD loader configuration so it can be used outside of this file

    return {
      define: S2.define,
      require: S2.require
    };
  }(); // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe


  var select2 = S2.require('jquery.select2'); // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.


  jQuery.fn.select2.amd = S2; // Return the Select2 instance for anyone who is importing it.

  return select2;
});

/***/ }),

/***/ "./node_modules/subtag/subtag.js":
/*!***************************************!*\
  !*** ./node_modules/subtag/subtag.js ***!
  \***************************************/
/***/ (function(module) {

!function (root, name, make) {
  if ( true && module.exports) module.exports = make();else root[name] = make();
}(this, 'subtag', function () {
  var empty = '';
  var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;

  function match(tag) {
    return tag.match(pattern) || [];
  }

  function split(tag) {
    return match(tag).filter(function (v, i) {
      return v && i;
    });
  }

  function api(tag) {
    tag = match(tag);
    return {
      language: tag[1] || empty,
      extlang: tag[2] || empty,
      script: tag[3] || empty,
      region: tag[4] || empty
    };
  }

  function expose(target, key, value) {
    Object.defineProperty(target, key, {
      value: value,
      enumerable: true
    });
  }

  function part(position, pattern, type) {
    function method(tag) {
      return match(tag)[position] || empty;
    }

    expose(method, 'pattern', pattern);
    expose(api, type, method);
  }

  part(1, /^[a-zA-Z]{2,3}$/, 'language');
  part(2, /^[a-zA-Z]{3}$/, 'extlang');
  part(3, /^[a-zA-Z]{4}$/, 'script');
  part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, 'region');
  expose(api, 'split', split);
  return api;
});

/***/ }),

/***/ "./node_modules/suggestions/index.js":
/*!*******************************************!*\
  !*** ./node_modules/suggestions/index.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/**
 * A typeahead component for inputs
 * @class Suggestions
 *
 * @param {HTMLInputElement} el A valid HTML input element
 * @param {Array} data An array of data used for results
 * @param {Object} options
 * @param {Number} [options.limit=5] Max number of results to display in the auto suggest list.
 * @param {Number} [options.minLength=2] Number of characters typed into an input to trigger suggestions.
 * @param {Boolean} [options.hideOnBlur=true] If `true`, hides the suggestions when focus is lost.
 * @return {Suggestions} `this`
 * @example
 * // in the browser
 * var input = document.querySelector('input');
 * var data = [
 *   'Roy Eldridge',
 *   'Roy Hargrove',
 *   'Rex Stewart'
 * ];
 *
 * new Suggestions(input, data);
 *
 * // with options
 * var input = document.querySelector('input');
 * var data = [{
 *   name: 'Roy Eldridge',
 *   year: 1911
 * }, {
 *   name: 'Roy Hargrove',
 *   year: 1969
 * }, {
 *   name: 'Rex Stewart',
 *   year: 1907
 * }];
 *
 * var typeahead = new Suggestions(input, data, {
 *   filter: false, // Disable filtering
 *   minLength: 3, // Number of characters typed into an input to trigger suggestions.
 *   limit: 3, //  Max number of results to display.
 *   hideOnBlur: false // Don't hide results when input loses focus
 * });
 *
 * // As we're passing an object of an arrays as data, override
 * // `getItemValue` by specifying the specific property to search on.
 * typeahead.getItemValue = function(item) { return item.name };
 *
 * input.addEventListener('change', function() {
 *   console.log(typeahead.selected); // Current selected item.
 * });
 *
 * // With browserify
 * var Suggestions = require('suggestions');
 *
 * new Suggestions(input, data);
 */

var Suggestions = __webpack_require__(/*! ./src/suggestions */ "./node_modules/suggestions/src/suggestions.js");

module.exports = Suggestions;

if (typeof window !== 'undefined') {
  window.Suggestions = Suggestions;
}

/***/ }),

/***/ "./node_modules/suggestions/src/list.js":
/*!**********************************************!*\
  !*** ./node_modules/suggestions/src/list.js ***!
  \**********************************************/
/***/ (function(module) {

"use strict";


var List = function (component) {
  this.component = component;
  this.items = [];
  this.active = 0;
  this.wrapper = document.createElement('div');
  this.wrapper.className = 'suggestions-wrapper';
  this.element = document.createElement('ul');
  this.element.className = 'suggestions';
  this.wrapper.appendChild(this.element); // selectingListItem is set to true in the time between the mousedown and mouseup when clicking an item in the list
  // mousedown on a list item will cause the input to blur which normally hides the list, so this flag is used to keep
  // the list open until the mouseup

  this.selectingListItem = false;
  component.el.parentNode.insertBefore(this.wrapper, component.el.nextSibling);
  return this;
};

List.prototype.show = function () {
  this.element.style.display = 'block';
};

List.prototype.hide = function () {
  this.element.style.display = 'none';
};

List.prototype.add = function (item) {
  this.items.push(item);
};

List.prototype.clear = function () {
  this.items = [];
  this.active = 0;
};

List.prototype.isEmpty = function () {
  return !this.items.length;
};

List.prototype.isVisible = function () {
  return this.element.style.display === 'block';
};

List.prototype.draw = function () {
  this.element.innerHTML = '';

  if (this.items.length === 0) {
    this.hide();
    return;
  }

  for (var i = 0; i < this.items.length; i++) {
    this.drawItem(this.items[i], this.active === i);
  }

  this.show();
};

List.prototype.drawItem = function (item, active) {
  var li = document.createElement('li'),
      a = document.createElement('a');
  if (active) li.className += ' active';
  a.innerHTML = item.string;
  li.appendChild(a);
  this.element.appendChild(li);
  li.addEventListener('mousedown', function () {
    this.selectingListItem = true;
  }.bind(this));
  li.addEventListener('mouseup', function () {
    this.handleMouseUp.call(this, item);
  }.bind(this));
};

List.prototype.handleMouseUp = function (item) {
  this.selectingListItem = false;
  this.component.value(item.original);
  this.clear();
  this.draw();
};

List.prototype.move = function (index) {
  this.active = index;
  this.draw();
};

List.prototype.previous = function () {
  this.move(this.active === 0 ? this.items.length - 1 : this.active - 1);
};

List.prototype.next = function () {
  this.move(this.active === this.items.length - 1 ? 0 : this.active + 1);
};

List.prototype.drawError = function (msg) {
  var li = document.createElement('li');
  li.innerHTML = msg;
  this.element.appendChild(li);
  this.show();
};

module.exports = List;

/***/ }),

/***/ "./node_modules/suggestions/src/suggestions.js":
/*!*****************************************************!*\
  !*** ./node_modules/suggestions/src/suggestions.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var extend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var fuzzy = __webpack_require__(/*! fuzzy */ "./node_modules/fuzzy/lib/fuzzy.js");

var List = __webpack_require__(/*! ./list */ "./node_modules/suggestions/src/list.js");

var Suggestions = function (el, data, options) {
  options = options || {};
  this.options = extend({
    minLength: 2,
    limit: 5,
    filter: true,
    hideOnBlur: true
  }, options);
  this.el = el;
  this.data = data || [];
  this.list = new List(this);
  this.query = '';
  this.selected = null;
  this.list.draw();
  this.el.addEventListener('keyup', function (e) {
    this.handleKeyUp(e.keyCode);
  }.bind(this), false);
  this.el.addEventListener('keydown', function (e) {
    this.handleKeyDown(e);
  }.bind(this));
  this.el.addEventListener('focus', function () {
    this.handleFocus();
  }.bind(this));
  this.el.addEventListener('blur', function () {
    this.handleBlur();
  }.bind(this));
  this.el.addEventListener('paste', function (e) {
    this.handlePaste(e);
  }.bind(this)); // use user-provided render function if given, otherwise just use the default

  this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this);
  this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this);
  return this;
};

Suggestions.prototype.handleKeyUp = function (keyCode) {
  // 40 - DOWN
  // 38 - UP
  // 27 - ESC
  // 13 - ENTER
  // 9 - TAB
  if (keyCode === 40 || keyCode === 38 || keyCode === 27 || keyCode === 13 || keyCode === 9) return;
  this.handleInputChange(this.el.value);
};

Suggestions.prototype.handleKeyDown = function (e) {
  switch (e.keyCode) {
    case 13: // ENTER

    case 9:
      // TAB
      if (!this.list.isEmpty()) {
        if (this.list.isVisible()) {
          e.preventDefault();
        }

        this.value(this.list.items[this.list.active].original);
        this.list.hide();
      }

      break;

    case 27:
      // ESC
      if (!this.list.isEmpty()) this.list.hide();
      break;

    case 38:
      // UP
      this.list.previous();
      break;

    case 40:
      // DOWN
      this.list.next();
      break;
  }
};

Suggestions.prototype.handleBlur = function () {
  if (!this.list.selectingListItem && this.options.hideOnBlur) {
    this.list.hide();
  }
};

Suggestions.prototype.handlePaste = function (e) {
  if (e.clipboardData) {
    this.handleInputChange(e.clipboardData.getData('Text'));
  } else {
    var self = this;
    setTimeout(function () {
      self.handleInputChange(e.target.value);
    }, 100);
  }
};

Suggestions.prototype.handleInputChange = function (query) {
  this.query = this.normalize(query);
  this.list.clear();

  if (this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }

  this.getCandidates(function (data) {
    for (var i = 0; i < data.length; i++) {
      this.list.add(data[i]);
      if (i === this.options.limit - 1) break;
    }

    this.list.draw();
  }.bind(this));
};

Suggestions.prototype.handleFocus = function () {
  if (!this.list.isEmpty()) this.list.show();
  this.list.selectingListItem = false;
};
/**
 * Update data previously passed
 *
 * @param {Array} revisedData
 */


Suggestions.prototype.update = function (revisedData) {
  this.data = revisedData;
  this.handleKeyUp();
};
/**
 * Clears data
 */


Suggestions.prototype.clear = function () {
  this.data = [];
  this.list.clear();
};
/**
 * Normalize the results list and input value for matching
 *
 * @param {String} value
 * @return {String}
 */


Suggestions.prototype.normalize = function (value) {
  value = value.toLowerCase();
  return value;
};
/**
 * Evaluates whether an array item qualifies as a match with the current query
 *
 * @param {String} candidate a possible item from the array passed
 * @param {String} query the current query
 * @return {Boolean}
 */


Suggestions.prototype.match = function (candidate, query) {
  return candidate.indexOf(query) > -1;
};

Suggestions.prototype.value = function (value) {
  this.selected = value;
  this.el.value = this.getItemValue(value);

  if (document.createEvent) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent('change', true, false);
    this.el.dispatchEvent(e);
  } else {
    this.el.fireEvent('onchange');
  }
};

Suggestions.prototype.getCandidates = function (callback) {
  var options = {
    pre: '<strong>',
    post: '</strong>',
    extract: function (d) {
      return this.getItemValue(d);
    }.bind(this)
  };
  var results;

  if (this.options.filter) {
    results = fuzzy.filter(this.query, this.data, options);
    results = results.map(function (item) {
      return {
        original: item.original,
        string: this.render(item.original, item.string)
      };
    }.bind(this));
  } else {
    results = this.data.map(function (d) {
      var renderedString = this.render(d);
      return {
        original: d,
        string: renderedString
      };
    }.bind(this));
  }

  callback(results);
};
/**
 * For a given item in the data array, return what should be used as the candidate string
 *
 * @param {Object|String} item an item from the data array
 * @return {String} item
 */


Suggestions.prototype.getItemValue = function (item) {
  return item;
};
/**
 * For a given item in the data array, return a string of html that should be rendered in the dropdown
 * @param {Object|String} item an item from the data array
 * @param {String} sourceFormatting a string that has pre-formatted html that should be passed directly through the render function 
 * @return {String} html
 */


Suggestions.prototype.render = function (item, sourceFormatting) {
  if (sourceFormatting) {
    // use existing formatting on the source string
    return sourceFormatting;
  }

  var boldString = item.original ? this.getItemValue(item.original) : this.getItemValue(item);
  var indexString = this.normalize(boldString);
  var indexOfQuery = indexString.lastIndexOf(this.query);

  while (indexOfQuery > -1) {
    var endIndexOfQuery = indexOfQuery + this.query.length;
    boldString = boldString.slice(0, indexOfQuery) + '<strong>' + boldString.slice(indexOfQuery, endIndexOfQuery) + '</strong>' + boldString.slice(endIndexOfQuery);
    indexOfQuery = indexString.slice(0, indexOfQuery).lastIndexOf(this.query);
  }

  return boldString;
};
/**
 * Render an custom error message in the suggestions list
 * @param {String} msg An html string to render as an error message
 */


Suggestions.prototype.renderError = function (msg) {
  this.list.drawError(msg);
};

module.exports = Suggestions;

/***/ }),

/***/ "./node_modules/turf-jsts/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/turf-jsts/jsts.min.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

!function (t, e) {
   true ? e(exports) : 0;
}(this, function (t) {
  "use strict";

  function e() {}

  function n(t) {
    this.message = t || "";
  }

  function i(t) {
    this.message = t || "";
  }

  function r(t) {
    this.message = t || "";
  }

  function o() {}

  function s(t) {
    return null === t ? Mt : t.color;
  }

  function a(t) {
    return null === t ? null : t.parent;
  }

  function u(t, e) {
    null !== t && (t.color = e);
  }

  function l(t) {
    return null === t ? null : t.left;
  }

  function c(t) {
    return null === t ? null : t.right;
  }

  function p() {
    this.root_ = null, this.size_ = 0;
  }

  function h() {}

  function f() {
    this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
  }

  function g() {}

  function d(t) {
    this.message = t || "";
  }

  function y() {
    this.array_ = [];
  }

  "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
    configurable: !0,
    value: function (t) {
      if (void 0 === this || null === this) throw new TypeError(this + " is not an object");
      var e = Object(this),
          n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,
          i = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
      i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);
      var r = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;

      for (r = r < 0 ? Math.max(n + arguments[2], 0) : Math.min(r, n); i < r;) e[i] = t, ++i;

      return e;
    },
    writable: !0
  }), Number.isFinite = Number.isFinite || function (t) {
    return "number" == typeof t && isFinite(t);
  }, Number.isInteger = Number.isInteger || function (t) {
    return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
  }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) {
    return t != t;
  }, Math.trunc = Math.trunc || function (t) {
    return t < 0 ? Math.ceil(t) : Math.floor(t);
  };

  var _ = function () {};

  _.prototype.interfaces_ = function () {
    return [];
  }, _.prototype.getClass = function () {
    return _;
  }, _.prototype.equalsWithTolerance = function (t, e, n) {
    return Math.abs(t - e) <= n;
  };

  var m = function (t) {
    function e(e) {
      t.call(this, e), this.name = "IllegalArgumentException", this.message = e, this.stack = new t().stack;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
  }(Error),
      v = function () {},
      I = {
    MAX_VALUE: {
      configurable: !0
    }
  };

  v.isNaN = function (t) {
    return Number.isNaN(t);
  }, v.doubleToLongBits = function (t) {
    return t;
  }, v.longBitsToDouble = function (t) {
    return t;
  }, v.isInfinite = function (t) {
    return !Number.isFinite(t);
  }, I.MAX_VALUE.get = function () {
    return Number.MAX_VALUE;
  }, Object.defineProperties(v, I);

  var E = function () {},
      x = function () {},
      N = function () {},
      C = function t() {
    if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) this.x = 0, this.y = 0, this.z = t.NULL_ORDINATE;else if (1 === arguments.length) {
      var e = arguments[0];
      this.x = e.x, this.y = e.y, this.z = e.z;
    } else 2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
  },
      S = {
    DimensionalComparator: {
      configurable: !0
    },
    serialVersionUID: {
      configurable: !0
    },
    NULL_ORDINATE: {
      configurable: !0
    },
    X: {
      configurable: !0
    },
    Y: {
      configurable: !0
    },
    Z: {
      configurable: !0
    }
  };

  C.prototype.setOrdinate = function (t, e) {
    switch (t) {
      case C.X:
        this.x = e;
        break;

      case C.Y:
        this.y = e;
        break;

      case C.Z:
        this.z = e;
        break;

      default:
        throw new m("Invalid ordinate index: " + t);
    }
  }, C.prototype.equals2D = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.x === t.x && this.y === t.y;
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return !!_.equalsWithTolerance(this.x, e.x, n) && !!_.equalsWithTolerance(this.y, e.y, n);
    }
  }, C.prototype.getOrdinate = function (t) {
    switch (t) {
      case C.X:
        return this.x;

      case C.Y:
        return this.y;

      case C.Z:
        return this.z;
    }

    throw new m("Invalid ordinate index: " + t);
  }, C.prototype.equals3D = function (t) {
    return this.x === t.x && this.y === t.y && (this.z === t.z || v.isNaN(this.z)) && v.isNaN(t.z);
  }, C.prototype.equals = function (t) {
    return t instanceof C && this.equals2D(t);
  }, C.prototype.equalInZ = function (t, e) {
    return _.equalsWithTolerance(this.z, t.z, e);
  }, C.prototype.compareTo = function (t) {
    var e = t;
    return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;
  }, C.prototype.clone = function () {}, C.prototype.copy = function () {
    return new C(this);
  }, C.prototype.toString = function () {
    return "(" + this.x + ", " + this.y + ", " + this.z + ")";
  }, C.prototype.distance3D = function (t) {
    var e = this.x - t.x,
        n = this.y - t.y,
        i = this.z - t.z;
    return Math.sqrt(e * e + n * n + i * i);
  }, C.prototype.distance = function (t) {
    var e = this.x - t.x,
        n = this.y - t.y;
    return Math.sqrt(e * e + n * n);
  }, C.prototype.hashCode = function () {
    var t = 17;
    return t = 37 * t + C.hashCode(this.x), t = 37 * t + C.hashCode(this.y);
  }, C.prototype.setCoordinate = function (t) {
    this.x = t.x, this.y = t.y, this.z = t.z;
  }, C.prototype.interfaces_ = function () {
    return [E, x, e];
  }, C.prototype.getClass = function () {
    return C;
  }, C.hashCode = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = v.doubleToLongBits(t);
      return Math.trunc((e ^ e) >>> 32);
    }
  }, S.DimensionalComparator.get = function () {
    return L;
  }, S.serialVersionUID.get = function () {
    return 0x5cbf2c235c7e5800;
  }, S.NULL_ORDINATE.get = function () {
    return v.NaN;
  }, S.X.get = function () {
    return 0;
  }, S.Y.get = function () {
    return 1;
  }, S.Z.get = function () {
    return 2;
  }, Object.defineProperties(C, S);

  var L = function (t) {
    if (this._dimensionsToTest = 2, 0 === arguments.length) ;else if (1 === arguments.length) {
      var e = arguments[0];
      if (2 !== e && 3 !== e) throw new m("only 2 or 3 dimensions may be specified");
      this._dimensionsToTest = e;
    }
  };

  L.prototype.compare = function (t, e) {
    var n = t,
        i = e,
        r = L.compare(n.x, i.x);
    if (0 !== r) return r;
    var o = L.compare(n.y, i.y);
    if (0 !== o) return o;
    if (this._dimensionsToTest <= 2) return 0;
    return L.compare(n.z, i.z);
  }, L.prototype.interfaces_ = function () {
    return [N];
  }, L.prototype.getClass = function () {
    return L;
  }, L.compare = function (t, e) {
    return t < e ? -1 : t > e ? 1 : v.isNaN(t) ? v.isNaN(e) ? 0 : -1 : v.isNaN(e) ? 1 : 0;
  };

  var b = function () {};

  b.prototype.create = function () {}, b.prototype.interfaces_ = function () {
    return [];
  }, b.prototype.getClass = function () {
    return b;
  };

  var w = function () {},
      O = {
    INTERIOR: {
      configurable: !0
    },
    BOUNDARY: {
      configurable: !0
    },
    EXTERIOR: {
      configurable: !0
    },
    NONE: {
      configurable: !0
    }
  };

  w.prototype.interfaces_ = function () {
    return [];
  }, w.prototype.getClass = function () {
    return w;
  }, w.toLocationSymbol = function (t) {
    switch (t) {
      case w.EXTERIOR:
        return "e";

      case w.BOUNDARY:
        return "b";

      case w.INTERIOR:
        return "i";

      case w.NONE:
        return "-";
    }

    throw new m("Unknown location value: " + t);
  }, O.INTERIOR.get = function () {
    return 0;
  }, O.BOUNDARY.get = function () {
    return 1;
  }, O.EXTERIOR.get = function () {
    return 2;
  }, O.NONE.get = function () {
    return -1;
  }, Object.defineProperties(w, O);

  var T = function (t, e) {
    return t.interfaces_ && t.interfaces_().indexOf(e) > -1;
  },
      R = function () {},
      P = {
    LOG_10: {
      configurable: !0
    }
  };

  R.prototype.interfaces_ = function () {
    return [];
  }, R.prototype.getClass = function () {
    return R;
  }, R.log10 = function (t) {
    var e = Math.log(t);
    return v.isInfinite(e) ? e : v.isNaN(e) ? e : e / R.LOG_10;
  }, R.min = function (t, e, n, i) {
    var r = t;
    return e < r && (r = e), n < r && (r = n), i < r && (r = i), r;
  }, R.clamp = function () {
    if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2];
      return t < e ? e : t > n ? n : t;
    }

    if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2];
      return i < r ? r : i > o ? o : i;
    }
  }, R.wrap = function (t, e) {
    return t < 0 ? e - -t % e : t % e;
  }, R.max = function () {
    if (3 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = t;
      return e > i && (i = e), n > i && (i = n), i;
    }

    if (4 === arguments.length) {
      var r = arguments[0],
          o = arguments[1],
          s = arguments[2],
          a = arguments[3],
          u = r;
      return o > u && (u = o), s > u && (u = s), a > u && (u = a), u;
    }
  }, R.average = function (t, e) {
    return (t + e) / 2;
  }, P.LOG_10.get = function () {
    return Math.log(10);
  }, Object.defineProperties(R, P);

  var D = function (t) {
    this.str = t;
  };

  D.prototype.append = function (t) {
    this.str += t;
  }, D.prototype.setCharAt = function (t, e) {
    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
  }, D.prototype.toString = function (t) {
    return this.str;
  };

  var M = function (t) {
    this.value = t;
  };

  M.prototype.intValue = function () {
    return this.value;
  }, M.prototype.compareTo = function (t) {
    return this.value < t ? -1 : this.value > t ? 1 : 0;
  }, M.isNaN = function (t) {
    return Number.isNaN(t);
  };

  var A = function () {};

  A.isWhitespace = function (t) {
    return t <= 32 && t >= 0 || 127 === t;
  }, A.toUpperCase = function (t) {
    return t.toUpperCase();
  };

  var F = function t() {
    if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {
      if ("number" == typeof arguments[0]) {
        var e = arguments[0];
        this.init(e);
      } else if (arguments[0] instanceof t) {
        var n = arguments[0];
        this.init(n);
      } else if ("string" == typeof arguments[0]) {
        var i = arguments[0];
        t.call(this, t.parse(i));
      }
    } else if (2 === arguments.length) {
      var r = arguments[0],
          o = arguments[1];
      this.init(r, o);
    }
  },
      G = {
    PI: {
      configurable: !0
    },
    TWO_PI: {
      configurable: !0
    },
    PI_2: {
      configurable: !0
    },
    E: {
      configurable: !0
    },
    NaN: {
      configurable: !0
    },
    EPS: {
      configurable: !0
    },
    SPLIT: {
      configurable: !0
    },
    MAX_PRINT_DIGITS: {
      configurable: !0
    },
    TEN: {
      configurable: !0
    },
    ONE: {
      configurable: !0
    },
    SCI_NOT_EXPONENT_CHAR: {
      configurable: !0
    },
    SCI_NOT_ZERO: {
      configurable: !0
    }
  };

  F.prototype.le = function (t) {
    return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo;
  }, F.prototype.extractSignificantDigits = function (t, e) {
    var n = this.abs(),
        i = F.magnitude(n._hi),
        r = F.TEN.pow(i);
    (n = n.divide(r)).gt(F.TEN) ? (n = n.divide(F.TEN), i += 1) : n.lt(F.ONE) && (n = n.multiply(F.TEN), i -= 1);

    for (var o = i + 1, s = new D(), a = F.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {
      t && u === o && s.append(".");
      var l = Math.trunc(n._hi);
      if (l < 0) break;
      var c = !1,
          p = 0;
      l > 9 ? (c = !0, p = "9") : p = "0" + l, s.append(p), n = n.subtract(F.valueOf(l)).multiply(F.TEN), c && n.selfAdd(F.TEN);
      var h = !0,
          f = F.magnitude(n._hi);
      if (f < 0 && Math.abs(f) >= a - u && (h = !1), !h) break;
    }

    return e[0] = i, s.toString();
  }, F.prototype.sqr = function () {
    return this.multiply(this);
  }, F.prototype.doubleValue = function () {
    return this._hi + this._lo;
  }, F.prototype.subtract = function () {
    if (arguments[0] instanceof F) {
      var t = arguments[0];
      return this.add(t.negate());
    }

    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return this.add(-e);
    }
  }, F.prototype.equals = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this._hi === t._hi && this._lo === t._lo;
    }
  }, F.prototype.isZero = function () {
    return 0 === this._hi && 0 === this._lo;
  }, F.prototype.selfSubtract = function () {
    if (arguments[0] instanceof F) {
      var t = arguments[0];
      return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo);
    }

    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return this.isNaN() ? this : this.selfAdd(-e, 0);
    }
  }, F.prototype.getSpecialNumberString = function () {
    return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
  }, F.prototype.min = function (t) {
    return this.le(t) ? this : t;
  }, F.prototype.selfDivide = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof F) {
        var t = arguments[0];
        return this.selfDivide(t._hi, t._lo);
      }

      if ("number" == typeof arguments[0]) {
        var e = arguments[0];
        return this.selfDivide(e, 0);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = null,
          o = null,
          s = null,
          a = null,
          u = null,
          l = null,
          c = null,
          p = null;
      return u = this._hi / n, l = F.SPLIT * u, r = l - u, p = F.SPLIT * n, r = l - r, o = u - r, s = p - n, c = u * n, s = p - s, a = n - s, p = r * s - c + r * a + o * s + o * a, l = (this._hi - c - p + this._lo - u * i) / n, p = u + l, this._hi = p, this._lo = u - p + l, this;
    }
  }, F.prototype.dump = function () {
    return "DD<" + this._hi + ", " + this._lo + ">";
  }, F.prototype.divide = function () {
    if (arguments[0] instanceof F) {
      var t = arguments[0],
          e = null,
          n = null,
          i = null,
          r = null,
          o = null,
          s = null,
          a = null,
          u = null;
      n = (o = this._hi / t._hi) - (e = (s = F.SPLIT * o) - (e = s - o)), u = e * (i = (u = F.SPLIT * t._hi) - (i = u - t._hi)) - (a = o * t._hi) + e * (r = t._hi - i) + n * i + n * r, s = (this._hi - a - u + this._lo - o * t._lo) / t._hi;
      return new F(u = o + s, o - u + s);
    }

    if ("number" == typeof arguments[0]) {
      var l = arguments[0];
      return v.isNaN(l) ? F.createNaN() : F.copy(this).selfDivide(l, 0);
    }
  }, F.prototype.ge = function (t) {
    return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo;
  }, F.prototype.pow = function (t) {
    if (0 === t) return F.valueOf(1);
    var e = new F(this),
        n = F.valueOf(1),
        i = Math.abs(t);
    if (i > 1) for (; i > 0;) i % 2 == 1 && n.selfMultiply(e), (i /= 2) > 0 && (e = e.sqr());else n = e;
    return t < 0 ? n.reciprocal() : n;
  }, F.prototype.ceil = function () {
    if (this.isNaN()) return F.NaN;
    var t = Math.ceil(this._hi),
        e = 0;
    return t === this._hi && (e = Math.ceil(this._lo)), new F(t, e);
  }, F.prototype.compareTo = function (t) {
    var e = t;
    return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0;
  }, F.prototype.rint = function () {
    if (this.isNaN()) return this;
    return this.add(.5).floor();
  }, F.prototype.setValue = function () {
    if (arguments[0] instanceof F) {
      var t = arguments[0];
      return this.init(t), this;
    }

    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return this.init(e), this;
    }
  }, F.prototype.max = function (t) {
    return this.ge(t) ? this : t;
  }, F.prototype.sqrt = function () {
    if (this.isZero()) return F.valueOf(0);
    if (this.isNegative()) return F.NaN;
    var t = 1 / Math.sqrt(this._hi),
        e = this._hi * t,
        n = F.valueOf(e),
        i = this.subtract(n.sqr())._hi * (.5 * t);
    return n.add(i);
  }, F.prototype.selfAdd = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof F) {
        var t = arguments[0];
        return this.selfAdd(t._hi, t._lo);
      }

      if ("number" == typeof arguments[0]) {
        var e = arguments[0],
            n = null,
            i = null,
            r = null,
            o = null,
            s = null,
            a = null;
        return r = this._hi + e, s = r - this._hi, o = r - s, o = e - s + (this._hi - o), a = o + this._lo, n = r + a, i = a + (r - n), this._hi = n + i, this._lo = i + (n - this._hi), this;
      }
    } else if (2 === arguments.length) {
      var u = arguments[0],
          l = arguments[1],
          c = null,
          p = null,
          h = null,
          f = null,
          g = null,
          d = null,
          y = null;
      f = this._hi + u, p = this._lo + l, g = f - (d = f - this._hi), h = p - (y = p - this._lo);

      var _ = (c = f + (d = (g = u - d + (this._hi - g)) + p)) + (d = (h = l - y + (this._lo - h)) + (d + (f - c))),
          m = d + (c - _);

      return this._hi = _, this._lo = m, this;
    }
  }, F.prototype.selfMultiply = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof F) {
        var t = arguments[0];
        return this.selfMultiply(t._hi, t._lo);
      }

      if ("number" == typeof arguments[0]) {
        var e = arguments[0];
        return this.selfMultiply(e, 0);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = null,
          o = null,
          s = null,
          a = null,
          u = null,
          l = null;
      r = (u = F.SPLIT * this._hi) - this._hi, l = F.SPLIT * n, r = u - r, o = this._hi - r, s = l - n;
      var c = (u = this._hi * n) + (l = r * (s = l - s) - u + r * (a = n - s) + o * s + o * a + (this._hi * i + this._lo * n)),
          p = l + (r = u - c);
      return this._hi = c, this._lo = p, this;
    }
  }, F.prototype.selfSqr = function () {
    return this.selfMultiply(this);
  }, F.prototype.floor = function () {
    if (this.isNaN()) return F.NaN;
    var t = Math.floor(this._hi),
        e = 0;
    return t === this._hi && (e = Math.floor(this._lo)), new F(t, e);
  }, F.prototype.negate = function () {
    return this.isNaN() ? this : new F(-this._hi, -this._lo);
  }, F.prototype.clone = function () {}, F.prototype.multiply = function () {
    if (arguments[0] instanceof F) {
      var t = arguments[0];
      return t.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t);
    }

    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return v.isNaN(e) ? F.createNaN() : F.copy(this).selfMultiply(e, 0);
    }
  }, F.prototype.isNaN = function () {
    return v.isNaN(this._hi);
  }, F.prototype.intValue = function () {
    return Math.trunc(this._hi);
  }, F.prototype.toString = function () {
    var t = F.magnitude(this._hi);
    return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();
  }, F.prototype.toStandardNotation = function () {
    var t = this.getSpecialNumberString();
    if (null !== t) return t;
    var e = new Array(1).fill(null),
        n = this.extractSignificantDigits(!0, e),
        i = e[0] + 1,
        r = n;
    if ("." === n.charAt(0)) r = "0" + n;else if (i < 0) r = "0." + F.stringOfChar("0", -i) + n;else if (-1 === n.indexOf(".")) {
      var o = i - n.length;
      r = n + F.stringOfChar("0", o) + ".0";
    }
    return this.isNegative() ? "-" + r : r;
  }, F.prototype.reciprocal = function () {
    var t = null,
        e = null,
        n = null,
        i = null,
        r = null,
        o = null,
        s = null,
        a = null;
    e = (r = 1 / this._hi) - (t = (o = F.SPLIT * r) - (t = o - r)), n = (a = F.SPLIT * this._hi) - this._hi;
    var u = r + (o = (1 - (s = r * this._hi) - (a = t * (n = a - n) - s + t * (i = this._hi - n) + e * n + e * i) - r * this._lo) / this._hi);
    return new F(u, r - u + o);
  }, F.prototype.toSciNotation = function () {
    if (this.isZero()) return F.SCI_NOT_ZERO;
    var t = this.getSpecialNumberString();
    if (null !== t) return t;
    var e = new Array(1).fill(null),
        n = this.extractSignificantDigits(!1, e),
        i = F.SCI_NOT_EXPONENT_CHAR + e[0];
    if ("0" === n.charAt(0)) throw new Error("Found leading zero: " + n);
    var r = "";
    n.length > 1 && (r = n.substring(1));
    var o = n.charAt(0) + "." + r;
    return this.isNegative() ? "-" + o + i : o + i;
  }, F.prototype.abs = function () {
    return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);
  }, F.prototype.isPositive = function () {
    return (this._hi > 0 || 0 === this._hi) && this._lo > 0;
  }, F.prototype.lt = function (t) {
    return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo;
  }, F.prototype.add = function () {
    if (arguments[0] instanceof F) {
      var t = arguments[0];
      return F.copy(this).selfAdd(t);
    }

    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return F.copy(this).selfAdd(e);
    }
  }, F.prototype.init = function () {
    if (1 === arguments.length) {
      if ("number" == typeof arguments[0]) {
        var t = arguments[0];
        this._hi = t, this._lo = 0;
      } else if (arguments[0] instanceof F) {
        var e = arguments[0];
        this._hi = e._hi, this._lo = e._lo;
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      this._hi = n, this._lo = i;
    }
  }, F.prototype.gt = function (t) {
    return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo;
  }, F.prototype.isNegative = function () {
    return (this._hi < 0 || 0 === this._hi) && this._lo < 0;
  }, F.prototype.trunc = function () {
    return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();
  }, F.prototype.signum = function () {
    return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
  }, F.prototype.interfaces_ = function () {
    return [e, E, x];
  }, F.prototype.getClass = function () {
    return F;
  }, F.sqr = function (t) {
    return F.valueOf(t).selfMultiply(t);
  }, F.valueOf = function () {
    if ("string" == typeof arguments[0]) {
      var t = arguments[0];
      return F.parse(t);
    }

    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return new F(e);
    }
  }, F.sqrt = function (t) {
    return F.valueOf(t).sqrt();
  }, F.parse = function (t) {
    for (var e = 0, n = t.length; A.isWhitespace(t.charAt(e));) e++;

    var i = !1;

    if (e < n) {
      var r = t.charAt(e);
      "-" !== r && "+" !== r || (e++, "-" === r && (i = !0));
    }

    for (var o = new F(), s = 0, a = 0, u = 0; !(e >= n);) {
      var l = t.charAt(e);

      if (e++, A.isDigit(l)) {
        var c = l - "0";
        o.selfMultiply(F.TEN), o.selfAdd(c), s++;
      } else {
        if ("." !== l) {
          if ("e" === l || "E" === l) {
            var p = t.substring(e);

            try {
              u = M.parseInt(p);
            } catch (e) {
              throw e instanceof Error ? new Error("Invalid exponent " + p + " in string " + t) : e;
            }

            break;
          }

          throw new Error("Unexpected character '" + l + "' at position " + e + " in string " + t);
        }

        a = s;
      }
    }

    var h = o,
        f = s - a - u;
    if (0 === f) h = o;else if (f > 0) {
      var g = F.TEN.pow(f);
      h = o.divide(g);
    } else if (f < 0) {
      var d = F.TEN.pow(-f);
      h = o.multiply(d);
    }
    return i ? h.negate() : h;
  }, F.createNaN = function () {
    return new F(v.NaN, v.NaN);
  }, F.copy = function (t) {
    return new F(t);
  }, F.magnitude = function (t) {
    var e = Math.abs(t),
        n = Math.log(e) / Math.log(10),
        i = Math.trunc(Math.floor(n));
    return 10 * Math.pow(10, i) <= e && (i += 1), i;
  }, F.stringOfChar = function (t, e) {
    for (var n = new D(), i = 0; i < e; i++) n.append(t);

    return n.toString();
  }, G.PI.get = function () {
    return new F(3.141592653589793, 1.2246467991473532e-16);
  }, G.TWO_PI.get = function () {
    return new F(6.283185307179586, 2.4492935982947064e-16);
  }, G.PI_2.get = function () {
    return new F(1.5707963267948966, 6.123233995736766e-17);
  }, G.E.get = function () {
    return new F(2.718281828459045, 1.4456468917292502e-16);
  }, G.NaN.get = function () {
    return new F(v.NaN, v.NaN);
  }, G.EPS.get = function () {
    return 1.23259516440783e-32;
  }, G.SPLIT.get = function () {
    return 134217729;
  }, G.MAX_PRINT_DIGITS.get = function () {
    return 32;
  }, G.TEN.get = function () {
    return F.valueOf(10);
  }, G.ONE.get = function () {
    return F.valueOf(1);
  }, G.SCI_NOT_EXPONENT_CHAR.get = function () {
    return "E";
  }, G.SCI_NOT_ZERO.get = function () {
    return "0.0E0";
  }, Object.defineProperties(F, G);

  var q = function () {},
      B = {
    DP_SAFE_EPSILON: {
      configurable: !0
    }
  };

  q.prototype.interfaces_ = function () {
    return [];
  }, q.prototype.getClass = function () {
    return q;
  }, q.orientationIndex = function (t, e, n) {
    var i = q.orientationIndexFilter(t, e, n);
    if (i <= 1) return i;
    var r = F.valueOf(e.x).selfAdd(-t.x),
        o = F.valueOf(e.y).selfAdd(-t.y),
        s = F.valueOf(n.x).selfAdd(-e.x),
        a = F.valueOf(n.y).selfAdd(-e.y);
    return r.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum();
  }, q.signOfDet2x2 = function (t, e, n, i) {
    return t.multiply(i).selfSubtract(e.multiply(n)).signum();
  }, q.intersection = function (t, e, n, i) {
    var r = F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(e.x).selfSubtract(t.x)),
        o = F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(e.y).selfSubtract(t.y)),
        s = r.subtract(o),
        a = F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),
        u = F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),
        l = a.subtract(u).selfDivide(s).doubleValue(),
        c = F.valueOf(t.x).selfAdd(F.valueOf(e.x).selfSubtract(t.x).selfMultiply(l)).doubleValue(),
        p = F.valueOf(e.x).selfSubtract(t.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),
        h = F.valueOf(e.y).selfSubtract(t.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),
        f = p.subtract(h).selfDivide(s).doubleValue(),
        g = F.valueOf(n.y).selfAdd(F.valueOf(i.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();
    return new C(c, g);
  }, q.orientationIndexFilter = function (t, e, n) {
    var i = null,
        r = (t.x - n.x) * (e.y - n.y),
        o = (t.y - n.y) * (e.x - n.x),
        s = r - o;

    if (r > 0) {
      if (o <= 0) return q.signum(s);
      i = r + o;
    } else {
      if (!(r < 0)) return q.signum(s);
      if (o >= 0) return q.signum(s);
      i = -r - o;
    }

    var a = q.DP_SAFE_EPSILON * i;
    return s >= a || -s >= a ? q.signum(s) : 2;
  }, q.signum = function (t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }, B.DP_SAFE_EPSILON.get = function () {
    return 1e-15;
  }, Object.defineProperties(q, B);

  var V = function () {},
      U = {
    X: {
      configurable: !0
    },
    Y: {
      configurable: !0
    },
    Z: {
      configurable: !0
    },
    M: {
      configurable: !0
    }
  };

  U.X.get = function () {
    return 0;
  }, U.Y.get = function () {
    return 1;
  }, U.Z.get = function () {
    return 2;
  }, U.M.get = function () {
    return 3;
  }, V.prototype.setOrdinate = function (t, e, n) {}, V.prototype.size = function () {}, V.prototype.getOrdinate = function (t, e) {}, V.prototype.getCoordinate = function () {}, V.prototype.getCoordinateCopy = function (t) {}, V.prototype.getDimension = function () {}, V.prototype.getX = function (t) {}, V.prototype.clone = function () {}, V.prototype.expandEnvelope = function (t) {}, V.prototype.copy = function () {}, V.prototype.getY = function (t) {}, V.prototype.toCoordinateArray = function () {}, V.prototype.interfaces_ = function () {
    return [x];
  }, V.prototype.getClass = function () {
    return V;
  }, Object.defineProperties(V, U);

  var z = function () {},
      X = function (t) {
    function e() {
      t.call(this, "Projective point not representable on the Cartesian plane.");
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(z),
      Y = function () {};

  Y.arraycopy = function (t, e, n, i, r) {
    for (var o = 0, s = e; s < e + r; s++) n[i + o] = t[s], o++;
  }, Y.getProperty = function (t) {
    return {
      "line.separator": "\n"
    }[t];
  };

  var k = function t() {
    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {
      var e = arguments[0];
      this.x = e.x, this.y = e.y, this.w = 1;
    } else if (2 === arguments.length) {
      if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
        var n = arguments[0],
            i = arguments[1];
        this.x = n, this.y = i, this.w = 1;
      } else if (arguments[0] instanceof t && arguments[1] instanceof t) {
        var r = arguments[0],
            o = arguments[1];
        this.x = r.y * o.w - o.y * r.w, this.y = o.x * r.w - r.x * o.w, this.w = r.x * o.y - o.x * r.y;
      } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
        var s = arguments[0],
            a = arguments[1];
        this.x = s.y - a.y, this.y = a.x - s.x, this.w = s.x * a.y - a.x * s.y;
      }
    } else if (3 === arguments.length) {
      var u = arguments[0],
          l = arguments[1],
          c = arguments[2];
      this.x = u, this.y = l, this.w = c;
    } else if (4 === arguments.length) {
      var p = arguments[0],
          h = arguments[1],
          f = arguments[2],
          g = arguments[3],
          d = p.y - h.y,
          y = h.x - p.x,
          _ = p.x * h.y - h.x * p.y,
          m = f.y - g.y,
          v = g.x - f.x,
          I = f.x * g.y - g.x * f.y;

      this.x = y * I - v * _, this.y = m * _ - d * I, this.w = d * v - m * y;
    }
  };

  k.prototype.getY = function () {
    var t = this.y / this.w;
    if (v.isNaN(t) || v.isInfinite(t)) throw new X();
    return t;
  }, k.prototype.getX = function () {
    var t = this.x / this.w;
    if (v.isNaN(t) || v.isInfinite(t)) throw new X();
    return t;
  }, k.prototype.getCoordinate = function () {
    var t = new C();
    return t.x = this.getX(), t.y = this.getY(), t;
  }, k.prototype.interfaces_ = function () {
    return [];
  }, k.prototype.getClass = function () {
    return k;
  }, k.intersection = function (t, e, n, i) {
    var r = t.y - e.y,
        o = e.x - t.x,
        s = t.x * e.y - e.x * t.y,
        a = n.y - i.y,
        u = i.x - n.x,
        l = n.x * i.y - i.x * n.y,
        c = r * u - a * o,
        p = (o * l - u * s) / c,
        h = (a * s - r * l) / c;
    if (v.isNaN(p) || v.isInfinite(p) || v.isNaN(h) || v.isInfinite(h)) throw new X();
    return new C(p, h);
  };

  var j = function t() {
    if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {
      if (arguments[0] instanceof C) {
        var e = arguments[0];
        this.init(e.x, e.x, e.y, e.y);
      } else if (arguments[0] instanceof t) {
        var n = arguments[0];
        this.init(n);
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
          r = arguments[1];
      this.init(i.x, r.x, i.y, r.y);
    } else if (4 === arguments.length) {
      var o = arguments[0],
          s = arguments[1],
          a = arguments[2],
          u = arguments[3];
      this.init(o, s, a, u);
    }
  },
      H = {
    serialVersionUID: {
      configurable: !0
    }
  };

  j.prototype.getArea = function () {
    return this.getWidth() * this.getHeight();
  }, j.prototype.equals = function (t) {
    if (!(t instanceof j)) return !1;
    var e = t;
    return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY();
  }, j.prototype.intersection = function (t) {
    if (this.isNull() || t.isNull() || !this.intersects(t)) return new j();
    var e = this._minx > t._minx ? this._minx : t._minx,
        n = this._miny > t._miny ? this._miny : t._miny,
        i = this._maxx < t._maxx ? this._maxx : t._maxx,
        r = this._maxy < t._maxy ? this._maxy : t._maxy;
    return new j(e, i, n, r);
  }, j.prototype.isNull = function () {
    return this._maxx < this._minx;
  }, j.prototype.getMaxX = function () {
    return this._maxx;
  }, j.prototype.covers = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof C) {
        var t = arguments[0];
        return this.covers(t.x, t.y);
      }

      if (arguments[0] instanceof j) {
        var e = arguments[0];
        return !this.isNull() && !e.isNull() && e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy;
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      return !this.isNull() && n >= this._minx && n <= this._maxx && i >= this._miny && i <= this._maxy;
    }
  }, j.prototype.intersects = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof j) {
        var t = arguments[0];
        return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny);
      }

      if (arguments[0] instanceof C) {
        var e = arguments[0];
        return this.intersects(e.x, e.y);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      return !this.isNull() && !(n > this._maxx || n < this._minx || i > this._maxy || i < this._miny);
    }
  }, j.prototype.getMinY = function () {
    return this._miny;
  }, j.prototype.getMinX = function () {
    return this._minx;
  }, j.prototype.expandToInclude = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof C) {
        var t = arguments[0];
        this.expandToInclude(t.x, t.y);
      } else if (arguments[0] instanceof j) {
        var e = arguments[0];
        if (e.isNull()) return null;
        this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy));
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      this.isNull() ? (this._minx = n, this._maxx = n, this._miny = i, this._maxy = i) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), i < this._miny && (this._miny = i), i > this._maxy && (this._maxy = i));
    }
  }, j.prototype.minExtent = function () {
    if (this.isNull()) return 0;
    var t = this.getWidth(),
        e = this.getHeight();
    return t < e ? t : e;
  }, j.prototype.getWidth = function () {
    return this.isNull() ? 0 : this._maxx - this._minx;
  }, j.prototype.compareTo = function (t) {
    var e = t;
    return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0;
  }, j.prototype.translate = function (t, e) {
    if (this.isNull()) return null;
    this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);
  }, j.prototype.toString = function () {
    return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
  }, j.prototype.setToNull = function () {
    this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
  }, j.prototype.getHeight = function () {
    return this.isNull() ? 0 : this._maxy - this._miny;
  }, j.prototype.maxExtent = function () {
    if (this.isNull()) return 0;
    var t = this.getWidth(),
        e = this.getHeight();
    return t > e ? t : e;
  }, j.prototype.expandBy = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.expandBy(t, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      if (this.isNull()) return null;
      this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
    }
  }, j.prototype.contains = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof j) {
        var t = arguments[0];
        return this.covers(t);
      }

      if (arguments[0] instanceof C) {
        var e = arguments[0];
        return this.covers(e);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      return this.covers(n, i);
    }
  }, j.prototype.centre = function () {
    return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
  }, j.prototype.init = function () {
    if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {
      if (arguments[0] instanceof C) {
        var t = arguments[0];
        this.init(t.x, t.x, t.y, t.y);
      } else if (arguments[0] instanceof j) {
        var e = arguments[0];
        this._minx = e._minx, this._maxx = e._maxx, this._miny = e._miny, this._maxy = e._maxy;
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      this.init(n.x, i.x, n.y, i.y);
    } else if (4 === arguments.length) {
      var r = arguments[0],
          o = arguments[1],
          s = arguments[2],
          a = arguments[3];
      r < o ? (this._minx = r, this._maxx = o) : (this._minx = o, this._maxx = r), s < a ? (this._miny = s, this._maxy = a) : (this._miny = a, this._maxy = s);
    }
  }, j.prototype.getMaxY = function () {
    return this._maxy;
  }, j.prototype.distance = function (t) {
    if (this.intersects(t)) return 0;
    var e = 0;
    this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
    var n = 0;
    return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);
  }, j.prototype.hashCode = function () {
    var t = 17;
    return t = 37 * t + C.hashCode(this._minx), t = 37 * t + C.hashCode(this._maxx), t = 37 * t + C.hashCode(this._miny), t = 37 * t + C.hashCode(this._maxy);
  }, j.prototype.interfaces_ = function () {
    return [E, e];
  }, j.prototype.getClass = function () {
    return j;
  }, j.intersects = function () {
    if (3 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2];
      return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);
    }

    if (4 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2],
          s = arguments[3],
          a = Math.min(o.x, s.x),
          u = Math.max(o.x, s.x),
          l = Math.min(i.x, r.x),
          c = Math.max(i.x, r.x);
      return !(l > u) && !(c < a) && (a = Math.min(o.y, s.y), u = Math.max(o.y, s.y), l = Math.min(i.y, r.y), c = Math.max(i.y, r.y), !(l > u) && !(c < a));
    }
  }, H.serialVersionUID.get = function () {
    return 0x51845cd552189800;
  }, Object.defineProperties(j, H);

  var W = {
    typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
    emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
    spaces: /\s+/,
    parenComma: /\)\s*,\s*\(/,
    doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
    trimParens: /^\s*\(?(.*?)\)?\s*$/
  },
      K = function (t) {
    this.geometryFactory = t || new _e();
  };

  K.prototype.read = function (t) {
    var e, n, i;
    t = t.replace(/[\n\r]/g, " ");
    var r = W.typeStr.exec(t);
    if (-1 !== t.search("EMPTY") && ((r = W.emptyTypeStr.exec(t))[2] = void 0), r && (n = r[1].toLowerCase(), i = r[2], Q[n] && (e = Q[n].apply(this, [i]))), void 0 === e) throw new Error("Could not parse WKT " + t);
    return e;
  }, K.prototype.write = function (t) {
    return this.extractGeometry(t);
  }, K.prototype.extractGeometry = function (t) {
    var e = t.getGeometryType().toLowerCase();
    if (!J[e]) return null;
    var n = e.toUpperCase();
    return t.isEmpty() ? n + " EMPTY" : n + "(" + J[e].apply(this, [t]) + ")";
  };

  var J = {
    coordinate: function (t) {
      return t.x + " " + t.y;
    },
    point: function (t) {
      return J.coordinate.call(this, t._coordinates._coordinates[0]);
    },
    multipoint: function (t) {
      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push("(" + J.point.apply(this, [t._geometries[n]]) + ")");

      return e.join(",");
    },
    linestring: function (t) {
      for (var e = [], n = 0, i = t._points._coordinates.length; n < i; ++n) e.push(J.coordinate.apply(this, [t._points._coordinates[n]]));

      return e.join(",");
    },
    linearring: function (t) {
      for (var e = [], n = 0, i = t._points._coordinates.length; n < i; ++n) e.push(J.coordinate.apply(this, [t._points._coordinates[n]]));

      return e.join(",");
    },
    multilinestring: function (t) {
      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push("(" + J.linestring.apply(this, [t._geometries[n]]) + ")");

      return e.join(",");
    },
    polygon: function (t) {
      var e = [];
      e.push("(" + J.linestring.apply(this, [t._shell]) + ")");

      for (var n = 0, i = t._holes.length; n < i; ++n) e.push("(" + J.linestring.apply(this, [t._holes[n]]) + ")");

      return e.join(",");
    },
    multipolygon: function (t) {
      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push("(" + J.polygon.apply(this, [t._geometries[n]]) + ")");

      return e.join(",");
    },
    geometrycollection: function (t) {
      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push(this.extractGeometry(t._geometries[n]));

      return e.join(",");
    }
  },
      Q = {
    point: function (t) {
      if (void 0 === t) return this.geometryFactory.createPoint();
      var e = t.trim().split(W.spaces);
      return this.geometryFactory.createPoint(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
    },
    multipoint: function (t) {
      if (void 0 === t) return this.geometryFactory.createMultiPoint();

      for (var e, n = t.trim().split(","), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].replace(W.trimParens, "$1"), i.push(Q.point.apply(this, [e]));

      return this.geometryFactory.createMultiPoint(i);
    },
    linestring: function (t) {
      if (void 0 === t) return this.geometryFactory.createLineString();

      for (var e, n = t.trim().split(","), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].trim().split(W.spaces), i.push(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));

      return this.geometryFactory.createLineString(i);
    },
    linearring: function (t) {
      if (void 0 === t) return this.geometryFactory.createLinearRing();

      for (var e, n = t.trim().split(","), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].trim().split(W.spaces), i.push(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));

      return this.geometryFactory.createLinearRing(i);
    },
    multilinestring: function (t) {
      if (void 0 === t) return this.geometryFactory.createMultiLineString();

      for (var e, n = t.trim().split(W.parenComma), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].replace(W.trimParens, "$1"), i.push(Q.linestring.apply(this, [e]));

      return this.geometryFactory.createMultiLineString(i);
    },
    polygon: function (t) {
      if (void 0 === t) return this.geometryFactory.createPolygon();

      for (var e, n, i, r, o = t.trim().split(W.parenComma), s = [], a = 0, u = o.length; a < u; ++a) e = o[a].replace(W.trimParens, "$1"), n = Q.linestring.apply(this, [e]), i = this.geometryFactory.createLinearRing(n._points), 0 === a ? r = i : s.push(i);

      return this.geometryFactory.createPolygon(r, s);
    },
    multipolygon: function (t) {
      if (void 0 === t) return this.geometryFactory.createMultiPolygon();

      for (var e, n = t.trim().split(W.doubleParenComma), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].replace(W.trimParens, "$1"), i.push(Q.polygon.apply(this, [e]));

      return this.geometryFactory.createMultiPolygon(i);
    },
    geometrycollection: function (t) {
      if (void 0 === t) return this.geometryFactory.createGeometryCollection();

      for (var e = (t = t.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n = [], i = 0, r = e.length; i < r; ++i) n.push(this.read(e[i]));

      return this.geometryFactory.createGeometryCollection(n);
    }
  },
      Z = function (t) {
    this.parser = new K(t);
  };

  Z.prototype.write = function (t) {
    return this.parser.write(t);
  }, Z.toLineString = function (t, e) {
    if (2 !== arguments.length) throw new Error("Not implemented");
    return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )";
  };

  var $ = function (t) {
    function e(e) {
      t.call(this, e), this.name = "RuntimeException", this.message = e, this.stack = new t().stack;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
  }(Error),
      tt = function (t) {
    function e() {
      if (t.call(this), 0 === arguments.length) t.call(this);else if (1 === arguments.length) {
        var e = arguments[0];
        t.call(this, e);
      }
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }($),
      et = function () {};

  et.prototype.interfaces_ = function () {
    return [];
  }, et.prototype.getClass = function () {
    return et;
  }, et.shouldNeverReachHere = function () {
    if (0 === arguments.length) et.shouldNeverReachHere(null);else if (1 === arguments.length) {
      var t = arguments[0];
      throw new tt("Should never reach here" + (null !== t ? ": " + t : ""));
    }
  }, et.isTrue = function () {
    var t, e;
    if (1 === arguments.length) t = arguments[0], et.isTrue(t, null);else if (2 === arguments.length && (t = arguments[0], e = arguments[1], !t)) throw null === e ? new tt() : new tt(e);
  }, et.equals = function () {
    var t, e, n;
    if (2 === arguments.length) t = arguments[0], e = arguments[1], et.equals(t, e, null);else if (3 === arguments.length && (t = arguments[0], e = arguments[1], n = arguments[2], !e.equals(t))) throw new tt("Expected " + t + " but encountered " + e + (null !== n ? ": " + n : ""));
  };

  var nt = function () {
    this._result = null, this._inputLines = Array(2).fill().map(function () {
      return Array(2);
    }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
  },
      it = {
    DONT_INTERSECT: {
      configurable: !0
    },
    DO_INTERSECT: {
      configurable: !0
    },
    COLLINEAR: {
      configurable: !0
    },
    NO_INTERSECTION: {
      configurable: !0
    },
    POINT_INTERSECTION: {
      configurable: !0
    },
    COLLINEAR_INTERSECTION: {
      configurable: !0
    }
  };

  nt.prototype.getIndexAlongSegment = function (t, e) {
    return this.computeIntLineIndex(), this._intLineIndex[t][e];
  }, nt.prototype.getTopologySummary = function () {
    var t = new D();
    return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString();
  }, nt.prototype.computeIntersection = function (t, e, n, i) {
    this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(t, e, n, i);
  }, nt.prototype.getIntersectionNum = function () {
    return this._result;
  }, nt.prototype.computeIntLineIndex = function () {
    if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function () {
      return Array(2);
    }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {
      var t = arguments[0];
      this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0);
    }
  }, nt.prototype.isProper = function () {
    return this.hasIntersection() && this._isProper;
  }, nt.prototype.setPrecisionModel = function (t) {
    this._precisionModel = t;
  }, nt.prototype.isInteriorIntersection = function () {
    if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);

    if (1 === arguments.length) {
      for (var t = arguments[0], e = 0; e < this._result; e++) if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0;

      return !1;
    }
  }, nt.prototype.getIntersection = function (t) {
    return this._intPt[t];
  }, nt.prototype.isEndPoint = function () {
    return this.hasIntersection() && !this._isProper;
  }, nt.prototype.hasIntersection = function () {
    return this._result !== nt.NO_INTERSECTION;
  }, nt.prototype.getEdgeDistance = function (t, e) {
    return nt.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1]);
  }, nt.prototype.isCollinear = function () {
    return this._result === nt.COLLINEAR_INTERSECTION;
  }, nt.prototype.toString = function () {
    return Z.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Z.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
  }, nt.prototype.getEndpoint = function (t, e) {
    return this._inputLines[t][e];
  }, nt.prototype.isIntersection = function (t) {
    for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;

    return !1;
  }, nt.prototype.getIntersectionAlongSegment = function (t, e) {
    return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];
  }, nt.prototype.interfaces_ = function () {
    return [];
  }, nt.prototype.getClass = function () {
    return nt;
  }, nt.computeEdgeDistance = function (t, e, n) {
    var i = Math.abs(n.x - e.x),
        r = Math.abs(n.y - e.y),
        o = -1;
    if (t.equals(e)) o = 0;else if (t.equals(n)) o = i > r ? i : r;else {
      var s = Math.abs(t.x - e.x),
          a = Math.abs(t.y - e.y);
      0 !== (o = i > r ? s : a) || t.equals(e) || (o = Math.max(s, a));
    }
    return et.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o;
  }, nt.nonRobustComputeEdgeDistance = function (t, e, n) {
    var i = t.x - e.x,
        r = t.y - e.y,
        o = Math.sqrt(i * i + r * r);
    return et.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o;
  }, it.DONT_INTERSECT.get = function () {
    return 0;
  }, it.DO_INTERSECT.get = function () {
    return 1;
  }, it.COLLINEAR.get = function () {
    return 2;
  }, it.NO_INTERSECTION.get = function () {
    return 0;
  }, it.POINT_INTERSECTION.get = function () {
    return 1;
  }, it.COLLINEAR_INTERSECTION.get = function () {
    return 2;
  }, Object.defineProperties(nt, it);

  var rt = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isInSegmentEnvelopes = function (t) {
      var e = new j(this._inputLines[0][0], this._inputLines[0][1]),
          n = new j(this._inputLines[1][0], this._inputLines[1][1]);
      return e.contains(t) && n.contains(t);
    }, e.prototype.computeIntersection = function () {
      if (3 !== arguments.length) return t.prototype.computeIntersection.apply(this, arguments);
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2];
      if (this._isProper = !1, j.intersects(n, i, e) && 0 === at.orientationIndex(n, i, e) && 0 === at.orientationIndex(i, n, e)) return this._isProper = !0, (e.equals(n) || e.equals(i)) && (this._isProper = !1), this._result = t.POINT_INTERSECTION, null;
      this._result = t.NO_INTERSECTION;
    }, e.prototype.normalizeToMinimum = function (t, e, n, i, r) {
      r.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x), r.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y), t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;
    }, e.prototype.safeHCoordinateIntersection = function (t, n, i, r) {
      var o = null;

      try {
        o = k.intersection(t, n, i, r);
      } catch (s) {
        if (!(s instanceof X)) throw s;
        o = e.nearestEndpoint(t, n, i, r);
      }

      return o;
    }, e.prototype.intersection = function (t, n, i, r) {
      var o = this.intersectionWithNormalization(t, n, i, r);
      return this.isInSegmentEnvelopes(o) || (o = new C(e.nearestEndpoint(t, n, i, r))), null !== this._precisionModel && this._precisionModel.makePrecise(o), o;
    }, e.prototype.smallestInAbsValue = function (t, e, n, i) {
      var r = t,
          o = Math.abs(r);
      return Math.abs(e) < o && (r = e, o = Math.abs(e)), Math.abs(n) < o && (r = n, o = Math.abs(n)), Math.abs(i) < o && (r = i), r;
    }, e.prototype.checkDD = function (t, e, n, i, r) {
      var o = q.intersection(t, e, n, i),
          s = this.isInSegmentEnvelopes(o);
      Y.out.println("DD in env = " + s + "  --------------------- " + o), r.distance(o) > 1e-4 && Y.out.println("Distance = " + r.distance(o));
    }, e.prototype.intersectionWithNormalization = function (t, e, n, i) {
      var r = new C(t),
          o = new C(e),
          s = new C(n),
          a = new C(i),
          u = new C();
      this.normalizeToEnvCentre(r, o, s, a, u);
      var l = this.safeHCoordinateIntersection(r, o, s, a);
      return l.x += u.x, l.y += u.y, l;
    }, e.prototype.computeCollinearIntersection = function (e, n, i, r) {
      var o = j.intersects(e, n, i),
          s = j.intersects(e, n, r),
          a = j.intersects(i, r, e),
          u = j.intersects(i, r, n);
      return o && s ? (this._intPt[0] = i, this._intPt[1] = r, t.COLLINEAR_INTERSECTION) : a && u ? (this._intPt[0] = e, this._intPt[1] = n, t.COLLINEAR_INTERSECTION) : o && a ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || s || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : o && u ? (this._intPt[0] = i, this._intPt[1] = n, !i.equals(n) || s || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && a ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || o || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && u ? (this._intPt[0] = r, this._intPt[1] = n, !r.equals(n) || o || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : t.NO_INTERSECTION;
    }, e.prototype.normalizeToEnvCentre = function (t, e, n, i, r) {
      var o = t.x < e.x ? t.x : e.x,
          s = t.y < e.y ? t.y : e.y,
          a = t.x > e.x ? t.x : e.x,
          u = t.y > e.y ? t.y : e.y,
          l = n.x < i.x ? n.x : i.x,
          c = n.y < i.y ? n.y : i.y,
          p = n.x > i.x ? n.x : i.x,
          h = n.y > i.y ? n.y : i.y,
          f = ((o > l ? o : l) + (a < p ? a : p)) / 2,
          g = ((s > c ? s : c) + (u < h ? u : h)) / 2;
      r.x = f, r.y = g, t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;
    }, e.prototype.computeIntersect = function (e, n, i, r) {
      if (this._isProper = !1, !j.intersects(e, n, i, r)) return t.NO_INTERSECTION;
      var o = at.orientationIndex(e, n, i),
          s = at.orientationIndex(e, n, r);
      if (o > 0 && s > 0 || o < 0 && s < 0) return t.NO_INTERSECTION;
      var a = at.orientationIndex(i, r, e),
          u = at.orientationIndex(i, r, n);
      if (a > 0 && u > 0 || a < 0 && u < 0) return t.NO_INTERSECTION;
      return 0 === o && 0 === s && 0 === a && 0 === u ? this.computeCollinearIntersection(e, n, i, r) : (0 === o || 0 === s || 0 === a || 0 === u ? (this._isProper = !1, e.equals2D(i) || e.equals2D(r) ? this._intPt[0] = e : n.equals2D(i) || n.equals2D(r) ? this._intPt[0] = n : 0 === o ? this._intPt[0] = new C(i) : 0 === s ? this._intPt[0] = new C(r) : 0 === a ? this._intPt[0] = new C(e) : 0 === u && (this._intPt[0] = new C(n))) : (this._isProper = !0, this._intPt[0] = this.intersection(e, n, i, r)), t.POINT_INTERSECTION);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e.nearestEndpoint = function (t, e, n, i) {
      var r = t,
          o = at.distancePointLine(t, n, i),
          s = at.distancePointLine(e, n, i);
      return s < o && (o = s, r = e), (s = at.distancePointLine(n, t, e)) < o && (o = s, r = n), (s = at.distancePointLine(i, t, e)) < o && (o = s, r = i), r;
    }, e;
  }(nt),
      ot = function () {};

  ot.prototype.interfaces_ = function () {
    return [];
  }, ot.prototype.getClass = function () {
    return ot;
  }, ot.orientationIndex = function (t, e, n) {
    var i = e.x - t.x,
        r = e.y - t.y,
        o = n.x - e.x,
        s = n.y - e.y;
    return ot.signOfDet2x2(i, r, o, s);
  }, ot.signOfDet2x2 = function (t, e, n, i) {
    var r = null,
        o = null,
        s = null;
    if (r = 1, 0 === t || 0 === i) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -r : r : n > 0 ? r : -r;
    if (0 === e || 0 === n) return i > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;

    if (e > 0 ? i > 0 ? e <= i || (r = -r, o = t, t = n, n = o, o = e, e = i, i = o) : e <= -i ? (r = -r, n = -n, i = -i) : (o = t, t = -n, n = o, o = e, e = -i, i = o) : i > 0 ? -e <= i ? (r = -r, t = -t, e = -e) : (o = -t, t = n, n = o, o = -e, e = i, i = o) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (r = -r, o = -t, t = -n, n = o, o = -e, e = -i, i = o), t > 0) {
      if (!(n > 0)) return r;
      if (!(t <= n)) return r;
    } else {
      if (n > 0) return -r;
      if (!(t >= n)) return -r;
      r = -r, t = -t, n = -n;
    }

    for (;;) {
      if (s = Math.floor(n / t), n -= s * t, (i -= s * e) < 0) return -r;
      if (i > e) return r;

      if (t > n + n) {
        if (e < i + i) return r;
      } else {
        if (e > i + i) return -r;
        n = t - n, i = e - i, r = -r;
      }

      if (0 === i) return 0 === n ? 0 : -r;
      if (0 === n) return r;
      if (s = Math.floor(t / n), t -= s * n, (e -= s * i) < 0) return r;
      if (e > i) return -r;

      if (n > t + t) {
        if (i < e + e) return -r;
      } else {
        if (i > e + e) return r;
        t = n - t, e = i - e, r = -r;
      }

      if (0 === e) return 0 === t ? 0 : r;
      if (0 === t) return -r;
    }
  };

  var st = function () {
    this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
    var t = arguments[0];
    this._p = t;
  };

  st.prototype.countSegment = function (t, e) {
    if (t.x < this._p.x && e.x < this._p.x) return null;
    if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;

    if (t.y === this._p.y && e.y === this._p.y) {
      var n = t.x,
          i = e.x;
      return n > i && (n = e.x, i = t.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null;
    }

    if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
      var r = t.x - this._p.x,
          o = t.y - this._p.y,
          s = e.x - this._p.x,
          a = e.y - this._p.y,
          u = ot.signOfDet2x2(r, o, s, a);
      if (0 === u) return this._isPointOnSegment = !0, null;
      a < o && (u = -u), u > 0 && this._crossingCount++;
    }
  }, st.prototype.isPointInPolygon = function () {
    return this.getLocation() !== w.EXTERIOR;
  }, st.prototype.getLocation = function () {
    return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;
  }, st.prototype.isOnSegment = function () {
    return this._isPointOnSegment;
  }, st.prototype.interfaces_ = function () {
    return [];
  }, st.prototype.getClass = function () {
    return st;
  }, st.locatePointInRing = function () {
    if (arguments[0] instanceof C && T(arguments[1], V)) {
      for (var t = arguments[0], e = arguments[1], n = new st(t), i = new C(), r = new C(), o = 1; o < e.size(); o++) if (e.getCoordinate(o, i), e.getCoordinate(o - 1, r), n.countSegment(i, r), n.isOnSegment()) return n.getLocation();

      return n.getLocation();
    }

    if (arguments[0] instanceof C && arguments[1] instanceof Array) {
      for (var s = arguments[0], a = arguments[1], u = new st(s), l = 1; l < a.length; l++) {
        var c = a[l],
            p = a[l - 1];
        if (u.countSegment(c, p), u.isOnSegment()) return u.getLocation();
      }

      return u.getLocation();
    }
  };

  var at = function () {},
      ut = {
    CLOCKWISE: {
      configurable: !0
    },
    RIGHT: {
      configurable: !0
    },
    COUNTERCLOCKWISE: {
      configurable: !0
    },
    LEFT: {
      configurable: !0
    },
    COLLINEAR: {
      configurable: !0
    },
    STRAIGHT: {
      configurable: !0
    }
  };

  at.prototype.interfaces_ = function () {
    return [];
  }, at.prototype.getClass = function () {
    return at;
  }, at.orientationIndex = function (t, e, n) {
    return q.orientationIndex(t, e, n);
  }, at.signedArea = function () {
    if (arguments[0] instanceof Array) {
      var t = arguments[0];
      if (t.length < 3) return 0;

      for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {
        var r = t[i].x - n,
            o = t[i + 1].y;
        e += r * (t[i - 1].y - o);
      }

      return e / 2;
    }

    if (T(arguments[0], V)) {
      var s = arguments[0],
          a = s.size();
      if (a < 3) return 0;
      var u = new C(),
          l = new C(),
          c = new C();
      s.getCoordinate(0, l), s.getCoordinate(1, c);
      var p = l.x;
      c.x -= p;

      for (var h = 0, f = 1; f < a - 1; f++) u.y = l.y, l.x = c.x, l.y = c.y, s.getCoordinate(f + 1, c), c.x -= p, h += l.x * (u.y - c.y);

      return h / 2;
    }
  }, at.distanceLineLine = function (t, e, n, i) {
    if (t.equals(e)) return at.distancePointLine(t, n, i);
    if (n.equals(i)) return at.distancePointLine(i, t, e);
    var r = !1;

    if (j.intersects(t, e, n, i)) {
      var o = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);
      if (0 === o) r = !0;else {
        var s = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y),
            a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / o,
            u = s / o;
        (u < 0 || u > 1 || a < 0 || a > 1) && (r = !0);
      }
    } else r = !0;

    return r ? R.min(at.distancePointLine(t, n, i), at.distancePointLine(e, n, i), at.distancePointLine(n, t, e), at.distancePointLine(i, t, e)) : 0;
  }, at.isPointInRing = function (t, e) {
    return at.locatePointInRing(t, e) !== w.EXTERIOR;
  }, at.computeLength = function (t) {
    var e = t.size();
    if (e <= 1) return 0;
    var n = 0,
        i = new C();
    t.getCoordinate(0, i);

    for (var r = i.x, o = i.y, s = 1; s < e; s++) {
      t.getCoordinate(s, i);
      var a = i.x,
          u = i.y,
          l = a - r,
          c = u - o;
      n += Math.sqrt(l * l + c * c), r = a, o = u;
    }

    return n;
  }, at.isCCW = function (t) {
    var e = t.length - 1;
    if (e < 3) throw new m("Ring has fewer than 4 points, so orientation cannot be determined");

    for (var n = t[0], i = 0, r = 1; r <= e; r++) {
      var o = t[r];
      o.y > n.y && (n = o, i = r);
    }

    var s = i;

    do {
      (s -= 1) < 0 && (s = e);
    } while (t[s].equals2D(n) && s !== i);

    var a = i;

    do {
      a = (a + 1) % e;
    } while (t[a].equals2D(n) && a !== i);

    var u = t[s],
        l = t[a];
    if (u.equals2D(n) || l.equals2D(n) || u.equals2D(l)) return !1;
    var c = at.computeOrientation(u, n, l),
        p = !1;
    return p = 0 === c ? u.x > l.x : c > 0, p;
  }, at.locatePointInRing = function (t, e) {
    return st.locatePointInRing(t, e);
  }, at.distancePointLinePerpendicular = function (t, e, n) {
    var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
        r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;
    return Math.abs(r) * Math.sqrt(i);
  }, at.computeOrientation = function (t, e, n) {
    return at.orientationIndex(t, e, n);
  }, at.distancePointLine = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      if (0 === e.length) throw new m("Line array must contain at least one vertex");

      for (var n = t.distance(e[0]), i = 0; i < e.length - 1; i++) {
        var r = at.distancePointLine(t, e[i], e[i + 1]);
        r < n && (n = r);
      }

      return n;
    }

    if (3 === arguments.length) {
      var o = arguments[0],
          s = arguments[1],
          a = arguments[2];
      if (s.x === a.x && s.y === a.y) return o.distance(s);
      var u = (a.x - s.x) * (a.x - s.x) + (a.y - s.y) * (a.y - s.y),
          l = ((o.x - s.x) * (a.x - s.x) + (o.y - s.y) * (a.y - s.y)) / u;
      if (l <= 0) return o.distance(s);
      if (l >= 1) return o.distance(a);
      var c = ((s.y - o.y) * (a.x - s.x) - (s.x - o.x) * (a.y - s.y)) / u;
      return Math.abs(c) * Math.sqrt(u);
    }
  }, at.isOnLine = function (t, e) {
    for (var n = new rt(), i = 1; i < e.length; i++) {
      var r = e[i - 1],
          o = e[i];
      if (n.computeIntersection(t, r, o), n.hasIntersection()) return !0;
    }

    return !1;
  }, ut.CLOCKWISE.get = function () {
    return -1;
  }, ut.RIGHT.get = function () {
    return at.CLOCKWISE;
  }, ut.COUNTERCLOCKWISE.get = function () {
    return 1;
  }, ut.LEFT.get = function () {
    return at.COUNTERCLOCKWISE;
  }, ut.COLLINEAR.get = function () {
    return 0;
  }, ut.STRAIGHT.get = function () {
    return at.COLLINEAR;
  }, Object.defineProperties(at, ut);

  var lt = function () {};

  lt.prototype.filter = function (t) {}, lt.prototype.interfaces_ = function () {
    return [];
  }, lt.prototype.getClass = function () {
    return lt;
  };

  var ct = function () {
    var t = arguments[0];
    this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t, this._SRID = t.getSRID();
  },
      pt = {
    serialVersionUID: {
      configurable: !0
    },
    SORTINDEX_POINT: {
      configurable: !0
    },
    SORTINDEX_MULTIPOINT: {
      configurable: !0
    },
    SORTINDEX_LINESTRING: {
      configurable: !0
    },
    SORTINDEX_LINEARRING: {
      configurable: !0
    },
    SORTINDEX_MULTILINESTRING: {
      configurable: !0
    },
    SORTINDEX_POLYGON: {
      configurable: !0
    },
    SORTINDEX_MULTIPOLYGON: {
      configurable: !0
    },
    SORTINDEX_GEOMETRYCOLLECTION: {
      configurable: !0
    },
    geometryChangedFilter: {
      configurable: !0
    }
  };

  ct.prototype.isGeometryCollection = function () {
    return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;
  }, ct.prototype.getFactory = function () {
    return this._factory;
  }, ct.prototype.getGeometryN = function (t) {
    return this;
  }, ct.prototype.getArea = function () {
    return 0;
  }, ct.prototype.isRectangle = function () {
    return !1;
  }, ct.prototype.equals = function () {
    if (arguments[0] instanceof ct) {
      var t = arguments[0];
      return null !== t && this.equalsTopo(t);
    }

    if (arguments[0] instanceof Object) {
      var e = arguments[0];
      if (!(e instanceof ct)) return !1;
      var n = e;
      return this.equalsExact(n);
    }
  }, ct.prototype.equalsExact = function (t) {
    return this === t || this.equalsExact(t, 0);
  }, ct.prototype.geometryChanged = function () {
    this.apply(ct.geometryChangedFilter);
  }, ct.prototype.geometryChangedAction = function () {
    this._envelope = null;
  }, ct.prototype.equalsNorm = function (t) {
    return null !== t && this.norm().equalsExact(t.norm());
  }, ct.prototype.getLength = function () {
    return 0;
  }, ct.prototype.getNumGeometries = function () {
    return 1;
  }, ct.prototype.compareTo = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = t;
      return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t);
    }

    if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, i);
    }
  }, ct.prototype.getUserData = function () {
    return this._userData;
  }, ct.prototype.getSRID = function () {
    return this._SRID;
  }, ct.prototype.getEnvelope = function () {
    return this.getFactory().toGeometry(this.getEnvelopeInternal());
  }, ct.prototype.checkNotGeometryCollection = function (t) {
    if (t.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION) throw new m("This method does not support GeometryCollection arguments");
  }, ct.prototype.equal = function (t, e, n) {
    return 0 === n ? t.equals(e) : t.distance(e) <= n;
  }, ct.prototype.norm = function () {
    var t = this.copy();
    return t.normalize(), t;
  }, ct.prototype.getPrecisionModel = function () {
    return this._factory.getPrecisionModel();
  }, ct.prototype.getEnvelopeInternal = function () {
    return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);
  }, ct.prototype.setSRID = function (t) {
    this._SRID = t;
  }, ct.prototype.setUserData = function (t) {
    this._userData = t;
  }, ct.prototype.compare = function (t, e) {
    for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {
      var r = n.next(),
          o = i.next(),
          s = r.compareTo(o);
      if (0 !== s) return s;
    }

    return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;
  }, ct.prototype.hashCode = function () {
    return this.getEnvelopeInternal().hashCode();
  }, ct.prototype.isGeometryCollectionOrDerived = function () {
    return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;
  }, ct.prototype.interfaces_ = function () {
    return [x, E, e];
  }, ct.prototype.getClass = function () {
    return ct;
  }, ct.hasNonEmptyElements = function (t) {
    for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;

    return !1;
  }, ct.hasNullElements = function (t) {
    for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;

    return !1;
  }, pt.serialVersionUID.get = function () {
    return 0x799ea46522854c00;
  }, pt.SORTINDEX_POINT.get = function () {
    return 0;
  }, pt.SORTINDEX_MULTIPOINT.get = function () {
    return 1;
  }, pt.SORTINDEX_LINESTRING.get = function () {
    return 2;
  }, pt.SORTINDEX_LINEARRING.get = function () {
    return 3;
  }, pt.SORTINDEX_MULTILINESTRING.get = function () {
    return 4;
  }, pt.SORTINDEX_POLYGON.get = function () {
    return 5;
  }, pt.SORTINDEX_MULTIPOLYGON.get = function () {
    return 6;
  }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function () {
    return 7;
  }, pt.geometryChangedFilter.get = function () {
    return ht;
  }, Object.defineProperties(ct, pt);

  var ht = function () {};

  ht.interfaces_ = function () {
    return [lt];
  }, ht.filter = function (t) {
    t.geometryChangedAction();
  };

  var ft = function () {};

  ft.prototype.filter = function (t) {}, ft.prototype.interfaces_ = function () {
    return [];
  }, ft.prototype.getClass = function () {
    return ft;
  };

  var gt = function () {},
      dt = {
    Mod2BoundaryNodeRule: {
      configurable: !0
    },
    EndPointBoundaryNodeRule: {
      configurable: !0
    },
    MultiValentEndPointBoundaryNodeRule: {
      configurable: !0
    },
    MonoValentEndPointBoundaryNodeRule: {
      configurable: !0
    },
    MOD2_BOUNDARY_RULE: {
      configurable: !0
    },
    ENDPOINT_BOUNDARY_RULE: {
      configurable: !0
    },
    MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {
      configurable: !0
    },
    MONOVALENT_ENDPOINT_BOUNDARY_RULE: {
      configurable: !0
    },
    OGC_SFS_BOUNDARY_RULE: {
      configurable: !0
    }
  };

  gt.prototype.isInBoundary = function (t) {}, gt.prototype.interfaces_ = function () {
    return [];
  }, gt.prototype.getClass = function () {
    return gt;
  }, dt.Mod2BoundaryNodeRule.get = function () {
    return yt;
  }, dt.EndPointBoundaryNodeRule.get = function () {
    return _t;
  }, dt.MultiValentEndPointBoundaryNodeRule.get = function () {
    return mt;
  }, dt.MonoValentEndPointBoundaryNodeRule.get = function () {
    return vt;
  }, dt.MOD2_BOUNDARY_RULE.get = function () {
    return new yt();
  }, dt.ENDPOINT_BOUNDARY_RULE.get = function () {
    return new _t();
  }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {
    return new mt();
  }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {
    return new vt();
  }, dt.OGC_SFS_BOUNDARY_RULE.get = function () {
    return gt.MOD2_BOUNDARY_RULE;
  }, Object.defineProperties(gt, dt);

  var yt = function () {};

  yt.prototype.isInBoundary = function (t) {
    return t % 2 == 1;
  }, yt.prototype.interfaces_ = function () {
    return [gt];
  }, yt.prototype.getClass = function () {
    return yt;
  };

  var _t = function () {};

  _t.prototype.isInBoundary = function (t) {
    return t > 0;
  }, _t.prototype.interfaces_ = function () {
    return [gt];
  }, _t.prototype.getClass = function () {
    return _t;
  };

  var mt = function () {};

  mt.prototype.isInBoundary = function (t) {
    return t > 1;
  }, mt.prototype.interfaces_ = function () {
    return [gt];
  }, mt.prototype.getClass = function () {
    return mt;
  };

  var vt = function () {};

  vt.prototype.isInBoundary = function (t) {
    return 1 === t;
  }, vt.prototype.interfaces_ = function () {
    return [gt];
  }, vt.prototype.getClass = function () {
    return vt;
  };

  var It = function () {};

  It.prototype.add = function () {}, It.prototype.addAll = function () {}, It.prototype.isEmpty = function () {}, It.prototype.iterator = function () {}, It.prototype.size = function () {}, It.prototype.toArray = function () {}, It.prototype.remove = function () {}, (n.prototype = new Error()).name = "IndexOutOfBoundsException";

  var Et = function () {};

  Et.prototype.hasNext = function () {}, Et.prototype.next = function () {}, Et.prototype.remove = function () {};

  var xt = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function () {}, e.prototype.set = function () {}, e.prototype.isEmpty = function () {}, e;
  }(It);

  (i.prototype = new Error()).name = "NoSuchElementException";

  var Nt = function (t) {
    function e() {
      t.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.ensureCapacity = function () {}, e.prototype.interfaces_ = function () {
      return [t, It];
    }, e.prototype.add = function (t) {
      return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0;
    }, e.prototype.clear = function () {
      this.array_ = [];
    }, e.prototype.addAll = function (t) {
      for (var e = t.iterator(); e.hasNext();) this.add(e.next());

      return !0;
    }, e.prototype.set = function (t, e) {
      var n = this.array_[t];
      return this.array_[t] = e, n;
    }, e.prototype.iterator = function () {
      return new Ct(this);
    }, e.prototype.get = function (t) {
      if (t < 0 || t >= this.size()) throw new n();
      return this.array_[t];
    }, e.prototype.isEmpty = function () {
      return 0 === this.array_.length;
    }, e.prototype.size = function () {
      return this.array_.length;
    }, e.prototype.toArray = function () {
      for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);

      return t;
    }, e.prototype.remove = function (t) {
      for (var e = !1, n = 0, i = this.array_.length; n < i; n++) if (this.array_[n] === t) {
        this.array_.splice(n, 1), e = !0;
        break;
      }

      return e;
    }, e;
  }(xt),
      Ct = function (t) {
    function e(e) {
      t.call(this), this.arrayList_ = e, this.position_ = 0;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () {
      if (this.position_ === this.arrayList_.size()) throw new i();
      return this.arrayList_.get(this.position_++);
    }, e.prototype.hasNext = function () {
      return this.position_ < this.arrayList_.size();
    }, e.prototype.set = function (t) {
      return this.arrayList_.set(this.position_ - 1, t);
    }, e.prototype.remove = function () {
      this.arrayList_.remove(this.arrayList_.get(this.position_));
    }, e;
  }(Et),
      St = function (t) {
    function e() {
      if (t.call(this), 0 === arguments.length) ;else if (1 === arguments.length) {
        var e = arguments[0];
        this.ensureCapacity(e.length), this.add(e, !0);
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];
        this.ensureCapacity(n.length), this.add(n, i);
      }
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      coordArrayType: {
        configurable: !0
      }
    };
    return n.coordArrayType.get = function () {
      return new Array(0).fill(null);
    }, e.prototype.getCoordinate = function (t) {
      return this.get(t);
    }, e.prototype.addAll = function () {
      if (2 === arguments.length) {
        for (var e = arguments[0], n = arguments[1], i = !1, r = e.iterator(); r.hasNext();) this.add(r.next(), n), i = !0;

        return i;
      }

      return t.prototype.addAll.apply(this, arguments);
    }, e.prototype.clone = function () {
      for (var e = t.prototype.clone.call(this), n = 0; n < this.size(); n++) e.add(n, this.get(n).copy());

      return e;
    }, e.prototype.toCoordinateArray = function () {
      return this.toArray(e.coordArrayType);
    }, e.prototype.add = function () {
      if (1 === arguments.length) {
        var e = arguments[0];
        t.prototype.add.call(this, e);
      } else if (2 === arguments.length) {
        if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
          var n = arguments[0],
              i = arguments[1];
          return this.add(n, i, !0), !0;
        }

        if (arguments[0] instanceof C && "boolean" == typeof arguments[1]) {
          var r = arguments[0];

          if (!arguments[1] && this.size() >= 1) {
            if (this.get(this.size() - 1).equals2D(r)) return null;
          }

          t.prototype.add.call(this, r);
        } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
          var o = arguments[0],
              s = arguments[1];
          return this.add(o, s), !0;
        }
      } else if (3 === arguments.length) {
        if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
          var a = arguments[0],
              u = arguments[1];
          if (arguments[2]) for (var l = 0; l < a.length; l++) this.add(a[l], u);else for (var c = a.length - 1; c >= 0; c--) this.add(a[c], u);
          return !0;
        }

        if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
          var p = arguments[0],
              h = arguments[1];

          if (!arguments[2]) {
            var f = this.size();

            if (f > 0) {
              if (p > 0) {
                if (this.get(p - 1).equals2D(h)) return null;
              }

              if (p < f) {
                if (this.get(p).equals2D(h)) return null;
              }
            }
          }

          t.prototype.add.call(this, p, h);
        }
      } else if (4 === arguments.length) {
        var g = arguments[0],
            d = arguments[1],
            y = arguments[2],
            _ = arguments[3],
            m = 1;
        y > _ && (m = -1);

        for (var v = y; v !== _; v += m) this.add(g[v], d);

        return !0;
      }
    }, e.prototype.closeRing = function () {
      this.size() > 0 && this.add(new C(this.get(0)), !1);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, Object.defineProperties(e, n), e;
  }(Nt),
      Lt = function () {},
      bt = {
    ForwardComparator: {
      configurable: !0
    },
    BidirectionalComparator: {
      configurable: !0
    },
    coordArrayType: {
      configurable: !0
    }
  };

  bt.ForwardComparator.get = function () {
    return wt;
  }, bt.BidirectionalComparator.get = function () {
    return Ot;
  }, bt.coordArrayType.get = function () {
    return new Array(0).fill(null);
  }, Lt.prototype.interfaces_ = function () {
    return [];
  }, Lt.prototype.getClass = function () {
    return Lt;
  }, Lt.isRing = function (t) {
    return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);
  }, Lt.ptNotInList = function (t, e) {
    for (var n = 0; n < t.length; n++) {
      var i = t[n];
      if (Lt.indexOf(i, e) < 0) return i;
    }

    return null;
  }, Lt.scroll = function (t, e) {
    var n = Lt.indexOf(e, t);
    if (n < 0) return null;
    var i = new Array(t.length).fill(null);
    Y.arraycopy(t, n, i, 0, t.length - n), Y.arraycopy(t, 0, i, t.length - n, n), Y.arraycopy(i, 0, t, 0, t.length);
  }, Lt.equals = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      if (t === e) return !0;
      if (null === t || null === e) return !1;
      if (t.length !== e.length) return !1;

      for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;

      return !0;
    }

    if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2];
      if (i === r) return !0;
      if (null === i || null === r) return !1;
      if (i.length !== r.length) return !1;

      for (var s = 0; s < i.length; s++) if (0 !== o.compare(i[s], r[s])) return !1;

      return !0;
    }
  }, Lt.intersection = function (t, e) {
    for (var n = new St(), i = 0; i < t.length; i++) e.intersects(t[i]) && n.add(t[i], !0);

    return n.toCoordinateArray();
  }, Lt.hasRepeatedPoints = function (t) {
    for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;

    return !1;
  }, Lt.removeRepeatedPoints = function (t) {
    if (!Lt.hasRepeatedPoints(t)) return t;
    return new St(t, !1).toCoordinateArray();
  }, Lt.reverse = function (t) {
    for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {
      var r = t[i];
      t[i] = t[e - i], t[e - i] = r;
    }
  }, Lt.removeNull = function (t) {
    for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;

    var i = new Array(e).fill(null);
    if (0 === e) return i;

    for (var r = 0, o = 0; o < t.length; o++) null !== t[o] && (i[r++] = t[o]);

    return i;
  }, Lt.copyDeep = function () {
    if (1 === arguments.length) {
      for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = new C(t[n]);

      return e;
    }

    if (5 === arguments.length) for (var i = arguments[0], r = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], u = 0; u < a; u++) o[s + u] = new C(i[r + u]);
  }, Lt.isEqualReversed = function (t, e) {
    for (var n = 0; n < t.length; n++) {
      var i = t[n],
          r = e[t.length - n - 1];
      if (0 !== i.compareTo(r)) return !1;
    }

    return !0;
  }, Lt.envelope = function (t) {
    for (var e = new j(), n = 0; n < t.length; n++) e.expandToInclude(t[n]);

    return e;
  }, Lt.toCoordinateArray = function (t) {
    return t.toArray(Lt.coordArrayType);
  }, Lt.atLeastNCoordinatesOrNothing = function (t, e) {
    return e.length >= t ? e : [];
  }, Lt.indexOf = function (t, e) {
    for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;

    return -1;
  }, Lt.increasingDirection = function (t) {
    for (var e = 0; e < Math.trunc(t.length / 2); e++) {
      var n = t.length - 1 - e,
          i = t[e].compareTo(t[n]);
      if (0 !== i) return i;
    }

    return 1;
  }, Lt.compare = function (t, e) {
    for (var n = 0; n < t.length && n < e.length;) {
      var i = t[n].compareTo(e[n]);
      if (0 !== i) return i;
      n++;
    }

    return n < e.length ? -1 : n < t.length ? 1 : 0;
  }, Lt.minCoordinate = function (t) {
    for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);

    return e;
  }, Lt.extract = function (t, e, n) {
    e = R.clamp(e, 0, t.length);
    var i = (n = R.clamp(n, -1, t.length)) - e + 1;
    n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);
    var r = new Array(i).fill(null);
    if (0 === i) return r;

    for (var o = 0, s = e; s <= n; s++) r[o++] = t[s];

    return r;
  }, Object.defineProperties(Lt, bt);

  var wt = function () {};

  wt.prototype.compare = function (t, e) {
    return Lt.compare(t, e);
  }, wt.prototype.interfaces_ = function () {
    return [N];
  }, wt.prototype.getClass = function () {
    return wt;
  };

  var Ot = function () {};

  Ot.prototype.compare = function (t, e) {
    var n = t,
        i = e;
    if (n.length < i.length) return -1;
    if (n.length > i.length) return 1;
    if (0 === n.length) return 0;
    var r = Lt.compare(n, i);
    return Lt.isEqualReversed(n, i) ? 0 : r;
  }, Ot.prototype.OLDcompare = function (t, e) {
    var n = t,
        i = e;
    if (n.length < i.length) return -1;
    if (n.length > i.length) return 1;
    if (0 === n.length) return 0;

    for (var r = Lt.increasingDirection(n), o = Lt.increasingDirection(i), s = r > 0 ? 0 : n.length - 1, a = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {
      var l = n[s].compareTo(i[a]);
      if (0 !== l) return l;
      s += r, a += o;
    }

    return 0;
  }, Ot.prototype.interfaces_ = function () {
    return [N];
  }, Ot.prototype.getClass = function () {
    return Ot;
  };

  var Tt = function () {};

  Tt.prototype.get = function () {}, Tt.prototype.put = function () {}, Tt.prototype.size = function () {}, Tt.prototype.values = function () {}, Tt.prototype.entrySet = function () {};

  var Rt = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
  }(Tt);

  (r.prototype = new Error()).name = "OperationNotSupported", (o.prototype = new It()).contains = function () {};

  var Pt = function (t) {
    function e() {
      t.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.contains = function (t) {
      for (var e = 0, n = this.array_.length; e < n; e++) {
        if (this.array_[e] === t) return !0;
      }

      return !1;
    }, e.prototype.add = function (t) {
      return !this.contains(t) && (this.array_.push(t), !0);
    }, e.prototype.addAll = function (t) {
      for (var e = t.iterator(); e.hasNext();) this.add(e.next());

      return !0;
    }, e.prototype.remove = function (t) {
      throw new Error();
    }, e.prototype.size = function () {
      return this.array_.length;
    }, e.prototype.isEmpty = function () {
      return 0 === this.array_.length;
    }, e.prototype.toArray = function () {
      for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);

      return t;
    }, e.prototype.iterator = function () {
      return new Dt(this);
    }, e;
  }(o),
      Dt = function (t) {
    function e(e) {
      t.call(this), this.hashSet_ = e, this.position_ = 0;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () {
      if (this.position_ === this.hashSet_.size()) throw new i();
      return this.hashSet_.array_[this.position_++];
    }, e.prototype.hasNext = function () {
      return this.position_ < this.hashSet_.size();
    }, e.prototype.remove = function () {
      throw new r();
    }, e;
  }(Et),
      Mt = 0;

  (p.prototype = new Rt()).get = function (t) {
    for (var e = this.root_; null !== e;) {
      var n = t.compareTo(e.key);
      if (n < 0) e = e.left;else {
        if (!(n > 0)) return e.value;
        e = e.right;
      }
    }

    return null;
  }, p.prototype.put = function (t, e) {
    if (null === this.root_) return this.root_ = {
      key: t,
      value: e,
      left: null,
      right: null,
      parent: null,
      color: Mt,
      getValue: function () {
        return this.value;
      },
      getKey: function () {
        return this.key;
      }
    }, this.size_ = 1, null;
    var n,
        i,
        r = this.root_;

    do {
      if (n = r, (i = t.compareTo(r.key)) < 0) r = r.left;else {
        if (!(i > 0)) {
          var o = r.value;
          return r.value = e, o;
        }

        r = r.right;
      }
    } while (null !== r);

    var s = {
      key: t,
      left: null,
      right: null,
      value: e,
      parent: n,
      color: Mt,
      getValue: function () {
        return this.value;
      },
      getKey: function () {
        return this.key;
      }
    };
    return i < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null;
  }, p.prototype.fixAfterInsertion = function (t) {
    for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) if (a(t) === l(a(a(t)))) {
      var e = c(a(a(t)));
      1 === s(e) ? (u(a(t), Mt), u(e, Mt), u(a(a(t)), 1), t = a(a(t))) : (t === c(a(t)) && (t = a(t), this.rotateLeft(t)), u(a(t), Mt), u(a(a(t)), 1), this.rotateRight(a(a(t))));
    } else {
      var n = l(a(a(t)));
      1 === s(n) ? (u(a(t), Mt), u(n, Mt), u(a(a(t)), 1), t = a(a(t))) : (t === l(a(t)) && (t = a(t), this.rotateRight(t)), u(a(t), Mt), u(a(a(t)), 1), this.rotateLeft(a(a(t))));
    }

    this.root_.color = Mt;
  }, p.prototype.values = function () {
    var t = new Nt(),
        e = this.getFirstEntry();
    if (null !== e) for (t.add(e.value); null !== (e = p.successor(e));) t.add(e.value);
    return t;
  }, p.prototype.entrySet = function () {
    var t = new Pt(),
        e = this.getFirstEntry();
    if (null !== e) for (t.add(e); null !== (e = p.successor(e));) t.add(e);
    return t;
  }, p.prototype.rotateLeft = function (t) {
    if (null != t) {
      var e = t.right;
      t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;
    }
  }, p.prototype.rotateRight = function (t) {
    if (null != t) {
      var e = t.left;
      t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;
    }
  }, p.prototype.getFirstEntry = function () {
    var t = this.root_;
    if (null != t) for (; null != t.left;) t = t.left;
    return t;
  }, p.successor = function (t) {
    if (null === t) return null;

    if (null !== t.right) {
      for (var e = t.right; null !== e.left;) e = e.left;

      return e;
    }

    for (var n = t.parent, i = t; null !== n && i === n.right;) i = n, n = n.parent;

    return n;
  }, p.prototype.size = function () {
    return this.size_;
  };

  var At = function () {};

  At.prototype.interfaces_ = function () {
    return [];
  }, At.prototype.getClass = function () {
    return At;
  }, h.prototype = new o(), (f.prototype = new h()).contains = function (t) {
    for (var e = 0, n = this.array_.length; e < n; e++) {
      if (0 === this.array_[e].compareTo(t)) return !0;
    }

    return !1;
  }, f.prototype.add = function (t) {
    if (this.contains(t)) return !1;

    for (var e = 0, n = this.array_.length; e < n; e++) {
      if (1 === this.array_[e].compareTo(t)) return this.array_.splice(e, 0, t), !0;
    }

    return this.array_.push(t), !0;
  }, f.prototype.addAll = function (t) {
    for (var e = t.iterator(); e.hasNext();) this.add(e.next());

    return !0;
  }, f.prototype.remove = function (t) {
    throw new r();
  }, f.prototype.size = function () {
    return this.array_.length;
  }, f.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  }, f.prototype.toArray = function () {
    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);

    return t;
  }, f.prototype.iterator = function () {
    return new Ft(this);
  };

  var Ft = function (t) {
    this.treeSet_ = t, this.position_ = 0;
  };

  Ft.prototype.next = function () {
    if (this.position_ === this.treeSet_.size()) throw new i();
    return this.treeSet_.array_[this.position_++];
  }, Ft.prototype.hasNext = function () {
    return this.position_ < this.treeSet_.size();
  }, Ft.prototype.remove = function () {
    throw new r();
  };

  var Gt = function () {};

  Gt.sort = function () {
    var t,
        e,
        n,
        i,
        r = arguments[0];
    if (1 === arguments.length) i = function (t, e) {
      return t.compareTo(e);
    }, r.sort(i);else if (2 === arguments.length) n = arguments[1], i = function (t, e) {
      return n.compare(t, e);
    }, r.sort(i);else if (3 === arguments.length) {
      (e = r.slice(arguments[1], arguments[2])).sort();
      var o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));

      for (r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]);
    } else if (4 === arguments.length) for (e = r.slice(arguments[1], arguments[2]), n = arguments[3], i = function (t, e) {
      return n.compare(t, e);
    }, e.sort(i), o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)), r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]);
  }, Gt.asList = function (t) {
    for (var e = new Nt(), n = 0, i = t.length; n < i; n++) e.add(t[n]);

    return e;
  };

  var qt = function () {},
      Bt = {
    P: {
      configurable: !0
    },
    L: {
      configurable: !0
    },
    A: {
      configurable: !0
    },
    FALSE: {
      configurable: !0
    },
    TRUE: {
      configurable: !0
    },
    DONTCARE: {
      configurable: !0
    },
    SYM_FALSE: {
      configurable: !0
    },
    SYM_TRUE: {
      configurable: !0
    },
    SYM_DONTCARE: {
      configurable: !0
    },
    SYM_P: {
      configurable: !0
    },
    SYM_L: {
      configurable: !0
    },
    SYM_A: {
      configurable: !0
    }
  };

  Bt.P.get = function () {
    return 0;
  }, Bt.L.get = function () {
    return 1;
  }, Bt.A.get = function () {
    return 2;
  }, Bt.FALSE.get = function () {
    return -1;
  }, Bt.TRUE.get = function () {
    return -2;
  }, Bt.DONTCARE.get = function () {
    return -3;
  }, Bt.SYM_FALSE.get = function () {
    return "F";
  }, Bt.SYM_TRUE.get = function () {
    return "T";
  }, Bt.SYM_DONTCARE.get = function () {
    return "*";
  }, Bt.SYM_P.get = function () {
    return "0";
  }, Bt.SYM_L.get = function () {
    return "1";
  }, Bt.SYM_A.get = function () {
    return "2";
  }, qt.prototype.interfaces_ = function () {
    return [];
  }, qt.prototype.getClass = function () {
    return qt;
  }, qt.toDimensionSymbol = function (t) {
    switch (t) {
      case qt.FALSE:
        return qt.SYM_FALSE;

      case qt.TRUE:
        return qt.SYM_TRUE;

      case qt.DONTCARE:
        return qt.SYM_DONTCARE;

      case qt.P:
        return qt.SYM_P;

      case qt.L:
        return qt.SYM_L;

      case qt.A:
        return qt.SYM_A;
    }

    throw new m("Unknown dimension value: " + t);
  }, qt.toDimensionValue = function (t) {
    switch (A.toUpperCase(t)) {
      case qt.SYM_FALSE:
        return qt.FALSE;

      case qt.SYM_TRUE:
        return qt.TRUE;

      case qt.SYM_DONTCARE:
        return qt.DONTCARE;

      case qt.SYM_P:
        return qt.P;

      case qt.SYM_L:
        return qt.L;

      case qt.SYM_A:
        return qt.A;
    }

    throw new m("Unknown dimension symbol: " + t);
  }, Object.defineProperties(qt, Bt);

  var Vt = function () {};

  Vt.prototype.filter = function (t) {}, Vt.prototype.interfaces_ = function () {
    return [];
  }, Vt.prototype.getClass = function () {
    return Vt;
  };

  var Ut = function () {};

  Ut.prototype.filter = function (t, e) {}, Ut.prototype.isDone = function () {}, Ut.prototype.isGeometryChanged = function () {}, Ut.prototype.interfaces_ = function () {
    return [];
  }, Ut.prototype.getClass = function () {
    return Ut;
  };

  var zt = function (t) {
    function e(e, n) {
      if (t.call(this, n), this._geometries = e || [], t.hasNullElements(this._geometries)) throw new m("geometries must not contain null elements");
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.computeEnvelopeInternal = function () {
      for (var t = new j(), e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());

      return t;
    }, e.prototype.getGeometryN = function (t) {
      return this._geometries[t];
    }, e.prototype.getSortIndex = function () {
      return t.SORTINDEX_GEOMETRYCOLLECTION;
    }, e.prototype.getCoordinates = function () {
      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (var i = this._geometries[n].getCoordinates(), r = 0; r < i.length; r++) t[++e] = i[r];

      return t;
    }, e.prototype.getArea = function () {
      for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();

      return t;
    }, e.prototype.equalsExact = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        if (!this.isEquivalentClass(e)) return !1;
        var i = e;
        if (this._geometries.length !== i._geometries.length) return !1;

        for (var r = 0; r < this._geometries.length; r++) if (!this._geometries[r].equalsExact(i._geometries[r], n)) return !1;

        return !0;
      }

      return t.prototype.equalsExact.apply(this, arguments);
    }, e.prototype.normalize = function () {
      for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();

      Gt.sort(this._geometries);
    }, e.prototype.getCoordinate = function () {
      return this.isEmpty() ? null : this._geometries[0].getCoordinate();
    }, e.prototype.getBoundaryDimension = function () {
      for (var t = qt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());

      return t;
    }, e.prototype.getDimension = function () {
      for (var t = qt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());

      return t;
    }, e.prototype.getLength = function () {
      for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();

      return t;
    }, e.prototype.getNumPoints = function () {
      for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();

      return t;
    }, e.prototype.getNumGeometries = function () {
      return this._geometries.length;
    }, e.prototype.reverse = function () {
      for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();

      return this.getFactory().createGeometryCollection(e);
    }, e.prototype.compareToSameClass = function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = new f(Gt.asList(this._geometries)),
            n = new f(Gt.asList(t._geometries));
        return this.compare(e, n);
      }

      if (2 === arguments.length) {
        for (var i = arguments[0], r = arguments[1], o = i, s = this.getNumGeometries(), a = o.getNumGeometries(), u = 0; u < s && u < a;) {
          var l = this.getGeometryN(u),
              c = o.getGeometryN(u),
              p = l.compareToSameClass(c, r);
          if (0 !== p) return p;
          u++;
        }

        return u < s ? 1 : u < a ? -1 : 0;
      }
    }, e.prototype.apply = function () {
      if (T(arguments[0], ft)) for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t);else if (T(arguments[0], Ut)) {
        var n = arguments[0];
        if (0 === this._geometries.length) return null;

        for (var i = 0; i < this._geometries.length && (this._geometries[i].apply(n), !n.isDone()); i++);

        n.isGeometryChanged() && this.geometryChanged();
      } else if (T(arguments[0], Vt)) {
        var r = arguments[0];
        r.filter(this);

        for (var o = 0; o < this._geometries.length; o++) this._geometries[o].apply(r);
      } else if (T(arguments[0], lt)) {
        var s = arguments[0];
        s.filter(this);

        for (var a = 0; a < this._geometries.length; a++) this._geometries[a].apply(s);
      }
    }, e.prototype.getBoundary = function () {
      return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;
    }, e.prototype.clone = function () {
      var e = t.prototype.clone.call(this);
      e._geometries = new Array(this._geometries.length).fill(null);

      for (var n = 0; n < this._geometries.length; n++) e._geometries[n] = this._geometries[n].clone();

      return e;
    }, e.prototype.getGeometryType = function () {
      return "GeometryCollection";
    }, e.prototype.copy = function () {
      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();

      return new e(t, this._factory);
    }, e.prototype.isEmpty = function () {
      for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;

      return !0;
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, n.serialVersionUID.get = function () {
      return -0x4f07bcb1f857d800;
    }, Object.defineProperties(e, n), e;
  }(ct),
      Xt = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.getSortIndex = function () {
      return ct.SORTINDEX_MULTILINESTRING;
    }, e.prototype.equalsExact = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);
      }

      return t.prototype.equalsExact.apply(this, arguments);
    }, e.prototype.getBoundaryDimension = function () {
      return this.isClosed() ? qt.FALSE : 0;
    }, e.prototype.isClosed = function () {
      if (this.isEmpty()) return !1;

      for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;

      return !0;
    }, e.prototype.getDimension = function () {
      return 1;
    }, e.prototype.reverse = function () {
      for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[t - 1 - n] = this._geometries[n].reverse();

      return this.getFactory().createMultiLineString(e);
    }, e.prototype.getBoundary = function () {
      return new Yt(this).getBoundary();
    }, e.prototype.getGeometryType = function () {
      return "MultiLineString";
    }, e.prototype.copy = function () {
      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();

      return new e(t, this._factory);
    }, e.prototype.interfaces_ = function () {
      return [At];
    }, e.prototype.getClass = function () {
      return e;
    }, n.serialVersionUID.get = function () {
      return 0x7155d2ab4afa8000;
    }, Object.defineProperties(e, n), e;
  }(zt),
      Yt = function () {
    if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
      var t = arguments[0],
          e = gt.MOD2_BOUNDARY_RULE;
      this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e;
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      this._geom = n, this._geomFact = n.getFactory(), this._bnRule = i;
    }
  };

  Yt.prototype.boundaryMultiLineString = function (t) {
    if (this._geom.isEmpty()) return this.getEmptyMultiPoint();
    var e = this.computeBoundaryCoordinates(t);
    return 1 === e.length ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e);
  }, Yt.prototype.getBoundary = function () {
    return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
  }, Yt.prototype.boundaryLineString = function (t) {
    if (this._geom.isEmpty()) return this.getEmptyMultiPoint();

    if (t.isClosed()) {
      return this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint();
    }

    return this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);
  }, Yt.prototype.getEmptyMultiPoint = function () {
    return this._geomFact.createMultiPoint();
  }, Yt.prototype.computeBoundaryCoordinates = function (t) {
    var e = new Nt();
    this._endpointMap = new p();

    for (var n = 0; n < t.getNumGeometries(); n++) {
      var i = t.getGeometryN(n);
      0 !== i.getNumPoints() && (this.addEndpoint(i.getCoordinateN(0)), this.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)));
    }

    for (var r = this._endpointMap.entrySet().iterator(); r.hasNext();) {
      var o = r.next(),
          s = o.getValue().count;
      this._bnRule.isInBoundary(s) && e.add(o.getKey());
    }

    return Lt.toCoordinateArray(e);
  }, Yt.prototype.addEndpoint = function (t) {
    var e = this._endpointMap.get(t);

    null === e && (e = new kt(), this._endpointMap.put(t, e)), e.count++;
  }, Yt.prototype.interfaces_ = function () {
    return [];
  }, Yt.prototype.getClass = function () {
    return Yt;
  }, Yt.getBoundary = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return new Yt(t).getBoundary();
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return new Yt(e, n).getBoundary();
    }
  };

  var kt = function () {
    this.count = null;
  };

  kt.prototype.interfaces_ = function () {
    return [];
  }, kt.prototype.getClass = function () {
    return kt;
  };

  var jt = function () {},
      Ht = {
    NEWLINE: {
      configurable: !0
    },
    SIMPLE_ORDINATE_FORMAT: {
      configurable: !0
    }
  };

  jt.prototype.interfaces_ = function () {
    return [];
  }, jt.prototype.getClass = function () {
    return jt;
  }, jt.chars = function (t, e) {
    for (var n = new Array(e).fill(null), i = 0; i < e; i++) n[i] = t;

    return String(n);
  }, jt.getStackTrace = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = new function () {}(),
          n = new function () {}(e);
      return t.printStackTrace(n), e.toString();
    }

    if (2 === arguments.length) {
      for (var i = arguments[0], r = arguments[1], o = "", s = new function () {}(new function () {}(jt.getStackTrace(i))), a = 0; a < r; a++) try {
        o += s.readLine() + jt.NEWLINE;
      } catch (t) {
        if (!(t instanceof g)) throw t;
        et.shouldNeverReachHere();
      }

      return o;
    }
  }, jt.split = function (t, e) {
    for (var n = e.length, i = new Nt(), r = "" + t, o = r.indexOf(e); o >= 0;) {
      var s = r.substring(0, o);
      i.add(s), o = (r = r.substring(o + n)).indexOf(e);
    }

    r.length > 0 && i.add(r);

    for (var a = new Array(i.size()).fill(null), u = 0; u < a.length; u++) a[u] = i.get(u);

    return a;
  }, jt.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return jt.SIMPLE_ORDINATE_FORMAT.format(t);
    }
  }, jt.spaces = function (t) {
    return jt.chars(" ", t);
  }, Ht.NEWLINE.get = function () {
    return Y.getProperty("line.separator");
  }, Ht.SIMPLE_ORDINATE_FORMAT.get = function () {
    return new function () {}("0.#");
  }, Object.defineProperties(jt, Ht);

  var Wt = function () {};

  Wt.prototype.interfaces_ = function () {
    return [];
  }, Wt.prototype.getClass = function () {
    return Wt;
  }, Wt.copyCoord = function (t, e, n, i) {
    for (var r = Math.min(t.getDimension(), n.getDimension()), o = 0; o < r; o++) n.setOrdinate(i, o, t.getOrdinate(e, o));
  }, Wt.isRing = function (t) {
    var e = t.size();
    return 0 === e || !(e <= 3) && t.getOrdinate(0, V.X) === t.getOrdinate(e - 1, V.X) && t.getOrdinate(0, V.Y) === t.getOrdinate(e - 1, V.Y);
  }, Wt.isEqual = function (t, e) {
    var n = t.size();
    if (n !== e.size()) return !1;

    for (var i = Math.min(t.getDimension(), e.getDimension()), r = 0; r < n; r++) for (var o = 0; o < i; o++) {
      var s = t.getOrdinate(r, o),
          a = e.getOrdinate(r, o);
      if (t.getOrdinate(r, o) !== e.getOrdinate(r, o) && (!v.isNaN(s) || !v.isNaN(a))) return !1;
    }

    return !0;
  }, Wt.extend = function (t, e, n) {
    var i = t.create(n, e.getDimension()),
        r = e.size();
    if (Wt.copy(e, 0, i, 0, r), r > 0) for (var o = r; o < n; o++) Wt.copy(e, r - 1, i, o, 1);
    return i;
  }, Wt.reverse = function (t) {
    for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) Wt.swap(t, i, e - i);
  }, Wt.swap = function (t, e, n) {
    if (e === n) return null;

    for (var i = 0; i < t.getDimension(); i++) {
      var r = t.getOrdinate(e, i);
      t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r);
    }
  }, Wt.copy = function (t, e, n, i, r) {
    for (var o = 0; o < r; o++) Wt.copyCoord(t, e + o, n, i + o);
  }, Wt.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = t.size();
      if (0 === e) return "()";
      var n = t.getDimension(),
          i = new D();
      i.append("(");

      for (var r = 0; r < e; r++) {
        r > 0 && i.append(" ");

        for (var o = 0; o < n; o++) o > 0 && i.append(","), i.append(jt.toString(t.getOrdinate(r, o)));
      }

      return i.append(")"), i.toString();
    }
  }, Wt.ensureValidRing = function (t, e) {
    var n = e.size();
    if (0 === n) return e;
    if (n <= 3) return Wt.createClosedRing(t, e, 4);
    return e.getOrdinate(0, V.X) === e.getOrdinate(n - 1, V.X) && e.getOrdinate(0, V.Y) === e.getOrdinate(n - 1, V.Y) ? e : Wt.createClosedRing(t, e, n + 1);
  }, Wt.createClosedRing = function (t, e, n) {
    var i = t.create(n, e.getDimension()),
        r = e.size();
    Wt.copy(e, 0, i, 0, r);

    for (var o = r; o < n; o++) Wt.copy(e, 0, i, o, 1);

    return i;
  };

  var Kt = function (t) {
    function e(e, n) {
      t.call(this, n), this._points = null, this.init(e);
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.computeEnvelopeInternal = function () {
      return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());
    }, e.prototype.isRing = function () {
      return this.isClosed() && this.isSimple();
    }, e.prototype.getSortIndex = function () {
      return t.SORTINDEX_LINESTRING;
    }, e.prototype.getCoordinates = function () {
      return this._points.toCoordinateArray();
    }, e.prototype.equalsExact = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        if (!this.isEquivalentClass(e)) return !1;
        var i = e;
        if (this._points.size() !== i._points.size()) return !1;

        for (var r = 0; r < this._points.size(); r++) if (!this.equal(this._points.getCoordinate(r), i._points.getCoordinate(r), n)) return !1;

        return !0;
      }

      return t.prototype.equalsExact.apply(this, arguments);
    }, e.prototype.normalize = function () {
      for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {
        var e = this._points.size() - 1 - t;
        if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) return this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0 && Wt.reverse(this._points), null;
      }
    }, e.prototype.getCoordinate = function () {
      return this.isEmpty() ? null : this._points.getCoordinate(0);
    }, e.prototype.getBoundaryDimension = function () {
      return this.isClosed() ? qt.FALSE : 0;
    }, e.prototype.isClosed = function () {
      return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
    }, e.prototype.getEndPoint = function () {
      return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
    }, e.prototype.getDimension = function () {
      return 1;
    }, e.prototype.getLength = function () {
      return at.computeLength(this._points);
    }, e.prototype.getNumPoints = function () {
      return this._points.size();
    }, e.prototype.reverse = function () {
      var t = this._points.copy();

      Wt.reverse(t);
      return this.getFactory().createLineString(t);
    }, e.prototype.compareToSameClass = function () {
      if (1 === arguments.length) {
        for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) {
          var i = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));

          if (0 !== i) return i;
          e++, n++;
        }

        return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0;
      }

      if (2 === arguments.length) {
        var r = arguments[0];
        return arguments[1].compare(this._points, r._points);
      }
    }, e.prototype.apply = function () {
      if (T(arguments[0], ft)) for (var t = arguments[0], e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e));else if (T(arguments[0], Ut)) {
        var n = arguments[0];
        if (0 === this._points.size()) return null;

        for (var i = 0; i < this._points.size() && (n.filter(this._points, i), !n.isDone()); i++);

        n.isGeometryChanged() && this.geometryChanged();
      } else if (T(arguments[0], Vt)) {
        arguments[0].filter(this);
      } else if (T(arguments[0], lt)) {
        arguments[0].filter(this);
      }
    }, e.prototype.getBoundary = function () {
      return new Yt(this).getBoundary();
    }, e.prototype.isEquivalentClass = function (t) {
      return t instanceof e;
    }, e.prototype.clone = function () {
      var e = t.prototype.clone.call(this);
      return e._points = this._points.clone(), e;
    }, e.prototype.getCoordinateN = function (t) {
      return this._points.getCoordinate(t);
    }, e.prototype.getGeometryType = function () {
      return "LineString";
    }, e.prototype.copy = function () {
      return new e(this._points.copy(), this._factory);
    }, e.prototype.getCoordinateSequence = function () {
      return this._points;
    }, e.prototype.isEmpty = function () {
      return 0 === this._points.size();
    }, e.prototype.init = function (t) {
      if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new m("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
      this._points = t;
    }, e.prototype.isCoordinate = function (t) {
      for (var e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;

      return !1;
    }, e.prototype.getStartPoint = function () {
      return this.isEmpty() ? null : this.getPointN(0);
    }, e.prototype.getPointN = function (t) {
      return this.getFactory().createPoint(this._points.getCoordinate(t));
    }, e.prototype.interfaces_ = function () {
      return [At];
    }, e.prototype.getClass = function () {
      return e;
    }, n.serialVersionUID.get = function () {
      return 0x2b2b51ba435c8e00;
    }, Object.defineProperties(e, n), e;
  }(ct),
      Jt = function () {};

  Jt.prototype.interfaces_ = function () {
    return [];
  }, Jt.prototype.getClass = function () {
    return Jt;
  };

  var Qt = function (t) {
    function e(e, n) {
      t.call(this, n), this._coordinates = e || null, this.init(this._coordinates);
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.computeEnvelopeInternal = function () {
      if (this.isEmpty()) return new j();
      var t = new j();
      return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t;
    }, e.prototype.getSortIndex = function () {
      return t.SORTINDEX_POINT;
    }, e.prototype.getCoordinates = function () {
      return this.isEmpty() ? [] : [this.getCoordinate()];
    }, e.prototype.equalsExact = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        return !!this.isEquivalentClass(e) && (!(!this.isEmpty() || !e.isEmpty()) || this.isEmpty() === e.isEmpty() && this.equal(e.getCoordinate(), this.getCoordinate(), n));
      }

      return t.prototype.equalsExact.apply(this, arguments);
    }, e.prototype.normalize = function () {}, e.prototype.getCoordinate = function () {
      return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
    }, e.prototype.getBoundaryDimension = function () {
      return qt.FALSE;
    }, e.prototype.getDimension = function () {
      return 0;
    }, e.prototype.getNumPoints = function () {
      return this.isEmpty() ? 0 : 1;
    }, e.prototype.reverse = function () {
      return this.copy();
    }, e.prototype.getX = function () {
      if (null === this.getCoordinate()) throw new Error("getX called on empty Point");
      return this.getCoordinate().x;
    }, e.prototype.compareToSameClass = function () {
      if (1 === arguments.length) {
        var t = arguments[0];
        return this.getCoordinate().compareTo(t.getCoordinate());
      }

      if (2 === arguments.length) {
        var e = arguments[0];
        return arguments[1].compare(this._coordinates, e._coordinates);
      }
    }, e.prototype.apply = function () {
      if (T(arguments[0], ft)) {
        var t = arguments[0];
        if (this.isEmpty()) return null;
        t.filter(this.getCoordinate());
      } else if (T(arguments[0], Ut)) {
        var e = arguments[0];
        if (this.isEmpty()) return null;
        e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged();
      } else if (T(arguments[0], Vt)) {
        arguments[0].filter(this);
      } else if (T(arguments[0], lt)) {
        arguments[0].filter(this);
      }
    }, e.prototype.getBoundary = function () {
      return this.getFactory().createGeometryCollection(null);
    }, e.prototype.clone = function () {
      var e = t.prototype.clone.call(this);
      return e._coordinates = this._coordinates.clone(), e;
    }, e.prototype.getGeometryType = function () {
      return "Point";
    }, e.prototype.copy = function () {
      return new e(this._coordinates.copy(), this._factory);
    }, e.prototype.getCoordinateSequence = function () {
      return this._coordinates;
    }, e.prototype.getY = function () {
      if (null === this.getCoordinate()) throw new Error("getY called on empty Point");
      return this.getCoordinate().y;
    }, e.prototype.isEmpty = function () {
      return 0 === this._coordinates.size();
    }, e.prototype.init = function (t) {
      null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t.size() <= 1), this._coordinates = t;
    }, e.prototype.isSimple = function () {
      return !0;
    }, e.prototype.interfaces_ = function () {
      return [Jt];
    }, e.prototype.getClass = function () {
      return e;
    }, n.serialVersionUID.get = function () {
      return 0x44077bad161cbc00;
    }, Object.defineProperties(e, n), e;
  }(ct),
      Zt = function () {};

  Zt.prototype.interfaces_ = function () {
    return [];
  }, Zt.prototype.getClass = function () {
    return Zt;
  };

  var $t = function (t) {
    function e(e, n, i) {
      if (t.call(this, i), this._shell = null, this._holes = null, null === e && (e = this.getFactory().createLinearRing()), null === n && (n = []), t.hasNullElements(n)) throw new m("holes must not contain null elements");
      if (e.isEmpty() && t.hasNonEmptyElements(n)) throw new m("shell is empty but holes are not");
      this._shell = e, this._holes = n;
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.computeEnvelopeInternal = function () {
      return this._shell.getEnvelopeInternal();
    }, e.prototype.getSortIndex = function () {
      return t.SORTINDEX_POLYGON;
    }, e.prototype.getCoordinates = function () {
      if (this.isEmpty()) return [];

      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), i = 0; i < n.length; i++) t[++e] = n[i];

      for (var r = 0; r < this._holes.length; r++) for (var o = this._holes[r].getCoordinates(), s = 0; s < o.length; s++) t[++e] = o[s];

      return t;
    }, e.prototype.getArea = function () {
      var t = 0;
      t += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));

      for (var e = 0; e < this._holes.length; e++) t -= Math.abs(at.signedArea(this._holes[e].getCoordinateSequence()));

      return t;
    }, e.prototype.isRectangle = function () {
      if (0 !== this.getNumInteriorRing()) return !1;
      if (null === this._shell) return !1;
      if (5 !== this._shell.getNumPoints()) return !1;

      for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
        var i = t.getX(n);
        if (i !== e.getMinX() && i !== e.getMaxX()) return !1;
        var r = t.getY(n);
        if (r !== e.getMinY() && r !== e.getMaxY()) return !1;
      }

      for (var o = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) {
        var u = t.getX(a),
            l = t.getY(a);
        if (u !== o === (l !== s)) return !1;
        o = u, s = l;
      }

      return !0;
    }, e.prototype.equalsExact = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        if (!this.isEquivalentClass(e)) return !1;
        var i = e,
            r = this._shell,
            o = i._shell;
        if (!r.equalsExact(o, n)) return !1;
        if (this._holes.length !== i._holes.length) return !1;

        for (var s = 0; s < this._holes.length; s++) if (!this._holes[s].equalsExact(i._holes[s], n)) return !1;

        return !0;
      }

      return t.prototype.equalsExact.apply(this, arguments);
    }, e.prototype.normalize = function () {
      if (0 === arguments.length) {
        this.normalize(this._shell, !0);

        for (var t = 0; t < this._holes.length; t++) this.normalize(this._holes[t], !1);

        Gt.sort(this._holes);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        if (e.isEmpty()) return null;
        var i = new Array(e.getCoordinates().length - 1).fill(null);
        Y.arraycopy(e.getCoordinates(), 0, i, 0, i.length);
        var r = Lt.minCoordinate(e.getCoordinates());
        Lt.scroll(i, r), Y.arraycopy(i, 0, e.getCoordinates(), 0, i.length), e.getCoordinates()[i.length] = i[0], at.isCCW(e.getCoordinates()) === n && Lt.reverse(e.getCoordinates());
      }
    }, e.prototype.getCoordinate = function () {
      return this._shell.getCoordinate();
    }, e.prototype.getNumInteriorRing = function () {
      return this._holes.length;
    }, e.prototype.getBoundaryDimension = function () {
      return 1;
    }, e.prototype.getDimension = function () {
      return 2;
    }, e.prototype.getLength = function () {
      var t = 0;
      t += this._shell.getLength();

      for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();

      return t;
    }, e.prototype.getNumPoints = function () {
      for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();

      return t;
    }, e.prototype.reverse = function () {
      var t = this.copy();
      t._shell = this._shell.copy().reverse(), t._holes = new Array(this._holes.length).fill(null);

      for (var e = 0; e < this._holes.length; e++) t._holes[e] = this._holes[e].copy().reverse();

      return t;
    }, e.prototype.convexHull = function () {
      return this.getExteriorRing().convexHull();
    }, e.prototype.compareToSameClass = function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = this._shell,
            n = t._shell;
        return e.compareToSameClass(n);
      }

      if (2 === arguments.length) {
        var i = arguments[0],
            r = arguments[1],
            o = i,
            s = this._shell,
            a = o._shell,
            u = s.compareToSameClass(a, r);
        if (0 !== u) return u;

        for (var l = this.getNumInteriorRing(), c = o.getNumInteriorRing(), p = 0; p < l && p < c;) {
          var h = this.getInteriorRingN(p),
              f = o.getInteriorRingN(p),
              g = h.compareToSameClass(f, r);
          if (0 !== g) return g;
          p++;
        }

        return p < l ? 1 : p < c ? -1 : 0;
      }
    }, e.prototype.apply = function (t) {
      if (T(t, ft)) {
        this._shell.apply(t);

        for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t);
      } else if (T(t, Ut)) {
        if (this._shell.apply(t), !t.isDone()) for (var n = 0; n < this._holes.length && (this._holes[n].apply(t), !t.isDone()); n++);
        t.isGeometryChanged() && this.geometryChanged();
      } else if (T(t, Vt)) t.filter(this);else if (T(t, lt)) {
        t.filter(this), this._shell.apply(t);

        for (var i = 0; i < this._holes.length; i++) this._holes[i].apply(t);
      }
    }, e.prototype.getBoundary = function () {
      if (this.isEmpty()) return this.getFactory().createMultiLineString();
      var t = new Array(this._holes.length + 1).fill(null);
      t[0] = this._shell;

      for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];

      return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);
    }, e.prototype.clone = function () {
      var e = t.prototype.clone.call(this);
      e._shell = this._shell.clone(), e._holes = new Array(this._holes.length).fill(null);

      for (var n = 0; n < this._holes.length; n++) e._holes[n] = this._holes[n].clone();

      return e;
    }, e.prototype.getGeometryType = function () {
      return "Polygon";
    }, e.prototype.copy = function () {
      for (var t = this._shell.copy(), n = new Array(this._holes.length).fill(null), i = 0; i < n.length; i++) n[i] = this._holes[i].copy();

      return new e(t, n, this._factory);
    }, e.prototype.getExteriorRing = function () {
      return this._shell;
    }, e.prototype.isEmpty = function () {
      return this._shell.isEmpty();
    }, e.prototype.getInteriorRingN = function (t) {
      return this._holes[t];
    }, e.prototype.interfaces_ = function () {
      return [Zt];
    }, e.prototype.getClass = function () {
      return e;
    }, n.serialVersionUID.get = function () {
      return -0x307ffefd8dc97200;
    }, Object.defineProperties(e, n), e;
  }(ct),
      te = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.getSortIndex = function () {
      return ct.SORTINDEX_MULTIPOINT;
    }, e.prototype.isValid = function () {
      return !0;
    }, e.prototype.equalsExact = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);
      }

      return t.prototype.equalsExact.apply(this, arguments);
    }, e.prototype.getCoordinate = function () {
      if (1 === arguments.length) {
        var e = arguments[0];
        return this._geometries[e].getCoordinate();
      }

      return t.prototype.getCoordinate.apply(this, arguments);
    }, e.prototype.getBoundaryDimension = function () {
      return qt.FALSE;
    }, e.prototype.getDimension = function () {
      return 0;
    }, e.prototype.getBoundary = function () {
      return this.getFactory().createGeometryCollection(null);
    }, e.prototype.getGeometryType = function () {
      return "MultiPoint";
    }, e.prototype.copy = function () {
      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();

      return new e(t, this._factory);
    }, e.prototype.interfaces_ = function () {
      return [Jt];
    }, e.prototype.getClass = function () {
      return e;
    }, n.serialVersionUID.get = function () {
      return -0x6fb1ed4162e0fc00;
    }, Object.defineProperties(e, n), e;
  }(zt),
      ee = function (t) {
    function e(e, n) {
      e instanceof C && n instanceof _e && (e = n.getCoordinateSequenceFactory().create(e)), t.call(this, e, n), this.validateConstruction();
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      MINIMUM_VALID_SIZE: {
        configurable: !0
      },
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.getSortIndex = function () {
      return ct.SORTINDEX_LINEARRING;
    }, e.prototype.getBoundaryDimension = function () {
      return qt.FALSE;
    }, e.prototype.isClosed = function () {
      return !!this.isEmpty() || t.prototype.isClosed.call(this);
    }, e.prototype.reverse = function () {
      var t = this._points.copy();

      Wt.reverse(t);
      return this.getFactory().createLinearRing(t);
    }, e.prototype.validateConstruction = function () {
      if (!this.isEmpty() && !t.prototype.isClosed.call(this)) throw new m("Points of LinearRing do not form a closed linestring");
      if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE) throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
    }, e.prototype.getGeometryType = function () {
      return "LinearRing";
    }, e.prototype.copy = function () {
      return new e(this._points.copy(), this._factory);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, n.MINIMUM_VALID_SIZE.get = function () {
      return 4;
    }, n.serialVersionUID.get = function () {
      return -0x3b229e262367a600;
    }, Object.defineProperties(e, n), e;
  }(Kt),
      ne = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      serialVersionUID: {
        configurable: !0
      }
    };
    return e.prototype.getSortIndex = function () {
      return ct.SORTINDEX_MULTIPOLYGON;
    }, e.prototype.equalsExact = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);
      }

      return t.prototype.equalsExact.apply(this, arguments);
    }, e.prototype.getBoundaryDimension = function () {
      return 1;
    }, e.prototype.getDimension = function () {
      return 2;
    }, e.prototype.reverse = function () {
      for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();

      return this.getFactory().createMultiPolygon(e);
    }, e.prototype.getBoundary = function () {
      if (this.isEmpty()) return this.getFactory().createMultiLineString();

      for (var t = new Nt(), e = 0; e < this._geometries.length; e++) for (var n = this._geometries[e].getBoundary(), i = 0; i < n.getNumGeometries(); i++) t.add(n.getGeometryN(i));

      var r = new Array(t.size()).fill(null);
      return this.getFactory().createMultiLineString(t.toArray(r));
    }, e.prototype.getGeometryType = function () {
      return "MultiPolygon";
    }, e.prototype.copy = function () {
      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();

      return new e(t, this._factory);
    }, e.prototype.interfaces_ = function () {
      return [Zt];
    }, e.prototype.getClass = function () {
      return e;
    }, n.serialVersionUID.get = function () {
      return -0x7a5aa1369171980;
    }, Object.defineProperties(e, n), e;
  }(zt),
      ie = function (t) {
    this._factory = t || null, this._isUserDataCopied = !1;
  },
      re = {
    NoOpGeometryOperation: {
      configurable: !0
    },
    CoordinateOperation: {
      configurable: !0
    },
    CoordinateSequenceOperation: {
      configurable: !0
    }
  };

  ie.prototype.setCopyUserData = function (t) {
    this._isUserDataCopied = t;
  }, ie.prototype.edit = function (t, e) {
    if (null === t) return null;
    var n = this.editInternal(t, e);
    return this._isUserDataCopied && n.setUserData(t.getUserData()), n;
  }, ie.prototype.editInternal = function (t, e) {
    return null === this._factory && (this._factory = t.getFactory()), t instanceof zt ? this.editGeometryCollection(t, e) : t instanceof $t ? this.editPolygon(t, e) : t instanceof Qt ? e.edit(t, this._factory) : t instanceof Kt ? e.edit(t, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null);
  }, ie.prototype.editGeometryCollection = function (t, e) {
    for (var n = e.edit(t, this._factory), i = new Nt(), r = 0; r < n.getNumGeometries(); r++) {
      var o = this.edit(n.getGeometryN(r), e);
      null === o || o.isEmpty() || i.add(o);
    }

    return n.getClass() === te ? this._factory.createMultiPoint(i.toArray([])) : n.getClass() === Xt ? this._factory.createMultiLineString(i.toArray([])) : n.getClass() === ne ? this._factory.createMultiPolygon(i.toArray([])) : this._factory.createGeometryCollection(i.toArray([]));
  }, ie.prototype.editPolygon = function (t, e) {
    var n = e.edit(t, this._factory);
    if (null === n && (n = this._factory.createPolygon(null)), n.isEmpty()) return n;
    var i = this.edit(n.getExteriorRing(), e);
    if (null === i || i.isEmpty()) return this._factory.createPolygon();

    for (var r = new Nt(), o = 0; o < n.getNumInteriorRing(); o++) {
      var s = this.edit(n.getInteriorRingN(o), e);
      null === s || s.isEmpty() || r.add(s);
    }

    return this._factory.createPolygon(i, r.toArray([]));
  }, ie.prototype.interfaces_ = function () {
    return [];
  }, ie.prototype.getClass = function () {
    return ie;
  }, ie.GeometryEditorOperation = function () {}, re.NoOpGeometryOperation.get = function () {
    return oe;
  }, re.CoordinateOperation.get = function () {
    return se;
  }, re.CoordinateSequenceOperation.get = function () {
    return ae;
  }, Object.defineProperties(ie, re);

  var oe = function () {};

  oe.prototype.edit = function (t, e) {
    return t;
  }, oe.prototype.interfaces_ = function () {
    return [ie.GeometryEditorOperation];
  }, oe.prototype.getClass = function () {
    return oe;
  };

  var se = function () {};

  se.prototype.edit = function (t, e) {
    var n = this.editCoordinates(t.getCoordinates(), t);
    return null === n ? t : t instanceof ee ? e.createLinearRing(n) : t instanceof Kt ? e.createLineString(n) : t instanceof Qt ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t;
  }, se.prototype.interfaces_ = function () {
    return [ie.GeometryEditorOperation];
  }, se.prototype.getClass = function () {
    return se;
  };

  var ae = function () {};

  ae.prototype.edit = function (t, e) {
    return t instanceof ee ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Kt ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Qt ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;
  }, ae.prototype.interfaces_ = function () {
    return [ie.GeometryEditorOperation];
  }, ae.prototype.getClass = function () {
    return ae;
  };

  var ue = function () {
    if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
      if (arguments[0] instanceof Array) this._coordinates = arguments[0], this._dimension = 3;else if (Number.isInteger(arguments[0])) {
        var t = arguments[0];
        this._coordinates = new Array(t).fill(null);

        for (var e = 0; e < t; e++) this._coordinates[e] = new C();
      } else if (T(arguments[0], V)) {
        var n = arguments[0];
        if (null === n) return this._coordinates = new Array(0).fill(null), null;
        this._dimension = n.getDimension(), this._coordinates = new Array(n.size()).fill(null);

        for (var i = 0; i < this._coordinates.length; i++) this._coordinates[i] = n.getCoordinateCopy(i);
      }
    } else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
      var r = arguments[0],
          o = arguments[1];
      this._coordinates = r, this._dimension = o, null === r && (this._coordinates = new Array(0).fill(null));
    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var s = arguments[0],
          a = arguments[1];
      this._coordinates = new Array(s).fill(null), this._dimension = a;

      for (var u = 0; u < s; u++) this._coordinates[u] = new C();
    }
  },
      le = {
    serialVersionUID: {
      configurable: !0
    }
  };

  ue.prototype.setOrdinate = function (t, e, n) {
    switch (e) {
      case V.X:
        this._coordinates[t].x = n;
        break;

      case V.Y:
        this._coordinates[t].y = n;
        break;

      case V.Z:
        this._coordinates[t].z = n;
        break;

      default:
        throw new m("invalid ordinateIndex");
    }
  }, ue.prototype.size = function () {
    return this._coordinates.length;
  }, ue.prototype.getOrdinate = function (t, e) {
    switch (e) {
      case V.X:
        return this._coordinates[t].x;

      case V.Y:
        return this._coordinates[t].y;

      case V.Z:
        return this._coordinates[t].z;
    }

    return v.NaN;
  }, ue.prototype.getCoordinate = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this._coordinates[t];
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      n.x = this._coordinates[e].x, n.y = this._coordinates[e].y, n.z = this._coordinates[e].z;
    }
  }, ue.prototype.getCoordinateCopy = function (t) {
    return new C(this._coordinates[t]);
  }, ue.prototype.getDimension = function () {
    return this._dimension;
  }, ue.prototype.getX = function (t) {
    return this._coordinates[t].x;
  }, ue.prototype.clone = function () {
    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].clone();

    return new ue(t, this._dimension);
  }, ue.prototype.expandEnvelope = function (t) {
    for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);

    return t;
  }, ue.prototype.copy = function () {
    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].copy();

    return new ue(t, this._dimension);
  }, ue.prototype.toString = function () {
    if (this._coordinates.length > 0) {
      var t = new D(17 * this._coordinates.length);
      t.append("("), t.append(this._coordinates[0]);

      for (var e = 1; e < this._coordinates.length; e++) t.append(", "), t.append(this._coordinates[e]);

      return t.append(")"), t.toString();
    }

    return "()";
  }, ue.prototype.getY = function (t) {
    return this._coordinates[t].y;
  }, ue.prototype.toCoordinateArray = function () {
    return this._coordinates;
  }, ue.prototype.interfaces_ = function () {
    return [V, e];
  }, ue.prototype.getClass = function () {
    return ue;
  }, le.serialVersionUID.get = function () {
    return -0xcb44a778db18e00;
  }, Object.defineProperties(ue, le);

  var ce = function () {},
      pe = {
    serialVersionUID: {
      configurable: !0
    },
    instanceObject: {
      configurable: !0
    }
  };

  ce.prototype.readResolve = function () {
    return ce.instance();
  }, ce.prototype.create = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        var t = arguments[0];
        return new ue(t);
      }

      if (T(arguments[0], V)) {
        var e = arguments[0];
        return new ue(e);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      return i > 3 && (i = 3), i < 2 ? new ue(n) : new ue(n, i);
    }
  }, ce.prototype.interfaces_ = function () {
    return [b, e];
  }, ce.prototype.getClass = function () {
    return ce;
  }, ce.instance = function () {
    return ce.instanceObject;
  }, pe.serialVersionUID.get = function () {
    return -0x38e49fa6cf6f2e00;
  }, pe.instanceObject.get = function () {
    return new ce();
  }, Object.defineProperties(ce, pe);

  var he = function (t) {
    function e() {
      t.call(this), this.map_ = new Map();
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function (t) {
      return this.map_.get(t) || null;
    }, e.prototype.put = function (t, e) {
      return this.map_.set(t, e), e;
    }, e.prototype.values = function () {
      for (var t = new Nt(), e = this.map_.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();

      return t;
    }, e.prototype.entrySet = function () {
      var t = new Pt();
      return this.map_.entries().forEach(function (e) {
        return t.add(e);
      }), t;
    }, e.prototype.size = function () {
      return this.map_.size();
    }, e;
  }(Tt),
      fe = function t() {
    if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof de) {
      var e = arguments[0];
      this._modelType = e, e === t.FIXED && this.setScale(1);
    } else if ("number" == typeof arguments[0]) {
      var n = arguments[0];
      this._modelType = t.FIXED, this.setScale(n);
    } else if (arguments[0] instanceof t) {
      var i = arguments[0];
      this._modelType = i._modelType, this._scale = i._scale;
    }
  },
      ge = {
    serialVersionUID: {
      configurable: !0
    },
    maximumPreciseValue: {
      configurable: !0
    }
  };

  fe.prototype.equals = function (t) {
    if (!(t instanceof fe)) return !1;
    var e = t;
    return this._modelType === e._modelType && this._scale === e._scale;
  }, fe.prototype.compareTo = function (t) {
    var e = t,
        n = this.getMaximumSignificantDigits(),
        i = e.getMaximumSignificantDigits();
    return new M(n).compareTo(new M(i));
  }, fe.prototype.getScale = function () {
    return this._scale;
  }, fe.prototype.isFloating = function () {
    return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;
  }, fe.prototype.getType = function () {
    return this._modelType;
  }, fe.prototype.toString = function () {
    var t = "UNKNOWN";
    return this._modelType === fe.FLOATING ? t = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === fe.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t;
  }, fe.prototype.makePrecise = function () {
    if ("number" == typeof arguments[0]) {
      var t = arguments[0];
      if (v.isNaN(t)) return t;

      if (this._modelType === fe.FLOATING_SINGLE) {
        return t;
      }

      return this._modelType === fe.FIXED ? Math.round(t * this._scale) / this._scale : t;
    }

    if (arguments[0] instanceof C) {
      var e = arguments[0];
      if (this._modelType === fe.FLOATING) return null;
      e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y);
    }
  }, fe.prototype.getMaximumSignificantDigits = function () {
    var t = 16;
    return this._modelType === fe.FLOATING ? t = 16 : this._modelType === fe.FLOATING_SINGLE ? t = 6 : this._modelType === fe.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;
  }, fe.prototype.setScale = function (t) {
    this._scale = Math.abs(t);
  }, fe.prototype.interfaces_ = function () {
    return [e, E];
  }, fe.prototype.getClass = function () {
    return fe;
  }, fe.mostPrecise = function (t, e) {
    return t.compareTo(e) >= 0 ? t : e;
  }, ge.serialVersionUID.get = function () {
    return 0x6bee6404e9a25c00;
  }, ge.maximumPreciseValue.get = function () {
    return 9007199254740992;
  }, Object.defineProperties(fe, ge);

  var de = function t(e) {
    this._name = e || null, t.nameToTypeMap.put(e, this);
  },
      ye = {
    serialVersionUID: {
      configurable: !0
    },
    nameToTypeMap: {
      configurable: !0
    }
  };

  de.prototype.readResolve = function () {
    return de.nameToTypeMap.get(this._name);
  }, de.prototype.toString = function () {
    return this._name;
  }, de.prototype.interfaces_ = function () {
    return [e];
  }, de.prototype.getClass = function () {
    return de;
  }, ye.serialVersionUID.get = function () {
    return -552860263173159e4;
  }, ye.nameToTypeMap.get = function () {
    return new he();
  }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de("FIXED"), fe.FLOATING = new de("FLOATING"), fe.FLOATING_SINGLE = new de("FLOATING SINGLE");

  var _e = function t() {
    this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
  },
      me = {
    serialVersionUID: {
      configurable: !0
    }
  };

  _e.prototype.toGeometry = function (t) {
    return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new C(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new C(t.getMinX(), t.getMinY()), new C(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t.getMinX(), t.getMinY()), new C(t.getMinX(), t.getMaxY()), new C(t.getMaxX(), t.getMaxY()), new C(t.getMaxX(), t.getMinY()), new C(t.getMinX(), t.getMinY())]), null);
  }, _e.prototype.createLineString = function (t) {
    return t ? t instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t), this) : T(t, V) ? new Kt(t, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);
  }, _e.prototype.createMultiLineString = function () {
    if (0 === arguments.length) return new Xt(null, this);

    if (1 === arguments.length) {
      var t = arguments[0];
      return new Xt(t, this);
    }
  }, _e.prototype.buildGeometry = function (t) {
    for (var e = null, n = !1, i = !1, r = t.iterator(); r.hasNext();) {
      var o = r.next(),
          s = o.getClass();
      null === e && (e = s), s !== e && (n = !0), o.isGeometryCollectionOrDerived() && (i = !0);
    }

    if (null === e) return this.createGeometryCollection();
    if (n || i) return this.createGeometryCollection(_e.toGeometryArray(t));
    var a = t.iterator().next();

    if (t.size() > 1) {
      if (a instanceof $t) return this.createMultiPolygon(_e.toPolygonArray(t));
      if (a instanceof Kt) return this.createMultiLineString(_e.toLineStringArray(t));
      if (a instanceof Qt) return this.createMultiPoint(_e.toPointArray(t));
      et.shouldNeverReachHere("Unhandled class: " + a.getClass().getName());
    }

    return a;
  }, _e.prototype.createMultiPointFromCoords = function (t) {
    return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
  }, _e.prototype.createPoint = function () {
    if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));

    if (1 === arguments.length) {
      if (arguments[0] instanceof C) {
        var t = arguments[0];
        return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);
      }

      if (T(arguments[0], V)) {
        var e = arguments[0];
        return new Qt(e, this);
      }
    }
  }, _e.prototype.getCoordinateSequenceFactory = function () {
    return this._coordinateSequenceFactory;
  }, _e.prototype.createPolygon = function () {
    if (0 === arguments.length) return new $t(null, null, this);

    if (1 === arguments.length) {
      if (T(arguments[0], V)) {
        var t = arguments[0];
        return this.createPolygon(this.createLinearRing(t));
      }

      if (arguments[0] instanceof Array) {
        var e = arguments[0];
        return this.createPolygon(this.createLinearRing(e));
      }

      if (arguments[0] instanceof ee) {
        var n = arguments[0];
        return this.createPolygon(n, null);
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
          r = arguments[1];
      return new $t(i, r, this);
    }
  }, _e.prototype.getSRID = function () {
    return this._SRID;
  }, _e.prototype.createGeometryCollection = function () {
    if (0 === arguments.length) return new zt(null, this);

    if (1 === arguments.length) {
      var t = arguments[0];
      return new zt(t, this);
    }
  }, _e.prototype.createGeometry = function (t) {
    return new ie(this).edit(t, {
      edit: function () {
        if (2 === arguments.length) {
          var t = arguments[0];
          return this._coordinateSequenceFactory.create(t);
        }
      }
    });
  }, _e.prototype.getPrecisionModel = function () {
    return this._precisionModel;
  }, _e.prototype.createLinearRing = function () {
    if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));

    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        var t = arguments[0];
        return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
      }

      if (T(arguments[0], V)) {
        var e = arguments[0];
        return new ee(e, this);
      }
    }
  }, _e.prototype.createMultiPolygon = function () {
    if (0 === arguments.length) return new ne(null, this);

    if (1 === arguments.length) {
      var t = arguments[0];
      return new ne(t, this);
    }
  }, _e.prototype.createMultiPoint = function () {
    if (0 === arguments.length) return new te(null, this);

    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        var t = arguments[0];
        return new te(t, this);
      }

      if (arguments[0] instanceof Array) {
        var e = arguments[0];
        return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null);
      }

      if (T(arguments[0], V)) {
        var n = arguments[0];
        if (null === n) return this.createMultiPoint(new Array(0).fill(null));

        for (var i = new Array(n.size()).fill(null), r = 0; r < n.size(); r++) {
          var o = this.getCoordinateSequenceFactory().create(1, n.getDimension());
          Wt.copy(n, r, o, 0, 1), i[r] = this.createPoint(o);
        }

        return this.createMultiPoint(i);
      }
    }
  }, _e.prototype.interfaces_ = function () {
    return [e];
  }, _e.prototype.getClass = function () {
    return _e;
  }, _e.toMultiPolygonArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.toGeometryArray = function (t) {
    if (null === t) return null;
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.getDefaultCoordinateSequenceFactory = function () {
    return ce.instance();
  }, _e.toMultiLineStringArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.toLineStringArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.toMultiPointArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.toLinearRingArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.toPointArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.toPolygonArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }, _e.createPointFromInternalCoord = function (t, e) {
    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
  }, me.serialVersionUID.get = function () {
    return -0x5ea75f2051eeb400;
  }, Object.defineProperties(_e, me);

  var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"],
      Ie = function (t) {
    this.geometryFactory = t || new _e();
  };

  Ie.prototype.read = function (t) {
    var e,
        n = (e = "string" == typeof t ? JSON.parse(t) : t).type;
    if (!Ee[n]) throw new Error("Unknown GeoJSON type: " + e.type);
    return -1 !== ve.indexOf(n) ? Ee[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? Ee[n].apply(this, [e.geometries]) : Ee[n].apply(this, [e]);
  }, Ie.prototype.write = function (t) {
    var e = t.getGeometryType();
    if (!xe[e]) throw new Error("Geometry is not supported");
    return xe[e].apply(this, [t]);
  };

  var Ee = {
    Feature: function (t) {
      var e = {};

      for (var n in t) e[n] = t[n];

      if (t.geometry) {
        var i = t.geometry.type;
        if (!Ee[i]) throw new Error("Unknown GeoJSON type: " + t.type);
        e.geometry = this.read(t.geometry);
      }

      return t.bbox && (e.bbox = Ee.bbox.apply(this, [t.bbox])), e;
    },
    FeatureCollection: function (t) {
      var e = {};

      if (t.features) {
        e.features = [];

        for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]));
      }

      return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e;
    },
    coordinates: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) {
        var i = t[n];
        e.push(new C(i[0], i[1]));
      }

      return e;
    },
    bbox: function (t) {
      return this.geometryFactory.createLinearRing([new C(t[0], t[1]), new C(t[2], t[1]), new C(t[2], t[3]), new C(t[0], t[3]), new C(t[0], t[1])]);
    },
    Point: function (t) {
      var e = new C(t[0], t[1]);
      return this.geometryFactory.createPoint(e);
    },
    MultiPoint: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) e.push(Ee.Point.apply(this, [t[n]]));

      return this.geometryFactory.createMultiPoint(e);
    },
    LineString: function (t) {
      var e = Ee.coordinates.apply(this, [t]);
      return this.geometryFactory.createLineString(e);
    },
    MultiLineString: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) e.push(Ee.LineString.apply(this, [t[n]]));

      return this.geometryFactory.createMultiLineString(e);
    },
    Polygon: function (t) {
      for (var e = Ee.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {
        var o = t[r],
            s = Ee.coordinates.apply(this, [o]),
            a = this.geometryFactory.createLinearRing(s);
        i.push(a);
      }

      return this.geometryFactory.createPolygon(n, i);
    },
    MultiPolygon: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) {
        var i = t[n];
        e.push(Ee.Polygon.apply(this, [i]));
      }

      return this.geometryFactory.createMultiPolygon(e);
    },
    GeometryCollection: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) {
        var i = t[n];
        e.push(this.read(i));
      }

      return this.geometryFactory.createGeometryCollection(e);
    }
  },
      xe = {
    coordinate: function (t) {
      return [t.x, t.y];
    },
    Point: function (t) {
      return {
        type: "Point",
        coordinates: xe.coordinate.apply(this, [t.getCoordinate()])
      };
    },
    MultiPoint: function (t) {
      for (var e = [], n = 0; n < t._geometries.length; ++n) {
        var i = t._geometries[n],
            r = xe.Point.apply(this, [i]);
        e.push(r.coordinates);
      }

      return {
        type: "MultiPoint",
        coordinates: e
      };
    },
    LineString: function (t) {
      for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {
        var r = n[i];
        e.push(xe.coordinate.apply(this, [r]));
      }

      return {
        type: "LineString",
        coordinates: e
      };
    },
    MultiLineString: function (t) {
      for (var e = [], n = 0; n < t._geometries.length; ++n) {
        var i = t._geometries[n],
            r = xe.LineString.apply(this, [i]);
        e.push(r.coordinates);
      }

      return {
        type: "MultiLineString",
        coordinates: e
      };
    },
    Polygon: function (t) {
      var e = [],
          n = xe.LineString.apply(this, [t._shell]);
      e.push(n.coordinates);

      for (var i = 0; i < t._holes.length; ++i) {
        var r = t._holes[i],
            o = xe.LineString.apply(this, [r]);
        e.push(o.coordinates);
      }

      return {
        type: "Polygon",
        coordinates: e
      };
    },
    MultiPolygon: function (t) {
      for (var e = [], n = 0; n < t._geometries.length; ++n) {
        var i = t._geometries[n],
            r = xe.Polygon.apply(this, [i]);
        e.push(r.coordinates);
      }

      return {
        type: "MultiPolygon",
        coordinates: e
      };
    },
    GeometryCollection: function (t) {
      for (var e = [], n = 0; n < t._geometries.length; ++n) {
        var i = t._geometries[n],
            r = i.getGeometryType();
        e.push(xe[r].apply(this, [i]));
      }

      return {
        type: "GeometryCollection",
        geometries: e
      };
    }
  },
      Ne = function (t) {
    this.geometryFactory = t || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
  };

  Ne.prototype.read = function (t) {
    var e = this.parser.read(t);
    return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e), e;
  }, Ne.prototype.reducePrecision = function (t) {
    var e, n;
    if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (e = 0, n = t.points.length; e < n; e++) this.precisionModel.makePrecise(t.points[e]);else if (t.geometries) for (e = 0, n = t.geometries.length; e < n; e++) this.reducePrecision(t.geometries[e]);
  };

  var Ce = function () {
    this.parser = new Ie(this.geometryFactory);
  };

  Ce.prototype.write = function (t) {
    return this.parser.write(t);
  };

  var Se = function () {},
      Le = {
    ON: {
      configurable: !0
    },
    LEFT: {
      configurable: !0
    },
    RIGHT: {
      configurable: !0
    }
  };

  Se.prototype.interfaces_ = function () {
    return [];
  }, Se.prototype.getClass = function () {
    return Se;
  }, Se.opposite = function (t) {
    return t === Se.LEFT ? Se.RIGHT : t === Se.RIGHT ? Se.LEFT : t;
  }, Le.ON.get = function () {
    return 0;
  }, Le.LEFT.get = function () {
    return 1;
  }, Le.RIGHT.get = function () {
    return 2;
  }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = "EmptyStackException", (y.prototype = new xt()).add = function (t) {
    return this.array_.push(t), !0;
  }, y.prototype.get = function (t) {
    if (t < 0 || t >= this.size()) throw new Error();
    return this.array_[t];
  }, y.prototype.push = function (t) {
    return this.array_.push(t), t;
  }, y.prototype.pop = function (t) {
    if (0 === this.array_.length) throw new d();
    return this.array_.pop();
  }, y.prototype.peek = function () {
    if (0 === this.array_.length) throw new d();
    return this.array_[this.array_.length - 1];
  }, y.prototype.empty = function () {
    return 0 === this.array_.length;
  }, y.prototype.isEmpty = function () {
    return this.empty();
  }, y.prototype.search = function (t) {
    return this.array_.indexOf(t);
  }, y.prototype.size = function () {
    return this.array_.length;
  }, y.prototype.toArray = function () {
    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);

    return t;
  };

  var be = function () {
    this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
  };

  be.prototype.getCoordinate = function () {
    return this._minCoord;
  }, be.prototype.getRightmostSide = function (t, e) {
    var n = this.getRightmostSideOfSegment(t, e);
    return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n;
  }, be.prototype.findRightmostEdgeAtVertex = function () {
    var t = this._minDe.getEdge().getCoordinates();

    et.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
    var e = t[this._minIndex - 1],
        n = t[this._minIndex + 1],
        i = at.computeOrientation(this._minCoord, n, e),
        r = !1;
    e.y < this._minCoord.y && n.y < this._minCoord.y && i === at.COUNTERCLOCKWISE ? r = !0 : e.y > this._minCoord.y && n.y > this._minCoord.y && i === at.CLOCKWISE && (r = !0), r && (this._minIndex = this._minIndex - 1);
  }, be.prototype.getRightmostSideOfSegment = function (t, e) {
    var n = t.getEdge().getCoordinates();
    if (e < 0 || e + 1 >= n.length) return -1;
    if (n[e].y === n[e + 1].y) return -1;
    var i = Se.LEFT;
    return n[e].y < n[e + 1].y && (i = Se.RIGHT), i;
  }, be.prototype.getEdge = function () {
    return this._orientedDe;
  }, be.prototype.checkForRightmostCoordinate = function (t) {
    for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) (null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n]);
  }, be.prototype.findRightmostEdgeAtNode = function () {
    var t = this._minDe.getNode().getEdges();

    this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
  }, be.prototype.findEdge = function (t) {
    for (var e = t.iterator(); e.hasNext();) {
      var n = e.next();
      n.isForward() && this.checkForRightmostCoordinate(n);
    }

    et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
    this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());
  }, be.prototype.interfaces_ = function () {
    return [];
  }, be.prototype.getClass = function () {
    return be;
  };

  var we = function (t) {
    function e(n, i) {
      t.call(this, e.msgWithCoord(n, i)), this.pt = i ? new C(i) : null, this.name = "TopologyException";
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getCoordinate = function () {
      return this.pt;
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e.msgWithCoord = function (t, e) {
      return e ? t : t + " [ " + e + " ]";
    }, e;
  }($),
      Oe = function () {
    this.array_ = [];
  };

  Oe.prototype.addLast = function (t) {
    this.array_.push(t);
  }, Oe.prototype.removeFirst = function () {
    return this.array_.shift();
  }, Oe.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  };

  var Te = function () {
    this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();
  };

  Te.prototype.clearVisitedEdges = function () {
    for (var t = this._dirEdgeList.iterator(); t.hasNext();) {
      t.next().setVisited(!1);
    }
  }, Te.prototype.getRightmostCoordinate = function () {
    return this._rightMostCoord;
  }, Te.prototype.computeNodeDepth = function (t) {
    for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
      var i = n.next();

      if (i.isVisited() || i.getSym().isVisited()) {
        e = i;
        break;
      }
    }

    if (null === e) throw new we("unable to find edge to compute depths at " + t.getCoordinate());
    t.getEdges().computeDepths(e);

    for (var r = t.getEdges().iterator(); r.hasNext();) {
      var o = r.next();
      o.setVisited(!0), this.copySymDepths(o);
    }
  }, Te.prototype.computeDepth = function (t) {
    this.clearVisitedEdges();

    var e = this._finder.getEdge();

    e.setEdgeDepths(Se.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);
  }, Te.prototype.create = function (t) {
    this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
  }, Te.prototype.findResultEdges = function () {
    for (var t = this._dirEdgeList.iterator(); t.hasNext();) {
      var e = t.next();
      e.getDepth(Se.RIGHT) >= 1 && e.getDepth(Se.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);
    }
  }, Te.prototype.computeDepths = function (t) {
    var e = new Pt(),
        n = new Oe(),
        i = t.getNode();

    for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {
      var r = n.removeFirst();
      e.add(r), this.computeNodeDepth(r);

      for (var o = r.getEdges().iterator(); o.hasNext();) {
        var s = o.next().getSym();

        if (!s.isVisited()) {
          var a = s.getNode();
          e.contains(a) || (n.addLast(a), e.add(a));
        }
      }
    }
  }, Te.prototype.compareTo = function (t) {
    var e = t;
    return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0;
  }, Te.prototype.getEnvelope = function () {
    if (null === this._env) {
      for (var t = new j(), e = this._dirEdgeList.iterator(); e.hasNext();) for (var n = e.next().getEdge().getCoordinates(), i = 0; i < n.length - 1; i++) t.expandToInclude(n[i]);

      this._env = t;
    }

    return this._env;
  }, Te.prototype.addReachable = function (t) {
    var e = new y();

    for (e.add(t); !e.empty();) {
      var n = e.pop();
      this.add(n, e);
    }
  }, Te.prototype.copySymDepths = function (t) {
    var e = t.getSym();
    e.setDepth(Se.LEFT, t.getDepth(Se.RIGHT)), e.setDepth(Se.RIGHT, t.getDepth(Se.LEFT));
  }, Te.prototype.add = function (t, e) {
    t.setVisited(!0), this._nodes.add(t);

    for (var n = t.getEdges().iterator(); n.hasNext();) {
      var i = n.next();

      this._dirEdgeList.add(i);

      var r = i.getSym().getNode();
      r.isVisited() || e.push(r);
    }
  }, Te.prototype.getNodes = function () {
    return this._nodes;
  }, Te.prototype.getDirectedEdges = function () {
    return this._dirEdgeList;
  }, Te.prototype.interfaces_ = function () {
    return [E];
  }, Te.prototype.getClass = function () {
    return Te;
  };

  var Re = function t() {
    if (this.location = null, 1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        var e = arguments[0];
        this.init(e.length);
      } else if (Number.isInteger(arguments[0])) {
        var n = arguments[0];
        this.init(1), this.location[Se.ON] = n;
      } else if (arguments[0] instanceof t) {
        var i = arguments[0];
        if (this.init(i.location.length), null !== i) for (var r = 0; r < this.location.length; r++) this.location[r] = i.location[r];
      }
    } else if (3 === arguments.length) {
      var o = arguments[0],
          s = arguments[1],
          a = arguments[2];
      this.init(3), this.location[Se.ON] = o, this.location[Se.LEFT] = s, this.location[Se.RIGHT] = a;
    }
  };

  Re.prototype.setAllLocations = function (t) {
    for (var e = 0; e < this.location.length; e++) this.location[e] = t;
  }, Re.prototype.isNull = function () {
    for (var t = 0; t < this.location.length; t++) if (this.location[t] !== w.NONE) return !1;

    return !0;
  }, Re.prototype.setAllLocationsIfNull = function (t) {
    for (var e = 0; e < this.location.length; e++) this.location[e] === w.NONE && (this.location[e] = t);
  }, Re.prototype.isLine = function () {
    return 1 === this.location.length;
  }, Re.prototype.merge = function (t) {
    if (t.location.length > this.location.length) {
      var e = new Array(3).fill(null);
      e[Se.ON] = this.location[Se.ON], e[Se.LEFT] = w.NONE, e[Se.RIGHT] = w.NONE, this.location = e;
    }

    for (var n = 0; n < this.location.length; n++) this.location[n] === w.NONE && n < t.location.length && (this.location[n] = t.location[n]);
  }, Re.prototype.getLocations = function () {
    return this.location;
  }, Re.prototype.flip = function () {
    if (this.location.length <= 1) return null;
    var t = this.location[Se.LEFT];
    this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t;
  }, Re.prototype.toString = function () {
    var t = new D();
    return this.location.length > 1 && t.append(w.toLocationSymbol(this.location[Se.LEFT])), t.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t.append(w.toLocationSymbol(this.location[Se.RIGHT])), t.toString();
  }, Re.prototype.setLocations = function (t, e, n) {
    this.location[Se.ON] = t, this.location[Se.LEFT] = e, this.location[Se.RIGHT] = n;
  }, Re.prototype.get = function (t) {
    return t < this.location.length ? this.location[t] : w.NONE;
  }, Re.prototype.isArea = function () {
    return this.location.length > 1;
  }, Re.prototype.isAnyNull = function () {
    for (var t = 0; t < this.location.length; t++) if (this.location[t] === w.NONE) return !0;

    return !1;
  }, Re.prototype.setLocation = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setLocation(Se.ON, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      this.location[e] = n;
    }
  }, Re.prototype.init = function (t) {
    this.location = new Array(t).fill(null), this.setAllLocations(w.NONE);
  }, Re.prototype.isEqualOnSide = function (t, e) {
    return this.location[e] === t.location[e];
  }, Re.prototype.allPositionsEqual = function (t) {
    for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;

    return !0;
  }, Re.prototype.interfaces_ = function () {
    return [];
  }, Re.prototype.getClass = function () {
    return Re;
  };

  var Pe = function t() {
    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
      if (Number.isInteger(arguments[0])) {
        var e = arguments[0];
        this.elt[0] = new Re(e), this.elt[1] = new Re(e);
      } else if (arguments[0] instanceof t) {
        var n = arguments[0];
        this.elt[0] = new Re(n.elt[0]), this.elt[1] = new Re(n.elt[1]);
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
          r = arguments[1];
      this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i].setLocation(r);
    } else if (3 === arguments.length) {
      var o = arguments[0],
          s = arguments[1],
          a = arguments[2];
      this.elt[0] = new Re(o, s, a), this.elt[1] = new Re(o, s, a);
    } else if (4 === arguments.length) {
      var u = arguments[0],
          l = arguments[1],
          c = arguments[2],
          p = arguments[3];
      this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u].setLocations(l, c, p);
    }
  };

  Pe.prototype.getGeometryCount = function () {
    var t = 0;
    return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;
  }, Pe.prototype.setAllLocations = function (t, e) {
    this.elt[t].setAllLocations(e);
  }, Pe.prototype.isNull = function (t) {
    return this.elt[t].isNull();
  }, Pe.prototype.setAllLocationsIfNull = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      this.elt[e].setAllLocationsIfNull(n);
    }
  }, Pe.prototype.isLine = function (t) {
    return this.elt[t].isLine();
  }, Pe.prototype.merge = function (t) {
    for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Re(t.elt[e]) : this.elt[e].merge(t.elt[e]);
  }, Pe.prototype.flip = function () {
    this.elt[0].flip(), this.elt[1].flip();
  }, Pe.prototype.getLocation = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.elt[t].get(Se.ON);
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return this.elt[e].get(n);
    }
  }, Pe.prototype.toString = function () {
    var t = new D();
    return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString();
  }, Pe.prototype.isArea = function () {
    if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();

    if (1 === arguments.length) {
      var t = arguments[0];
      return this.elt[t].isArea();
    }
  }, Pe.prototype.isAnyNull = function (t) {
    return this.elt[t].isAnyNull();
  }, Pe.prototype.setLocation = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      this.elt[t].setLocation(Se.ON, e);
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];
      this.elt[n].setLocation(i, r);
    }
  }, Pe.prototype.isEqualOnSide = function (t, e) {
    return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);
  }, Pe.prototype.allPositionsEqual = function (t, e) {
    return this.elt[t].allPositionsEqual(e);
  }, Pe.prototype.toLine = function (t) {
    this.elt[t].isArea() && (this.elt[t] = new Re(this.elt[t].location[0]));
  }, Pe.prototype.interfaces_ = function () {
    return [];
  }, Pe.prototype.getClass = function () {
    return Pe;
  }, Pe.toLineLabel = function (t) {
    for (var e = new Pe(w.NONE), n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n));

    return e;
  };

  var De = function () {
    this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;
    var t = arguments[0],
        e = arguments[1];
    this._geometryFactory = e, this.computePoints(t), this.computeRing();
  };

  De.prototype.computeRing = function () {
    if (null !== this._ring) return null;

    for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);

    this._ring = this._geometryFactory.createLinearRing(t), this._isHole = at.isCCW(this._ring.getCoordinates());
  }, De.prototype.isIsolated = function () {
    return 1 === this._label.getGeometryCount();
  }, De.prototype.computePoints = function (t) {
    this._startDe = t;
    var e = t,
        n = !0;

    do {
      if (null === e) throw new we("Found null DirectedEdge");
      if (e.getEdgeRing() === this) throw new we("Directed Edge visited twice during ring-building at " + e.getCoordinate());

      this._edges.add(e);

      var i = e.getLabel();
      et.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);
    } while (e !== this._startDe);
  }, De.prototype.getLinearRing = function () {
    return this._ring;
  }, De.prototype.getCoordinate = function (t) {
    return this._pts.get(t);
  }, De.prototype.computeMaxNodeDegree = function () {
    this._maxNodeDegree = 0;
    var t = this._startDe;

    do {
      var e = t.getNode().getEdges().getOutgoingDegree(this);
      e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t);
    } while (t !== this._startDe);

    this._maxNodeDegree *= 2;
  }, De.prototype.addPoints = function (t, e, n) {
    var i = t.getCoordinates();

    if (e) {
      var r = 1;
      n && (r = 0);

      for (var o = r; o < i.length; o++) this._pts.add(i[o]);
    } else {
      var s = i.length - 2;
      n && (s = i.length - 1);

      for (var a = s; a >= 0; a--) this._pts.add(i[a]);
    }
  }, De.prototype.isHole = function () {
    return this._isHole;
  }, De.prototype.setInResult = function () {
    var t = this._startDe;

    do {
      t.getEdge().setInResult(!0), t = t.getNext();
    } while (t !== this._startDe);
  }, De.prototype.containsPoint = function (t) {
    var e = this.getLinearRing();
    if (!e.getEnvelopeInternal().contains(t)) return !1;
    if (!at.isPointInRing(t, e.getCoordinates())) return !1;

    for (var n = this._holes.iterator(); n.hasNext();) {
      if (n.next().containsPoint(t)) return !1;
    }

    return !0;
  }, De.prototype.addHole = function (t) {
    this._holes.add(t);
  }, De.prototype.isShell = function () {
    return null === this._shell;
  }, De.prototype.getLabel = function () {
    return this._label;
  }, De.prototype.getEdges = function () {
    return this._edges;
  }, De.prototype.getMaxNodeDegree = function () {
    return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
  }, De.prototype.getShell = function () {
    return this._shell;
  }, De.prototype.mergeLabel = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.mergeLabel(t, 0), this.mergeLabel(t, 1);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = e.getLocation(n, Se.RIGHT);
      if (i === w.NONE) return null;
      if (this._label.getLocation(n) === w.NONE) return this._label.setLocation(n, i), null;
    }
  }, De.prototype.setShell = function (t) {
    this._shell = t, null !== t && t.addHole(this);
  }, De.prototype.toPolygon = function (t) {
    for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();

    return t.createPolygon(this.getLinearRing(), e);
  }, De.prototype.interfaces_ = function () {
    return [];
  }, De.prototype.getClass = function () {
    return De;
  };

  var Me = function (t) {
    function e() {
      var e = arguments[0],
          n = arguments[1];
      t.call(this, e, n);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setEdgeRing = function (t, e) {
      t.setMinEdgeRing(e);
    }, e.prototype.getNext = function (t) {
      return t.getNextMin();
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(De),
      Ae = function (t) {
    function e() {
      var e = arguments[0],
          n = arguments[1];
      t.call(this, e, n);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildMinimalRings = function () {
      var t = new Nt(),
          e = this._startDe;

      do {
        if (null === e.getMinEdgeRing()) {
          var n = new Me(e, this._geometryFactory);
          t.add(n);
        }

        e = e.getNext();
      } while (e !== this._startDe);

      return t;
    }, e.prototype.setEdgeRing = function (t, e) {
      t.setEdgeRing(e);
    }, e.prototype.linkDirectedEdgesForMinimalEdgeRings = function () {
      var t = this._startDe;

      do {
        t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext();
      } while (t !== this._startDe);
    }, e.prototype.getNext = function (t) {
      return t.getNext();
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(De),
      Fe = function () {
    if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];
      this._label = t;
    }
  };

  Fe.prototype.setVisited = function (t) {
    this._isVisited = t;
  }, Fe.prototype.setInResult = function (t) {
    this._isInResult = t;
  }, Fe.prototype.isCovered = function () {
    return this._isCovered;
  }, Fe.prototype.isCoveredSet = function () {
    return this._isCoveredSet;
  }, Fe.prototype.setLabel = function (t) {
    this._label = t;
  }, Fe.prototype.getLabel = function () {
    return this._label;
  }, Fe.prototype.setCovered = function (t) {
    this._isCovered = t, this._isCoveredSet = !0;
  }, Fe.prototype.updateIM = function (t) {
    et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t);
  }, Fe.prototype.isInResult = function () {
    return this._isInResult;
  }, Fe.prototype.isVisited = function () {
    return this._isVisited;
  }, Fe.prototype.interfaces_ = function () {
    return [];
  }, Fe.prototype.getClass = function () {
    return Fe;
  };

  var Ge = function (t) {
    function e() {
      t.call(this), this._coord = null, this._edges = null;
      var e = arguments[0],
          n = arguments[1];
      this._coord = e, this._edges = n, this._label = new Pe(0, w.NONE);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isIncidentEdgeInResult = function () {
      for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {
        if (t.next().getEdge().isInResult()) return !0;
      }

      return !1;
    }, e.prototype.isIsolated = function () {
      return 1 === this._label.getGeometryCount();
    }, e.prototype.getCoordinate = function () {
      return this._coord;
    }, e.prototype.print = function (t) {
      t.println("node " + this._coord + " lbl: " + this._label);
    }, e.prototype.computeIM = function (t) {}, e.prototype.computeMergedLocation = function (t, e) {
      var n = w.NONE;

      if (n = this._label.getLocation(e), !t.isNull(e)) {
        var i = t.getLocation(e);
        n !== w.BOUNDARY && (n = i);
      }

      return n;
    }, e.prototype.setLabel = function () {
      if (2 !== arguments.length) return t.prototype.setLabel.apply(this, arguments);
      var e = arguments[0],
          n = arguments[1];
      null === this._label ? this._label = new Pe(e, n) : this._label.setLocation(e, n);
    }, e.prototype.getEdges = function () {
      return this._edges;
    }, e.prototype.mergeLabel = function () {
      if (arguments[0] instanceof e) {
        var t = arguments[0];
        this.mergeLabel(t._label);
      } else if (arguments[0] instanceof Pe) for (var n = arguments[0], i = 0; i < 2; i++) {
        var r = this.computeMergedLocation(n, i);
        this._label.getLocation(i) === w.NONE && this._label.setLocation(i, r);
      }
    }, e.prototype.add = function (t) {
      this._edges.insert(t), t.setNode(this);
    }, e.prototype.setLabelBoundary = function (t) {
      if (null === this._label) return null;
      var e = w.NONE;
      null !== this._label && (e = this._label.getLocation(t));
      var n = null;

      switch (e) {
        case w.BOUNDARY:
          n = w.INTERIOR;
          break;

        case w.INTERIOR:
        default:
          n = w.BOUNDARY;
      }

      this._label.setLocation(t, n);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(Fe),
      qe = function () {
    this.nodeMap = new p(), this.nodeFact = null;
    var t = arguments[0];
    this.nodeFact = t;
  };

  qe.prototype.find = function (t) {
    return this.nodeMap.get(t);
  }, qe.prototype.addNode = function () {
    if (arguments[0] instanceof C) {
      var t = arguments[0],
          e = this.nodeMap.get(t);
      return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;
    }

    if (arguments[0] instanceof Ge) {
      var n = arguments[0],
          i = this.nodeMap.get(n.getCoordinate());
      return null === i ? (this.nodeMap.put(n.getCoordinate(), n), n) : (i.mergeLabel(n), i);
    }
  }, qe.prototype.print = function (t) {
    for (var e = this.iterator(); e.hasNext();) {
      e.next().print(t);
    }
  }, qe.prototype.iterator = function () {
    return this.nodeMap.values().iterator();
  }, qe.prototype.values = function () {
    return this.nodeMap.values();
  }, qe.prototype.getBoundaryNodes = function (t) {
    for (var e = new Nt(), n = this.iterator(); n.hasNext();) {
      var i = n.next();
      i.getLabel().getLocation(t) === w.BOUNDARY && e.add(i);
    }

    return e;
  }, qe.prototype.add = function (t) {
    var e = t.getCoordinate();
    this.addNode(e).add(t);
  }, qe.prototype.interfaces_ = function () {
    return [];
  }, qe.prototype.getClass = function () {
    return qe;
  };

  var Be = function () {},
      Ve = {
    NE: {
      configurable: !0
    },
    NW: {
      configurable: !0
    },
    SW: {
      configurable: !0
    },
    SE: {
      configurable: !0
    }
  };

  Be.prototype.interfaces_ = function () {
    return [];
  }, Be.prototype.getClass = function () {
    return Be;
  }, Be.isNorthern = function (t) {
    return t === Be.NE || t === Be.NW;
  }, Be.isOpposite = function (t, e) {
    if (t === e) return !1;
    return 2 === (t - e + 4) % 4;
  }, Be.commonHalfPlane = function (t, e) {
    if (t === e) return t;
    if (2 === (t - e + 4) % 4) return -1;
    var n = t < e ? t : e;
    return 0 === n && 3 === (t > e ? t : e) ? 3 : n;
  }, Be.isInHalfPlane = function (t, e) {
    return e === Be.SE ? t === Be.SE || t === Be.SW : t === e || t === e + 1;
  }, Be.quadrant = function () {
    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1];
      if (0 === t && 0 === e) throw new m("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
      return t >= 0 ? e >= 0 ? Be.NE : Be.SE : e >= 0 ? Be.NW : Be.SW;
    }

    if (arguments[0] instanceof C && arguments[1] instanceof C) {
      var n = arguments[0],
          i = arguments[1];
      if (i.x === n.x && i.y === n.y) throw new m("Cannot compute the quadrant for two identical points " + n);
      return i.x >= n.x ? i.y >= n.y ? Be.NE : Be.SE : i.y >= n.y ? Be.NW : Be.SW;
    }
  }, Ve.NE.get = function () {
    return 0;
  }, Ve.NW.get = function () {
    return 1;
  }, Ve.SW.get = function () {
    return 2;
  }, Ve.SE.get = function () {
    return 3;
  }, Object.defineProperties(Be, Ve);

  var Ue = function () {
    if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
      var t = arguments[0];
      this._edge = t;
    } else if (3 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2];
      this._edge = e, this.init(n, i), this._label = null;
    } else if (4 === arguments.length) {
      var r = arguments[0],
          o = arguments[1],
          s = arguments[2],
          a = arguments[3];
      this._edge = r, this.init(o, s), this._label = a;
    }
  };

  Ue.prototype.compareDirection = function (t) {
    return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : at.computeOrientation(t._p0, t._p1, this._p1);
  }, Ue.prototype.getDy = function () {
    return this._dy;
  }, Ue.prototype.getCoordinate = function () {
    return this._p0;
  }, Ue.prototype.setNode = function (t) {
    this._node = t;
  }, Ue.prototype.print = function (t) {
    var e = Math.atan2(this._dy, this._dx),
        n = this.getClass().getName(),
        i = n.lastIndexOf("."),
        r = n.substring(i + 1);
    t.print("  " + r + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label);
  }, Ue.prototype.compareTo = function (t) {
    var e = t;
    return this.compareDirection(e);
  }, Ue.prototype.getDirectedCoordinate = function () {
    return this._p1;
  }, Ue.prototype.getDx = function () {
    return this._dx;
  }, Ue.prototype.getLabel = function () {
    return this._label;
  }, Ue.prototype.getEdge = function () {
    return this._edge;
  }, Ue.prototype.getQuadrant = function () {
    return this._quadrant;
  }, Ue.prototype.getNode = function () {
    return this._node;
  }, Ue.prototype.toString = function () {
    var t = Math.atan2(this._dy, this._dx),
        e = this.getClass().getName(),
        n = e.lastIndexOf(".");
    return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label;
  }, Ue.prototype.computeLabel = function (t) {}, Ue.prototype.init = function (t, e) {
    this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
  }, Ue.prototype.interfaces_ = function () {
    return [E];
  }, Ue.prototype.getClass = function () {
    return Ue;
  };

  var ze = function (t) {
    function e() {
      var e = arguments[0],
          n = arguments[1];
      if (t.call(this, e), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n) this.init(e.getCoordinate(0), e.getCoordinate(1));else {
        var i = e.getNumPoints() - 1;
        this.init(e.getCoordinate(i), e.getCoordinate(i - 1));
      }
      this.computeDirectedLabel();
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getNextMin = function () {
      return this._nextMin;
    }, e.prototype.getDepth = function (t) {
      return this._depth[t];
    }, e.prototype.setVisited = function (t) {
      this._isVisited = t;
    }, e.prototype.computeDirectedLabel = function () {
      this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
    }, e.prototype.getNext = function () {
      return this._next;
    }, e.prototype.setDepth = function (t, e) {
      if (-999 !== this._depth[t] && this._depth[t] !== e) throw new we("assigned depths do not match", this.getCoordinate());
      this._depth[t] = e;
    }, e.prototype.isInteriorAreaEdge = function () {
      for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, Se.LEFT) === w.INTERIOR && this._label.getLocation(e, Se.RIGHT) === w.INTERIOR || (t = !1);

      return t;
    }, e.prototype.setNextMin = function (t) {
      this._nextMin = t;
    }, e.prototype.print = function (e) {
      t.prototype.print.call(this, e), e.print(" " + this._depth[Se.LEFT] + "/" + this._depth[Se.RIGHT]), e.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e.print(" inResult");
    }, e.prototype.setMinEdgeRing = function (t) {
      this._minEdgeRing = t;
    }, e.prototype.isLineEdge = function () {
      var t = this._label.isLine(0) || this._label.isLine(1),
          e = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR),
          n = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);

      return t && e && n;
    }, e.prototype.setEdgeRing = function (t) {
      this._edgeRing = t;
    }, e.prototype.getMinEdgeRing = function () {
      return this._minEdgeRing;
    }, e.prototype.getDepthDelta = function () {
      var t = this._edge.getDepthDelta();

      return this._isForward || (t = -t), t;
    }, e.prototype.setInResult = function (t) {
      this._isInResult = t;
    }, e.prototype.getSym = function () {
      return this._sym;
    }, e.prototype.isForward = function () {
      return this._isForward;
    }, e.prototype.getEdge = function () {
      return this._edge;
    }, e.prototype.printEdge = function (t) {
      this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t);
    }, e.prototype.setSym = function (t) {
      this._sym = t;
    }, e.prototype.setVisitedEdge = function (t) {
      this.setVisited(t), this._sym.setVisited(t);
    }, e.prototype.setEdgeDepths = function (t, e) {
      var n = this.getEdge().getDepthDelta();
      this._isForward || (n = -n);
      var i = 1;
      t === Se.LEFT && (i = -1);
      var r = Se.opposite(t),
          o = e + n * i;
      this.setDepth(t, e), this.setDepth(r, o);
    }, e.prototype.getEdgeRing = function () {
      return this._edgeRing;
    }, e.prototype.isInResult = function () {
      return this._isInResult;
    }, e.prototype.setNext = function (t) {
      this._next = t;
    }, e.prototype.isVisited = function () {
      return this._isVisited;
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e.depthFactor = function (t, e) {
      return t === w.EXTERIOR && e === w.INTERIOR ? 1 : t === w.INTERIOR && e === w.EXTERIOR ? -1 : 0;
    }, e;
  }(Ue),
      Xe = function () {};

  Xe.prototype.createNode = function (t) {
    return new Ge(t, null);
  }, Xe.prototype.interfaces_ = function () {
    return [];
  }, Xe.prototype.getClass = function () {
    return Xe;
  };

  var Ye = function () {
    if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), 0 === arguments.length) this._nodes = new qe(new Xe());else if (1 === arguments.length) {
      var t = arguments[0];
      this._nodes = new qe(t);
    }
  };

  Ye.prototype.printEdges = function (t) {
    t.println("Edges:");

    for (var e = 0; e < this._edges.size(); e++) {
      t.println("edge " + e + ":");

      var n = this._edges.get(e);

      n.print(t), n.eiList.print(t);
    }
  }, Ye.prototype.find = function (t) {
    return this._nodes.find(t);
  }, Ye.prototype.addNode = function () {
    if (arguments[0] instanceof Ge) {
      var t = arguments[0];
      return this._nodes.addNode(t);
    }

    if (arguments[0] instanceof C) {
      var e = arguments[0];
      return this._nodes.addNode(e);
    }
  }, Ye.prototype.getNodeIterator = function () {
    return this._nodes.iterator();
  }, Ye.prototype.linkResultDirectedEdges = function () {
    for (var t = this._nodes.iterator(); t.hasNext();) {
      t.next().getEdges().linkResultDirectedEdges();
    }
  }, Ye.prototype.debugPrintln = function (t) {
    Y.out.println(t);
  }, Ye.prototype.isBoundaryNode = function (t, e) {
    var n = this._nodes.find(e);

    if (null === n) return !1;
    var i = n.getLabel();
    return null !== i && i.getLocation(t) === w.BOUNDARY;
  }, Ye.prototype.linkAllDirectedEdges = function () {
    for (var t = this._nodes.iterator(); t.hasNext();) {
      t.next().getEdges().linkAllDirectedEdges();
    }
  }, Ye.prototype.matchInSameDirection = function (t, e, n, i) {
    return !!t.equals(n) && at.computeOrientation(t, e, i) === at.COLLINEAR && Be.quadrant(t, e) === Be.quadrant(n, i);
  }, Ye.prototype.getEdgeEnds = function () {
    return this._edgeEndList;
  }, Ye.prototype.debugPrint = function (t) {
    Y.out.print(t);
  }, Ye.prototype.getEdgeIterator = function () {
    return this._edges.iterator();
  }, Ye.prototype.findEdgeInSameDirection = function (t, e) {
    for (var n = 0; n < this._edges.size(); n++) {
      var i = this._edges.get(n),
          r = i.getCoordinates();

      if (this.matchInSameDirection(t, e, r[0], r[1])) return i;
      if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i;
    }

    return null;
  }, Ye.prototype.insertEdge = function (t) {
    this._edges.add(t);
  }, Ye.prototype.findEdgeEnd = function (t) {
    for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
      var n = e.next();
      if (n.getEdge() === t) return n;
    }

    return null;
  }, Ye.prototype.addEdges = function (t) {
    for (var e = t.iterator(); e.hasNext();) {
      var n = e.next();

      this._edges.add(n);

      var i = new ze(n, !0),
          r = new ze(n, !1);
      i.setSym(r), r.setSym(i), this.add(i), this.add(r);
    }
  }, Ye.prototype.add = function (t) {
    this._nodes.add(t), this._edgeEndList.add(t);
  }, Ye.prototype.getNodes = function () {
    return this._nodes.values();
  }, Ye.prototype.findEdge = function (t, e) {
    for (var n = 0; n < this._edges.size(); n++) {
      var i = this._edges.get(n),
          r = i.getCoordinates();

      if (t.equals(r[0]) && e.equals(r[1])) return i;
    }

    return null;
  }, Ye.prototype.interfaces_ = function () {
    return [];
  }, Ye.prototype.getClass = function () {
    return Ye;
  }, Ye.linkResultDirectedEdges = function (t) {
    for (var e = t.iterator(); e.hasNext();) {
      e.next().getEdges().linkResultDirectedEdges();
    }
  };

  var ke = function () {
    this._geometryFactory = null, this._shellList = new Nt();
    var t = arguments[0];
    this._geometryFactory = t;
  };

  ke.prototype.sortShellsAndHoles = function (t, e, n) {
    for (var i = t.iterator(); i.hasNext();) {
      var r = i.next();
      r.isHole() ? n.add(r) : e.add(r);
    }
  }, ke.prototype.computePolygons = function (t) {
    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {
      var i = n.next().toPolygon(this._geometryFactory);
      e.add(i);
    }

    return e;
  }, ke.prototype.placeFreeHoles = function (t, e) {
    for (var n = e.iterator(); n.hasNext();) {
      var i = n.next();

      if (null === i.getShell()) {
        var r = this.findEdgeRingContaining(i, t);
        if (null === r) throw new we("unable to assign hole to a shell", i.getCoordinate(0));
        i.setShell(r);
      }
    }
  }, ke.prototype.buildMinimalEdgeRings = function (t, e, n) {
    for (var i = new Nt(), r = t.iterator(); r.hasNext();) {
      var o = r.next();

      if (o.getMaxNodeDegree() > 2) {
        o.linkDirectedEdgesForMinimalEdgeRings();
        var s = o.buildMinimalRings(),
            a = this.findShell(s);
        null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s);
      } else i.add(o);
    }

    return i;
  }, ke.prototype.containsPoint = function (t) {
    for (var e = this._shellList.iterator(); e.hasNext();) {
      if (e.next().containsPoint(t)) return !0;
    }

    return !1;
  }, ke.prototype.buildMaximalEdgeRings = function (t) {
    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {
      var i = n.next();

      if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {
        var r = new Ae(i, this._geometryFactory);
        e.add(r), r.setInResult();
      }
    }

    return e;
  }, ke.prototype.placePolygonHoles = function (t, e) {
    for (var n = e.iterator(); n.hasNext();) {
      var i = n.next();
      i.isHole() && i.setShell(t);
    }
  }, ke.prototype.getPolygons = function () {
    return this.computePolygons(this._shellList);
  }, ke.prototype.findEdgeRingContaining = function (t, e) {
    for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
      var u = a.next(),
          l = u.getLinearRing(),
          c = l.getEnvelopeInternal();
      null !== o && (s = o.getLinearRing().getEnvelopeInternal());
      var p = !1;
      c.contains(i) && at.isPointInRing(r, l.getCoordinates()) && (p = !0), p && (null === o || s.contains(c)) && (o = u);
    }

    return o;
  }, ke.prototype.findShell = function (t) {
    for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {
      var r = i.next();
      r.isHole() || (n = r, e++);
    }

    return et.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n;
  }, ke.prototype.add = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.add(t.getEdgeEnds(), t.getNodes());
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      Ye.linkResultDirectedEdges(n);
      var i = this.buildMaximalEdgeRings(e),
          r = new Nt(),
          o = this.buildMinimalEdgeRings(i, this._shellList, r);
      this.sortShellsAndHoles(o, this._shellList, r), this.placeFreeHoles(this._shellList, r);
    }
  }, ke.prototype.interfaces_ = function () {
    return [];
  }, ke.prototype.getClass = function () {
    return ke;
  };

  var je = function () {};

  je.prototype.getBounds = function () {}, je.prototype.interfaces_ = function () {
    return [];
  }, je.prototype.getClass = function () {
    return je;
  };

  var He = function () {
    this._bounds = null, this._item = null;
    var t = arguments[0],
        e = arguments[1];
    this._bounds = t, this._item = e;
  };

  He.prototype.getItem = function () {
    return this._item;
  }, He.prototype.getBounds = function () {
    return this._bounds;
  }, He.prototype.interfaces_ = function () {
    return [je, e];
  }, He.prototype.getClass = function () {
    return He;
  };

  var We = function () {
    this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);
  };

  We.prototype.poll = function () {
    if (this.isEmpty()) return null;

    var t = this._items.get(1);

    return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t;
  }, We.prototype.size = function () {
    return this._size;
  }, We.prototype.reorder = function (t) {
    for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));

    this._items.set(t, n);
  }, We.prototype.clear = function () {
    this._size = 0, this._items.clear();
  }, We.prototype.isEmpty = function () {
    return 0 === this._size;
  }, We.prototype.add = function (t) {
    this._items.add(null), this._size += 1;
    var e = this._size;

    for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));

    this._items.set(e, t);
  }, We.prototype.interfaces_ = function () {
    return [];
  }, We.prototype.getClass = function () {
    return We;
  };

  var Ke = function () {};

  Ke.prototype.visitItem = function (t) {}, Ke.prototype.interfaces_ = function () {
    return [];
  }, Ke.prototype.getClass = function () {
    return Ke;
  };

  var Je = function () {};

  Je.prototype.insert = function (t, e) {}, Je.prototype.remove = function (t, e) {}, Je.prototype.query = function () {}, Je.prototype.interfaces_ = function () {
    return [];
  }, Je.prototype.getClass = function () {
    return Je;
  };

  var Qe = function () {
    if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];
      this._level = t;
    }
  },
      Ze = {
    serialVersionUID: {
      configurable: !0
    }
  };

  Qe.prototype.getLevel = function () {
    return this._level;
  }, Qe.prototype.size = function () {
    return this._childBoundables.size();
  }, Qe.prototype.getChildBoundables = function () {
    return this._childBoundables;
  }, Qe.prototype.addChildBoundable = function (t) {
    et.isTrue(null === this._bounds), this._childBoundables.add(t);
  }, Qe.prototype.isEmpty = function () {
    return this._childBoundables.isEmpty();
  }, Qe.prototype.getBounds = function () {
    return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
  }, Qe.prototype.interfaces_ = function () {
    return [je, e];
  }, Qe.prototype.getClass = function () {
    return Qe;
  }, Ze.serialVersionUID.get = function () {
    return 0x5a1e55ec41369800;
  }, Object.defineProperties(Qe, Ze);

  var $e = function () {};

  $e.reverseOrder = function () {
    return {
      compare: function (t, e) {
        return e.compareTo(t);
      }
    };
  }, $e.min = function (t) {
    return $e.sort(t), t.get(0);
  }, $e.sort = function (t, e) {
    var n = t.toArray();
    e ? Gt.sort(n, e) : Gt.sort(n);

    for (var i = t.iterator(), r = 0, o = n.length; r < o; r++) i.next(), i.set(n[r]);
  }, $e.singletonList = function (t) {
    var e = new Nt();
    return e.add(t), e;
  };

  var tn = function () {
    this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2];
    this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance();
  };

  tn.prototype.expandToQueue = function (t, e) {
    var n = tn.isComposite(this._boundable1),
        i = tn.isComposite(this._boundable2);
    if (n && i) return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t, e), null) : (this.expand(this._boundable2, this._boundable1, t, e), null);
    if (n) return this.expand(this._boundable1, this._boundable2, t, e), null;
    if (i) return this.expand(this._boundable2, this._boundable1, t, e), null;
    throw new m("neither boundable is composite");
  }, tn.prototype.isLeaves = function () {
    return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));
  }, tn.prototype.compareTo = function (t) {
    var e = t;
    return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;
  }, tn.prototype.expand = function (t, e, n, i) {
    for (var r = t.getChildBoundables().iterator(); r.hasNext();) {
      var o = r.next(),
          s = new tn(o, e, this._itemDistance);
      s.getDistance() < i && n.add(s);
    }
  }, tn.prototype.getBoundable = function (t) {
    return 0 === t ? this._boundable1 : this._boundable2;
  }, tn.prototype.getDistance = function () {
    return this._distance;
  }, tn.prototype.distance = function () {
    return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
  }, tn.prototype.interfaces_ = function () {
    return [E];
  }, tn.prototype.getClass = function () {
    return tn;
  }, tn.area = function (t) {
    return t.getBounds().getArea();
  }, tn.isComposite = function (t) {
    return t instanceof Qe;
  };

  var en = function t() {
    if (this._root = null, this._built = !1, this._itemBoundables = new Nt(), this._nodeCapacity = null, 0 === arguments.length) {
      var e = t.DEFAULT_NODE_CAPACITY;
      this._nodeCapacity = e;
    } else if (1 === arguments.length) {
      var n = arguments[0];
      et.isTrue(n > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n;
    }
  },
      nn = {
    IntersectsOp: {
      configurable: !0
    },
    serialVersionUID: {
      configurable: !0
    },
    DEFAULT_NODE_CAPACITY: {
      configurable: !0
    }
  };

  en.prototype.getNodeCapacity = function () {
    return this._nodeCapacity;
  }, en.prototype.lastNode = function (t) {
    return t.get(t.size() - 1);
  }, en.prototype.size = function () {
    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));

    if (1 === arguments.length) {
      for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
        var n = e.next();
        n instanceof Qe ? t += this.size(n) : n instanceof He && (t += 1);
      }

      return t;
    }
  }, en.prototype.removeItem = function (t, e) {
    for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {
      var r = i.next();
      r instanceof He && r.getItem() === e && (n = r);
    }

    return null !== n && (t.getChildBoundables().remove(n), !0);
  }, en.prototype.itemsTree = function () {
    if (0 === arguments.length) {
      this.build();
      var t = this.itemsTree(this._root);
      return null === t ? new Nt() : t;
    }

    if (1 === arguments.length) {
      for (var e = arguments[0], n = new Nt(), i = e.getChildBoundables().iterator(); i.hasNext();) {
        var r = i.next();

        if (r instanceof Qe) {
          var o = this.itemsTree(r);
          null !== o && n.add(o);
        } else r instanceof He ? n.add(r.getItem()) : et.shouldNeverReachHere();
      }

      return n.size() <= 0 ? null : n;
    }
  }, en.prototype.insert = function (t, e) {
    et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new He(t, e));
  }, en.prototype.boundablesAtLevel = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = new Nt();
      return this.boundablesAtLevel(t, this._root, e), e;
    }

    if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];
      if (et.isTrue(n > -2), i.getLevel() === n) return r.add(i), null;

      for (var o = i.getChildBoundables().iterator(); o.hasNext();) {
        var s = o.next();
        s instanceof Qe ? this.boundablesAtLevel(n, s, r) : (et.isTrue(s instanceof He), -1 === n && r.add(s));
      }

      return null;
    }
  }, en.prototype.query = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.build();
      var e = new Nt();
      return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.query(t, this._root, e), e);
    }

    if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      if (this.build(), this.isEmpty()) return null;
      this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.query(n, this._root, i);
    } else if (3 === arguments.length) if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) for (var r = arguments[0], o = arguments[1], s = arguments[2], a = o.getChildBoundables(), u = 0; u < a.size(); u++) {
      var l = a.get(u);
      this.getIntersectsOp().intersects(l.getBounds(), r) && (l instanceof Qe ? this.query(r, l, s) : l instanceof He ? s.visitItem(l.getItem()) : et.shouldNeverReachHere());
    } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) for (var c = arguments[0], p = arguments[1], h = arguments[2], f = p.getChildBoundables(), g = 0; g < f.size(); g++) {
      var d = f.get(g);
      this.getIntersectsOp().intersects(d.getBounds(), c) && (d instanceof Qe ? this.query(c, d, h) : d instanceof He ? h.add(d.getItem()) : et.shouldNeverReachHere());
    }
  }, en.prototype.build = function () {
    if (this._built) return null;
    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
  }, en.prototype.getRoot = function () {
    return this.build(), this._root;
  }, en.prototype.remove = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e);
    }

    if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2],
          o = this.removeItem(i, r);
      if (o) return !0;

      for (var s = null, a = i.getChildBoundables().iterator(); a.hasNext();) {
        var u = a.next();

        if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof Qe && (o = this.remove(n, u, r))) {
          s = u;
          break;
        }
      }

      return null !== s && s.getChildBoundables().isEmpty() && i.getChildBoundables().remove(s), o;
    }
  }, en.prototype.createHigherLevels = function (t, e) {
    et.isTrue(!t.isEmpty());
    var n = this.createParentBoundables(t, e + 1);
    return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);
  }, en.prototype.depth = function () {
    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));

    if (1 === arguments.length) {
      for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
        var n = e.next();

        if (n instanceof Qe) {
          var i = this.depth(n);
          i > t && (t = i);
        }
      }

      return t + 1;
    }
  }, en.prototype.createParentBoundables = function (t, e) {
    et.isTrue(!t.isEmpty());
    var n = new Nt();
    n.add(this.createNode(e));
    var i = new Nt(t);
    $e.sort(i, this.getComparator());

    for (var r = i.iterator(); r.hasNext();) {
      var o = r.next();
      this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(o);
    }

    return n;
  }, en.prototype.isEmpty = function () {
    return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
  }, en.prototype.interfaces_ = function () {
    return [e];
  }, en.prototype.getClass = function () {
    return en;
  }, en.compareDoubles = function (t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }, nn.IntersectsOp.get = function () {
    return rn;
  }, nn.serialVersionUID.get = function () {
    return -0x35ef64c82d4c5400;
  }, nn.DEFAULT_NODE_CAPACITY.get = function () {
    return 10;
  }, Object.defineProperties(en, nn);

  var rn = function () {},
      on = function () {};

  on.prototype.distance = function (t, e) {}, on.prototype.interfaces_ = function () {
    return [];
  }, on.prototype.getClass = function () {
    return on;
  };

  var sn = function (t) {
    function n(e) {
      e = e || n.DEFAULT_NODE_CAPACITY, t.call(this, e);
    }

    t && (n.__proto__ = t), (n.prototype = Object.create(t && t.prototype)).constructor = n;
    var i = {
      STRtreeNode: {
        configurable: !0
      },
      serialVersionUID: {
        configurable: !0
      },
      xComparator: {
        configurable: !0
      },
      yComparator: {
        configurable: !0
      },
      intersectsOp: {
        configurable: !0
      },
      DEFAULT_NODE_CAPACITY: {
        configurable: !0
      }
    };
    return n.prototype.createParentBoundablesFromVerticalSlices = function (t, e) {
      et.isTrue(t.length > 0);

      for (var n = new Nt(), i = 0; i < t.length; i++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));

      return n;
    }, n.prototype.createNode = function (t) {
      return new an(t);
    }, n.prototype.size = function () {
      return 0 === arguments.length ? t.prototype.size.call(this) : t.prototype.size.apply(this, arguments);
    }, n.prototype.insert = function () {
      if (2 !== arguments.length) return t.prototype.insert.apply(this, arguments);
      var e = arguments[0],
          n = arguments[1];
      if (e.isNull()) return null;
      t.prototype.insert.call(this, e, n);
    }, n.prototype.getIntersectsOp = function () {
      return n.intersectsOp;
    }, n.prototype.verticalSlices = function (t, e) {
      for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), o = 0; o < e; o++) {
        i[o] = new Nt();

        for (var s = 0; r.hasNext() && s < n;) {
          var a = r.next();
          i[o].add(a), s++;
        }
      }

      return i;
    }, n.prototype.query = function () {
      if (1 === arguments.length) {
        var e = arguments[0];
        return t.prototype.query.call(this, e);
      }

      if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];
        t.prototype.query.call(this, n, i);
      } else if (3 === arguments.length) if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
        var r = arguments[0],
            o = arguments[1],
            s = arguments[2];
        t.prototype.query.call(this, r, o, s);
      } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
        var a = arguments[0],
            u = arguments[1],
            l = arguments[2];
        t.prototype.query.call(this, a, u, l);
      }
    }, n.prototype.getComparator = function () {
      return n.yComparator;
    }, n.prototype.createParentBoundablesFromVerticalSlice = function (e, n) {
      return t.prototype.createParentBoundables.call(this, e, n);
    }, n.prototype.remove = function () {
      if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];
        return t.prototype.remove.call(this, e, n);
      }

      return t.prototype.remove.apply(this, arguments);
    }, n.prototype.depth = function () {
      return 0 === arguments.length ? t.prototype.depth.call(this) : t.prototype.depth.apply(this, arguments);
    }, n.prototype.createParentBoundables = function (t, e) {
      et.isTrue(!t.isEmpty());
      var i = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
          r = new Nt(t);
      $e.sort(r, n.xComparator);
      var o = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(i))));
      return this.createParentBoundablesFromVerticalSlices(o, e);
    }, n.prototype.nearestNeighbour = function () {
      if (1 === arguments.length) {
        if (T(arguments[0], on)) {
          var t = arguments[0],
              e = new tn(this.getRoot(), this.getRoot(), t);
          return this.nearestNeighbour(e);
        }

        if (arguments[0] instanceof tn) {
          var i = arguments[0];
          return this.nearestNeighbour(i, v.POSITIVE_INFINITY);
        }
      } else if (2 === arguments.length) {
        if (arguments[0] instanceof n && T(arguments[1], on)) {
          var r = arguments[0],
              o = arguments[1],
              s = new tn(this.getRoot(), r.getRoot(), o);
          return this.nearestNeighbour(s);
        }

        if (arguments[0] instanceof tn && "number" == typeof arguments[1]) {
          var a = arguments[0],
              u = arguments[1],
              l = null,
              c = new We();

          for (c.add(a); !c.isEmpty() && u > 0;) {
            var p = c.poll(),
                h = p.getDistance();
            if (h >= u) break;
            p.isLeaves() ? (u = h, l = p) : p.expandToQueue(c, u);
          }

          return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()];
        }
      } else if (3 === arguments.length) {
        var f = arguments[0],
            g = arguments[1],
            d = arguments[2],
            y = new He(f, g),
            _ = new tn(this.getRoot(), y, d);

        return this.nearestNeighbour(_)[0];
      }
    }, n.prototype.interfaces_ = function () {
      return [Je, e];
    }, n.prototype.getClass = function () {
      return n;
    }, n.centreX = function (t) {
      return n.avg(t.getMinX(), t.getMaxX());
    }, n.avg = function (t, e) {
      return (t + e) / 2;
    }, n.centreY = function (t) {
      return n.avg(t.getMinY(), t.getMaxY());
    }, i.STRtreeNode.get = function () {
      return an;
    }, i.serialVersionUID.get = function () {
      return 0x39920f7d5f261e0;
    }, i.xComparator.get = function () {
      return {
        interfaces_: function () {
          return [N];
        },
        compare: function (e, i) {
          return t.compareDoubles(n.centreX(e.getBounds()), n.centreX(i.getBounds()));
        }
      };
    }, i.yComparator.get = function () {
      return {
        interfaces_: function () {
          return [N];
        },
        compare: function (e, i) {
          return t.compareDoubles(n.centreY(e.getBounds()), n.centreY(i.getBounds()));
        }
      };
    }, i.intersectsOp.get = function () {
      return {
        interfaces_: function () {
          return [t.IntersectsOp];
        },
        intersects: function (t, e) {
          return t.intersects(e);
        }
      };
    }, i.DEFAULT_NODE_CAPACITY.get = function () {
      return 10;
    }, Object.defineProperties(n, i), n;
  }(en),
      an = function (t) {
    function e() {
      var e = arguments[0];
      t.call(this, e);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.computeBounds = function () {
      for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
        var n = e.next();
        null === t ? t = new j(n.getBounds()) : t.expandToInclude(n.getBounds());
      }

      return t;
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(Qe),
      un = function () {};

  un.prototype.interfaces_ = function () {
    return [];
  }, un.prototype.getClass = function () {
    return un;
  }, un.relativeSign = function (t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }, un.compare = function (t, e, n) {
    if (e.equals2D(n)) return 0;
    var i = un.relativeSign(e.x, n.x),
        r = un.relativeSign(e.y, n.y);

    switch (t) {
      case 0:
        return un.compareValue(i, r);

      case 1:
        return un.compareValue(r, i);

      case 2:
        return un.compareValue(r, -i);

      case 3:
        return un.compareValue(-i, r);

      case 4:
        return un.compareValue(-i, -r);

      case 5:
        return un.compareValue(-r, -i);

      case 6:
        return un.compareValue(-r, i);

      case 7:
        return un.compareValue(i, -r);
    }

    return et.shouldNeverReachHere("invalid octant value"), 0;
  }, un.compareValue = function (t, e) {
    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;
  };

  var ln = function () {
    this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3];
    this._segString = t, this.coord = new C(e), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));
  };

  ln.prototype.getCoordinate = function () {
    return this.coord;
  }, ln.prototype.print = function (t) {
    t.print(this.coord), t.print(" seg # = " + this.segmentIndex);
  }, ln.prototype.compareTo = function (t) {
    var e = t;
    return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e.coord);
  }, ln.prototype.isEndPoint = function (t) {
    return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;
  }, ln.prototype.isInterior = function () {
    return this._isInterior;
  }, ln.prototype.interfaces_ = function () {
    return [E];
  }, ln.prototype.getClass = function () {
    return ln;
  };

  var cn = function () {
    this._nodeMap = new p(), this._edge = null;
    var t = arguments[0];
    this._edge = t;
  };

  cn.prototype.getSplitCoordinates = function () {
    var t = new St();
    this.addEndpoints();

    for (var e = this.iterator(), n = e.next(); e.hasNext();) {
      var i = e.next();
      this.addEdgeCoordinates(n, i, t), n = i;
    }

    return t.toCoordinateArray();
  }, cn.prototype.addCollapsedNodes = function () {
    var t = new Nt();
    this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);

    for (var e = t.iterator(); e.hasNext();) {
      var n = e.next().intValue();
      this.add(this._edge.getCoordinate(n), n);
    }
  }, cn.prototype.print = function (t) {
    t.println("Intersections:");

    for (var e = this.iterator(); e.hasNext();) {
      e.next().print(t);
    }
  }, cn.prototype.findCollapsesFromExistingVertices = function (t) {
    for (var e = 0; e < this._edge.size() - 2; e++) {
      var n = this._edge.getCoordinate(e),
          i = this._edge.getCoordinate(e + 2);

      n.equals2D(i) && t.add(new M(e + 1));
    }
  }, cn.prototype.addEdgeCoordinates = function (t, e, n) {
    var i = this._edge.getCoordinate(e.segmentIndex),
        r = e.isInterior() || !e.coord.equals2D(i);

    n.add(new C(t.coord), !1);

    for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) n.add(this._edge.getCoordinate(o));

    r && n.add(new C(e.coord));
  }, cn.prototype.iterator = function () {
    return this._nodeMap.values().iterator();
  }, cn.prototype.addSplitEdges = function (t) {
    this.addEndpoints(), this.addCollapsedNodes();

    for (var e = this.iterator(), n = e.next(); e.hasNext();) {
      var i = e.next(),
          r = this.createSplitEdge(n, i);
      t.add(r), n = i;
    }
  }, cn.prototype.findCollapseIndex = function (t, e, n) {
    if (!t.coord.equals2D(e.coord)) return !1;
    var i = e.segmentIndex - t.segmentIndex;
    return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0);
  }, cn.prototype.findCollapsesFromInsertedNodes = function (t) {
    for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {
      var r = n.next();
      this.findCollapseIndex(i, r, e) && t.add(new M(e[0])), i = r;
    }
  }, cn.prototype.getEdge = function () {
    return this._edge;
  }, cn.prototype.addEndpoints = function () {
    var t = this._edge.size() - 1;
    this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);
  }, cn.prototype.createSplitEdge = function (t, e) {
    var n = e.segmentIndex - t.segmentIndex + 2,
        i = this._edge.getCoordinate(e.segmentIndex),
        r = e.isInterior() || !e.coord.equals2D(i);

    r || n--;
    var o = new Array(n).fill(null),
        s = 0;
    o[s++] = new C(t.coord);

    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this._edge.getCoordinate(a);

    return r && (o[s] = new C(e.coord)), new gn(o, this._edge.getData());
  }, cn.prototype.add = function (t, e) {
    var n = new ln(this._edge, t, e, this._edge.getSegmentOctant(e)),
        i = this._nodeMap.get(n);

    return null !== i ? (et.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"), i) : (this._nodeMap.put(n, n), n);
  }, cn.prototype.checkSplitEdgesCorrectness = function (t) {
    var e = this._edge.getCoordinates(),
        n = t.get(0).getCoordinate(0);

    if (!n.equals2D(e[0])) throw new $("bad split edge start point at " + n);
    var i = t.get(t.size() - 1).getCoordinates(),
        r = i[i.length - 1];
    if (!r.equals2D(e[e.length - 1])) throw new $("bad split edge end point at " + r);
  }, cn.prototype.interfaces_ = function () {
    return [];
  }, cn.prototype.getClass = function () {
    return cn;
  };

  var pn = function () {};

  pn.prototype.interfaces_ = function () {
    return [];
  }, pn.prototype.getClass = function () {
    return pn;
  }, pn.octant = function () {
    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1];
      if (0 === t && 0 === e) throw new m("Cannot compute the octant for point ( " + t + ", " + e + " )");
      var n = Math.abs(t),
          i = Math.abs(e);
      return t >= 0 ? e >= 0 ? n >= i ? 0 : 1 : n >= i ? 7 : 6 : e >= 0 ? n >= i ? 3 : 2 : n >= i ? 4 : 5;
    }

    if (arguments[0] instanceof C && arguments[1] instanceof C) {
      var r = arguments[0],
          o = arguments[1],
          s = o.x - r.x,
          a = o.y - r.y;
      if (0 === s && 0 === a) throw new m("Cannot compute the octant for two identical points " + r);
      return pn.octant(s, a);
    }
  };

  var hn = function () {};

  hn.prototype.getCoordinates = function () {}, hn.prototype.size = function () {}, hn.prototype.getCoordinate = function (t) {}, hn.prototype.isClosed = function () {}, hn.prototype.setData = function (t) {}, hn.prototype.getData = function () {}, hn.prototype.interfaces_ = function () {
    return [];
  }, hn.prototype.getClass = function () {
    return hn;
  };

  var fn = function () {};

  fn.prototype.addIntersection = function (t, e) {}, fn.prototype.interfaces_ = function () {
    return [hn];
  }, fn.prototype.getClass = function () {
    return fn;
  };

  var gn = function () {
    this._nodeList = new cn(this), this._pts = null, this._data = null;
    var t = arguments[0],
        e = arguments[1];
    this._pts = t, this._data = e;
  };

  gn.prototype.getCoordinates = function () {
    return this._pts;
  }, gn.prototype.size = function () {
    return this._pts.length;
  }, gn.prototype.getCoordinate = function (t) {
    return this._pts[t];
  }, gn.prototype.isClosed = function () {
    return this._pts[0].equals(this._pts[this._pts.length - 1]);
  }, gn.prototype.getSegmentOctant = function (t) {
    return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));
  }, gn.prototype.setData = function (t) {
    this._data = t;
  }, gn.prototype.safeOctant = function (t, e) {
    return t.equals2D(e) ? 0 : pn.octant(t, e);
  }, gn.prototype.getData = function () {
    return this._data;
  }, gn.prototype.addIntersection = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      this.addIntersectionNode(t, e);
    } else if (4 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[3],
          o = new C(n.getIntersection(r));
      this.addIntersection(o, i);
    }
  }, gn.prototype.toString = function () {
    return Z.toLineString(new ue(this._pts));
  }, gn.prototype.getNodeList = function () {
    return this._nodeList;
  }, gn.prototype.addIntersectionNode = function (t, e) {
    var n = e,
        i = n + 1;

    if (i < this._pts.length) {
      var r = this._pts[i];
      t.equals2D(r) && (n = i);
    }

    return this._nodeList.add(t, n);
  }, gn.prototype.addIntersections = function (t, e, n) {
    for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);
  }, gn.prototype.interfaces_ = function () {
    return [fn];
  }, gn.prototype.getClass = function () {
    return gn;
  }, gn.getNodedSubstrings = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = new Nt();
      return gn.getNodedSubstrings(t, e), e;
    }

    if (2 === arguments.length) for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext();) {
      r.next().getNodeList().addSplitEdges(i);
    }
  };

  var dn = function () {
    if (this.p0 = null, this.p1 = null, 0 === arguments.length) this.p0 = new C(), this.p1 = new C();else if (1 === arguments.length) {
      var t = arguments[0];
      this.p0 = new C(t.p0), this.p1 = new C(t.p1);
    } else if (2 === arguments.length) this.p0 = arguments[0], this.p1 = arguments[1];else if (4 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2],
          r = arguments[3];
      this.p0 = new C(e, n), this.p1 = new C(i, r);
    }
  },
      yn = {
    serialVersionUID: {
      configurable: !0
    }
  };

  dn.prototype.minX = function () {
    return Math.min(this.p0.x, this.p1.x);
  }, dn.prototype.orientationIndex = function () {
    if (arguments[0] instanceof dn) {
      var t = arguments[0],
          e = at.orientationIndex(this.p0, this.p1, t.p0),
          n = at.orientationIndex(this.p0, this.p1, t.p1);
      return e >= 0 && n >= 0 ? Math.max(e, n) : e <= 0 && n <= 0 ? Math.max(e, n) : 0;
    }

    if (arguments[0] instanceof C) {
      var i = arguments[0];
      return at.orientationIndex(this.p0, this.p1, i);
    }
  }, dn.prototype.toGeometry = function (t) {
    return t.createLineString([this.p0, this.p1]);
  }, dn.prototype.isVertical = function () {
    return this.p0.x === this.p1.x;
  }, dn.prototype.equals = function (t) {
    if (!(t instanceof dn)) return !1;
    var e = t;
    return this.p0.equals(e.p0) && this.p1.equals(e.p1);
  }, dn.prototype.intersection = function (t) {
    var e = new rt();
    return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;
  }, dn.prototype.project = function () {
    if (arguments[0] instanceof C) {
      var t = arguments[0];
      if (t.equals(this.p0) || t.equals(this.p1)) return new C(t);
      var e = this.projectionFactor(t),
          n = new C();
      return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n;
    }

    if (arguments[0] instanceof dn) {
      var i = arguments[0],
          r = this.projectionFactor(i.p0),
          o = this.projectionFactor(i.p1);
      if (r >= 1 && o >= 1) return null;
      if (r <= 0 && o <= 0) return null;
      var s = this.project(i.p0);
      r < 0 && (s = this.p0), r > 1 && (s = this.p1);
      var a = this.project(i.p1);
      return o < 0 && (a = this.p0), o > 1 && (a = this.p1), new dn(s, a);
    }
  }, dn.prototype.normalize = function () {
    this.p1.compareTo(this.p0) < 0 && this.reverse();
  }, dn.prototype.angle = function () {
    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
  }, dn.prototype.getCoordinate = function (t) {
    return 0 === t ? this.p0 : this.p1;
  }, dn.prototype.distancePerpendicular = function (t) {
    return at.distancePointLinePerpendicular(t, this.p0, this.p1);
  }, dn.prototype.minY = function () {
    return Math.min(this.p0.y, this.p1.y);
  }, dn.prototype.midPoint = function () {
    return dn.midPoint(this.p0, this.p1);
  }, dn.prototype.projectionFactor = function (t) {
    if (t.equals(this.p0)) return 0;
    if (t.equals(this.p1)) return 1;
    var e = this.p1.x - this.p0.x,
        n = this.p1.y - this.p0.y,
        i = e * e + n * n;
    if (i <= 0) return v.NaN;
    return ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;
  }, dn.prototype.closestPoints = function (t) {
    var e = this.intersection(t);
    if (null !== e) return [e, e];
    var n = new Array(2).fill(null),
        i = v.MAX_VALUE,
        r = null,
        o = this.closestPoint(t.p0);
    i = o.distance(t.p0), n[0] = o, n[1] = t.p0;
    var s = this.closestPoint(t.p1);
    (r = s.distance(t.p1)) < i && (i = r, n[0] = s, n[1] = t.p1);
    var a = t.closestPoint(this.p0);
    (r = a.distance(this.p0)) < i && (i = r, n[0] = this.p0, n[1] = a);
    var u = t.closestPoint(this.p1);
    return (r = u.distance(this.p1)) < i && (i = r, n[0] = this.p1, n[1] = u), n;
  }, dn.prototype.closestPoint = function (t) {
    var e = this.projectionFactor(t);
    if (e > 0 && e < 1) return this.project(t);
    return this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1;
  }, dn.prototype.maxX = function () {
    return Math.max(this.p0.x, this.p1.x);
  }, dn.prototype.getLength = function () {
    return this.p0.distance(this.p1);
  }, dn.prototype.compareTo = function (t) {
    var e = t,
        n = this.p0.compareTo(e.p0);
    return 0 !== n ? n : this.p1.compareTo(e.p1);
  }, dn.prototype.reverse = function () {
    var t = this.p0;
    this.p0 = this.p1, this.p1 = t;
  }, dn.prototype.equalsTopo = function (t) {
    return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0);
  }, dn.prototype.lineIntersection = function (t) {
    try {
      return k.intersection(this.p0, this.p1, t.p0, t.p1);
    } catch (t) {
      if (!(t instanceof X)) throw t;
    }

    return null;
  }, dn.prototype.maxY = function () {
    return Math.max(this.p0.y, this.p1.y);
  }, dn.prototype.pointAlongOffset = function (t, e) {
    var n = this.p0.x + t * (this.p1.x - this.p0.x),
        i = this.p0.y + t * (this.p1.y - this.p0.y),
        r = this.p1.x - this.p0.x,
        o = this.p1.y - this.p0.y,
        s = Math.sqrt(r * r + o * o),
        a = 0,
        u = 0;

    if (0 !== e) {
      if (s <= 0) throw new Error("Cannot compute offset from zero-length line segment");
      a = e * r / s, u = e * o / s;
    }

    return new C(n - u, i + a);
  }, dn.prototype.setCoordinates = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setCoordinates(t.p0, t.p1);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;
    }
  }, dn.prototype.segmentFraction = function (t) {
    var e = this.projectionFactor(t);
    return e < 0 ? e = 0 : (e > 1 || v.isNaN(e)) && (e = 1), e;
  }, dn.prototype.toString = function () {
    return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
  }, dn.prototype.isHorizontal = function () {
    return this.p0.y === this.p1.y;
  }, dn.prototype.distance = function () {
    if (arguments[0] instanceof dn) {
      var t = arguments[0];
      return at.distanceLineLine(this.p0, this.p1, t.p0, t.p1);
    }

    if (arguments[0] instanceof C) {
      var e = arguments[0];
      return at.distancePointLine(e, this.p0, this.p1);
    }
  }, dn.prototype.pointAlong = function (t) {
    var e = new C();
    return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;
  }, dn.prototype.hashCode = function () {
    var t = v.doubleToLongBits(this.p0.x);
    t ^= 31 * v.doubleToLongBits(this.p0.y);
    var e = Math.trunc(t) ^ Math.trunc(t >> 32),
        n = v.doubleToLongBits(this.p1.x);
    n ^= 31 * v.doubleToLongBits(this.p1.y);
    return e ^ (Math.trunc(n) ^ Math.trunc(n >> 32));
  }, dn.prototype.interfaces_ = function () {
    return [E, e];
  }, dn.prototype.getClass = function () {
    return dn;
  }, dn.midPoint = function (t, e) {
    return new C((t.x + e.x) / 2, (t.y + e.y) / 2);
  }, yn.serialVersionUID.get = function () {
    return 0x2d2172135f411c00;
  }, Object.defineProperties(dn, yn);

  var _n = function () {
    this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();
  };

  _n.prototype.overlap = function () {
    if (2 === arguments.length) ;else if (4 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = arguments[3];
      t.getLineSegment(e, this._overlapSeg1), n.getLineSegment(i, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
    }
  }, _n.prototype.interfaces_ = function () {
    return [];
  }, _n.prototype.getClass = function () {
    return _n;
  };

  var mn = function () {
    this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3];
    this._pts = t, this._start = e, this._end = n, this._context = i;
  };

  mn.prototype.getLineSegment = function (t, e) {
    e.p0 = this._pts[t], e.p1 = this._pts[t + 1];
  }, mn.prototype.computeSelect = function (t, e, n, i) {
    var r = this._pts[e],
        o = this._pts[n];
    if (i.tempEnv1.init(r, o), n - e == 1) return i.select(this, e), null;
    if (!t.intersects(i.tempEnv1)) return null;
    var s = Math.trunc((e + n) / 2);
    e < s && this.computeSelect(t, e, s, i), s < n && this.computeSelect(t, s, n, i);
  }, mn.prototype.getCoordinates = function () {
    for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];

    return t;
  }, mn.prototype.computeOverlaps = function (t, e) {
    this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e);
  }, mn.prototype.setId = function (t) {
    this._id = t;
  }, mn.prototype.select = function (t, e) {
    this.computeSelect(t, this._start, this._end, e);
  }, mn.prototype.getEnvelope = function () {
    if (null === this._env) {
      var t = this._pts[this._start],
          e = this._pts[this._end];
      this._env = new j(t, e);
    }

    return this._env;
  }, mn.prototype.getEndIndex = function () {
    return this._end;
  }, mn.prototype.getStartIndex = function () {
    return this._start;
  }, mn.prototype.getContext = function () {
    return this._context;
  }, mn.prototype.getId = function () {
    return this._id;
  }, mn.prototype.computeOverlapsInternal = function (t, e, n, i, r, o) {
    var s = this._pts[t],
        a = this._pts[e],
        u = n._pts[i],
        l = n._pts[r];
    if (e - t == 1 && r - i == 1) return o.overlap(this, t, n, i), null;
    if (o.tempEnv1.init(s, a), o.tempEnv2.init(u, l), !o.tempEnv1.intersects(o.tempEnv2)) return null;
    var c = Math.trunc((t + e) / 2),
        p = Math.trunc((i + r) / 2);
    t < c && (i < p && this.computeOverlapsInternal(t, c, n, i, p, o), p < r && this.computeOverlapsInternal(t, c, n, p, r, o)), c < e && (i < p && this.computeOverlapsInternal(c, e, n, i, p, o), p < r && this.computeOverlapsInternal(c, e, n, p, r, o));
  }, mn.prototype.interfaces_ = function () {
    return [];
  }, mn.prototype.getClass = function () {
    return mn;
  };

  var vn = function () {};

  vn.prototype.interfaces_ = function () {
    return [];
  }, vn.prototype.getClass = function () {
    return vn;
  }, vn.getChainStartIndices = function (t) {
    var e = 0,
        n = new Nt();
    n.add(new M(e));

    do {
      var i = vn.findChainEnd(t, e);
      n.add(new M(i)), e = i;
    } while (e < t.length - 1);

    return vn.toIntArray(n);
  }, vn.findChainEnd = function (t, e) {
    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;

    if (n >= t.length - 1) return t.length - 1;

    for (var i = Be.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length;) {
      if (!t[r - 1].equals2D(t[r])) {
        if (Be.quadrant(t[r - 1], t[r]) !== i) break;
      }

      r++;
    }

    return r - 1;
  }, vn.getChains = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return vn.getChains(t, null);
    }

    if (2 === arguments.length) {
      for (var e = arguments[0], n = arguments[1], i = new Nt(), r = vn.getChainStartIndices(e), o = 0; o < r.length - 1; o++) {
        var s = new mn(e, r[o], r[o + 1], n);
        i.add(s);
      }

      return i;
    }
  }, vn.toIntArray = function (t) {
    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();

    return e;
  };

  var In = function () {};

  In.prototype.computeNodes = function (t) {}, In.prototype.getNodedSubstrings = function () {}, In.prototype.interfaces_ = function () {
    return [];
  }, In.prototype.getClass = function () {
    return In;
  };

  var En = function () {
    if (this._segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];
      this.setSegmentIntersector(t);
    }
  };

  En.prototype.setSegmentIntersector = function (t) {
    this._segInt = t;
  }, En.prototype.interfaces_ = function () {
    return [In];
  }, En.prototype.getClass = function () {
    return En;
  };

  var xn = function (t) {
    function e(e) {
      e ? t.call(this, e) : t.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
    }

    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
    var n = {
      SegmentOverlapAction: {
        configurable: !0
      }
    };
    return e.prototype.getMonotoneChains = function () {
      return this._monoChains;
    }, e.prototype.getNodedSubstrings = function () {
      return gn.getNodedSubstrings(this._nodedSegStrings);
    }, e.prototype.getIndex = function () {
      return this._index;
    }, e.prototype.add = function (t) {
      for (var e = vn.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {
        var n = e.next();
        n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n);
      }
    }, e.prototype.computeNodes = function (t) {
      this._nodedSegStrings = t;

      for (var e = t.iterator(); e.hasNext();) this.add(e.next());

      this.intersectChains();
    }, e.prototype.intersectChains = function () {
      for (var t = new Nn(this._segInt), e = this._monoChains.iterator(); e.hasNext();) for (var n = e.next(), i = this._index.query(n.getEnvelope()).iterator(); i.hasNext();) {
        var r = i.next();
        if (r.getId() > n.getId() && (n.computeOverlaps(r, t), this._nOverlaps++), this._segInt.isDone()) return null;
      }
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, n.SegmentOverlapAction.get = function () {
      return Nn;
    }, Object.defineProperties(e, n), e;
  }(En),
      Nn = function (t) {
    function e() {
      t.call(this), this._si = null;
      var e = arguments[0];
      this._si = e;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.overlap = function () {
      if (4 !== arguments.length) return t.prototype.overlap.apply(this, arguments);
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2],
          r = arguments[3],
          o = e.getContext(),
          s = i.getContext();

      this._si.processIntersections(o, n, s, r);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(_n),
      Cn = function t() {
    if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {
      var e = arguments[0];
      this.setQuadrantSegments(e);
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];
      this.setQuadrantSegments(n), this.setEndCapStyle(i);
    } else if (4 === arguments.length) {
      var r = arguments[0],
          o = arguments[1],
          s = arguments[2],
          a = arguments[3];
      this.setQuadrantSegments(r), this.setEndCapStyle(o), this.setJoinStyle(s), this.setMitreLimit(a);
    }
  },
      Sn = {
    CAP_ROUND: {
      configurable: !0
    },
    CAP_FLAT: {
      configurable: !0
    },
    CAP_SQUARE: {
      configurable: !0
    },
    JOIN_ROUND: {
      configurable: !0
    },
    JOIN_MITRE: {
      configurable: !0
    },
    JOIN_BEVEL: {
      configurable: !0
    },
    DEFAULT_QUADRANT_SEGMENTS: {
      configurable: !0
    },
    DEFAULT_MITRE_LIMIT: {
      configurable: !0
    },
    DEFAULT_SIMPLIFY_FACTOR: {
      configurable: !0
    }
  };

  Cn.prototype.getEndCapStyle = function () {
    return this._endCapStyle;
  }, Cn.prototype.isSingleSided = function () {
    return this._isSingleSided;
  }, Cn.prototype.setQuadrantSegments = function (t) {
    this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);
  }, Cn.prototype.getJoinStyle = function () {
    return this._joinStyle;
  }, Cn.prototype.setJoinStyle = function (t) {
    this._joinStyle = t;
  }, Cn.prototype.setSimplifyFactor = function (t) {
    this._simplifyFactor = t < 0 ? 0 : t;
  }, Cn.prototype.getSimplifyFactor = function () {
    return this._simplifyFactor;
  }, Cn.prototype.getQuadrantSegments = function () {
    return this._quadrantSegments;
  }, Cn.prototype.setEndCapStyle = function (t) {
    this._endCapStyle = t;
  }, Cn.prototype.getMitreLimit = function () {
    return this._mitreLimit;
  }, Cn.prototype.setMitreLimit = function (t) {
    this._mitreLimit = t;
  }, Cn.prototype.setSingleSided = function (t) {
    this._isSingleSided = t;
  }, Cn.prototype.interfaces_ = function () {
    return [];
  }, Cn.prototype.getClass = function () {
    return Cn;
  }, Cn.bufferDistanceError = function (t) {
    var e = Math.PI / 2 / t;
    return 1 - Math.cos(e / 2);
  }, Sn.CAP_ROUND.get = function () {
    return 1;
  }, Sn.CAP_FLAT.get = function () {
    return 2;
  }, Sn.CAP_SQUARE.get = function () {
    return 3;
  }, Sn.JOIN_ROUND.get = function () {
    return 1;
  }, Sn.JOIN_MITRE.get = function () {
    return 2;
  }, Sn.JOIN_BEVEL.get = function () {
    return 3;
  }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function () {
    return 8;
  }, Sn.DEFAULT_MITRE_LIMIT.get = function () {
    return 5;
  }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function () {
    return .01;
  }, Object.defineProperties(Cn, Sn);

  var Ln = function (t) {
    this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t || null;
  },
      bn = {
    INIT: {
      configurable: !0
    },
    DELETE: {
      configurable: !0
    },
    KEEP: {
      configurable: !0
    },
    NUM_PTS_TO_CHECK: {
      configurable: !0
    }
  };

  Ln.prototype.isDeletable = function (t, e, n, i) {
    var r = this._inputLine[t],
        o = this._inputLine[e],
        s = this._inputLine[n];
    return !!this.isConcave(r, o, s) && !!this.isShallow(r, o, s, i) && this.isShallowSampled(r, o, t, n, i);
  }, Ln.prototype.deleteShallowConcavities = function () {
    for (var t = 1, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e), i = !1; n < this._inputLine.length;) {
      var r = !1;
      this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = Ln.DELETE, r = !0, i = !0), t = r ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e);
    }

    return i;
  }, Ln.prototype.isShallowConcavity = function (t, e, n, i) {
    if (!(at.computeOrientation(t, e, n) === this._angleOrientation)) return !1;
    return at.distancePointLine(e, t, n) < i;
  }, Ln.prototype.isShallowSampled = function (t, e, n, i, r) {
    var o = Math.trunc((i - n) / Ln.NUM_PTS_TO_CHECK);
    o <= 0 && (o = 1);

    for (var s = n; s < i; s += o) if (!this.isShallow(t, e, this._inputLine[s], r)) return !1;

    return !0;
  }, Ln.prototype.isConcave = function (t, e, n) {
    var i = at.computeOrientation(t, e, n) === this._angleOrientation;

    return i;
  }, Ln.prototype.simplify = function (t) {
    this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
    var e = !1;

    do {
      e = this.deleteShallowConcavities();
    } while (e);

    return this.collapseLine();
  }, Ln.prototype.findNextNonDeletedIndex = function (t) {
    for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === Ln.DELETE;) e++;

    return e;
  }, Ln.prototype.isShallow = function (t, e, n, i) {
    return at.distancePointLine(e, t, n) < i;
  }, Ln.prototype.collapseLine = function () {
    for (var t = new St(), e = 0; e < this._inputLine.length; e++) this._isDeleted[e] !== Ln.DELETE && t.add(this._inputLine[e]);

    return t.toCoordinateArray();
  }, Ln.prototype.interfaces_ = function () {
    return [];
  }, Ln.prototype.getClass = function () {
    return Ln;
  }, Ln.simplify = function (t, e) {
    return new Ln(t).simplify(e);
  }, bn.INIT.get = function () {
    return 0;
  }, bn.DELETE.get = function () {
    return 1;
  }, bn.KEEP.get = function () {
    return 1;
  }, bn.NUM_PTS_TO_CHECK.get = function () {
    return 10;
  }, Object.defineProperties(Ln, bn);

  var wn = function () {
    this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();
  },
      On = {
    COORDINATE_ARRAY_TYPE: {
      configurable: !0
    }
  };

  wn.prototype.getCoordinates = function () {
    return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);
  }, wn.prototype.setPrecisionModel = function (t) {
    this._precisionModel = t;
  }, wn.prototype.addPt = function (t) {
    var e = new C(t);
    if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;

    this._ptList.add(e);
  }, wn.prototype.revere = function () {}, wn.prototype.addPts = function (t, e) {
    if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);else for (var i = t.length - 1; i >= 0; i--) this.addPt(t[i]);
  }, wn.prototype.isRedundant = function (t) {
    if (this._ptList.size() < 1) return !1;

    var e = this._ptList.get(this._ptList.size() - 1);

    return t.distance(e) < this._minimimVertexDistance;
  }, wn.prototype.toString = function () {
    return new _e().createLineString(this.getCoordinates()).toString();
  }, wn.prototype.closeRing = function () {
    if (this._ptList.size() < 1) return null;

    var t = new C(this._ptList.get(0)),
        e = this._ptList.get(this._ptList.size() - 1);

    if (t.equals(e)) return null;

    this._ptList.add(t);
  }, wn.prototype.setMinimumVertexDistance = function (t) {
    this._minimimVertexDistance = t;
  }, wn.prototype.interfaces_ = function () {
    return [];
  }, wn.prototype.getClass = function () {
    return wn;
  }, On.COORDINATE_ARRAY_TYPE.get = function () {
    return new Array(0).fill(null);
  }, Object.defineProperties(wn, On);

  var Tn = function () {},
      Rn = {
    PI_TIMES_2: {
      configurable: !0
    },
    PI_OVER_2: {
      configurable: !0
    },
    PI_OVER_4: {
      configurable: !0
    },
    COUNTERCLOCKWISE: {
      configurable: !0
    },
    CLOCKWISE: {
      configurable: !0
    },
    NONE: {
      configurable: !0
    }
  };

  Tn.prototype.interfaces_ = function () {
    return [];
  }, Tn.prototype.getClass = function () {
    return Tn;
  }, Tn.toDegrees = function (t) {
    return 180 * t / Math.PI;
  }, Tn.normalize = function (t) {
    for (; t > Math.PI;) t -= Tn.PI_TIMES_2;

    for (; t <= -Math.PI;) t += Tn.PI_TIMES_2;

    return t;
  }, Tn.angle = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return Math.atan2(t.y, t.x);
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = n.x - e.x,
          r = n.y - e.y;
      return Math.atan2(r, i);
    }
  }, Tn.isAcute = function (t, e, n) {
    var i = t.x - e.x,
        r = t.y - e.y;
    return i * (n.x - e.x) + r * (n.y - e.y) > 0;
  }, Tn.isObtuse = function (t, e, n) {
    var i = t.x - e.x,
        r = t.y - e.y;
    return i * (n.x - e.x) + r * (n.y - e.y) < 0;
  }, Tn.interiorAngle = function (t, e, n) {
    var i = Tn.angle(e, t),
        r = Tn.angle(e, n);
    return Math.abs(r - i);
  }, Tn.normalizePositive = function (t) {
    if (t < 0) {
      for (; t < 0;) t += Tn.PI_TIMES_2;

      t >= Tn.PI_TIMES_2 && (t = 0);
    } else {
      for (; t >= Tn.PI_TIMES_2;) t -= Tn.PI_TIMES_2;

      t < 0 && (t = 0);
    }

    return t;
  }, Tn.angleBetween = function (t, e, n) {
    var i = Tn.angle(e, t),
        r = Tn.angle(e, n);
    return Tn.diff(i, r);
  }, Tn.diff = function (t, e) {
    var n = null;
    return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n;
  }, Tn.toRadians = function (t) {
    return t * Math.PI / 180;
  }, Tn.getTurn = function (t, e) {
    var n = Math.sin(e - t);
    return n > 0 ? Tn.COUNTERCLOCKWISE : n < 0 ? Tn.CLOCKWISE : Tn.NONE;
  }, Tn.angleBetweenOriented = function (t, e, n) {
    var i = Tn.angle(e, t),
        r = Tn.angle(e, n) - i;
    return r <= -Math.PI ? r + Tn.PI_TIMES_2 : r > Math.PI ? r - Tn.PI_TIMES_2 : r;
  }, Rn.PI_TIMES_2.get = function () {
    return 2 * Math.PI;
  }, Rn.PI_OVER_2.get = function () {
    return Math.PI / 2;
  }, Rn.PI_OVER_4.get = function () {
    return Math.PI / 4;
  }, Rn.COUNTERCLOCKWISE.get = function () {
    return at.COUNTERCLOCKWISE;
  }, Rn.CLOCKWISE.get = function () {
    return at.CLOCKWISE;
  }, Rn.NONE.get = function () {
    return at.COLLINEAR;
  }, Object.defineProperties(Tn, Rn);

  var Pn = function t() {
    this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = !1;
    var e = arguments[0],
        n = arguments[1],
        i = arguments[2];
    this._precisionModel = e, this._bufParams = n, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i);
  },
      Dn = {
    OFFSET_SEGMENT_SEPARATION_FACTOR: {
      configurable: !0
    },
    INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {
      configurable: !0
    },
    CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {
      configurable: !0
    },
    MAX_CLOSING_SEG_LEN_FACTOR: {
      configurable: !0
    }
  };

  Pn.prototype.addNextSegment = function (t, e) {
    if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
    var n = at.computeOrientation(this._s0, this._s1, this._s2),
        i = n === at.CLOCKWISE && this._side === Se.LEFT || n === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;
    0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);
  }, Pn.prototype.addLineEndCap = function (t, e) {
    var n = new dn(t, e),
        i = new dn();
    this.computeOffsetSegment(n, Se.LEFT, this._distance, i);
    var r = new dn();
    this.computeOffsetSegment(n, Se.RIGHT, this._distance, r);
    var o = e.x - t.x,
        s = e.y - t.y,
        a = Math.atan2(s, o);

    switch (this._bufParams.getEndCapStyle()) {
      case Cn.CAP_ROUND:
        this._segList.addPt(i.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r.p1);
        break;

      case Cn.CAP_FLAT:
        this._segList.addPt(i.p1), this._segList.addPt(r.p1);
        break;

      case Cn.CAP_SQUARE:
        var u = new C();
        u.x = Math.abs(this._distance) * Math.cos(a), u.y = Math.abs(this._distance) * Math.sin(a);
        var l = new C(i.p1.x + u.x, i.p1.y + u.y),
            c = new C(r.p1.x + u.x, r.p1.y + u.y);
        this._segList.addPt(l), this._segList.addPt(c);
    }
  }, Pn.prototype.getCoordinates = function () {
    return this._segList.getCoordinates();
  }, Pn.prototype.addMitreJoin = function (t, e, n, i) {
    var r = !0,
        o = null;

    try {
      o = k.intersection(e.p0, e.p1, n.p0, n.p1);
      (i <= 0 ? 1 : o.distance(t) / Math.abs(i)) > this._bufParams.getMitreLimit() && (r = !1);
    } catch (t) {
      if (!(t instanceof X)) throw t;
      o = new C(0, 0), r = !1;
    }

    r ? this._segList.addPt(o) : this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit());
  }, Pn.prototype.addFilletCorner = function (t, e, n, i, r) {
    var o = e.x - t.x,
        s = e.y - t.y,
        a = Math.atan2(s, o),
        u = n.x - t.x,
        l = n.y - t.y,
        c = Math.atan2(l, u);
    i === at.CLOCKWISE ? a <= c && (a += 2 * Math.PI) : a >= c && (a -= 2 * Math.PI), this._segList.addPt(e), this.addFilletArc(t, a, c, i, r), this._segList.addPt(n);
  }, Pn.prototype.addOutsideTurn = function (t, e) {
    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
    this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0));
  }, Pn.prototype.createSquare = function (t) {
    this._segList.addPt(new C(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new C(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new C(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new C(t.x - this._distance, t.y + this._distance)), this._segList.closeRing();
  }, Pn.prototype.addSegments = function (t, e) {
    this._segList.addPts(t, e);
  }, Pn.prototype.addFirstSegment = function () {
    this._segList.addPt(this._offset1.p0);
  }, Pn.prototype.addLastSegment = function () {
    this._segList.addPt(this._offset1.p1);
  }, Pn.prototype.initSideSegments = function (t, e, n) {
    this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);
  }, Pn.prototype.addLimitedMitreJoin = function (t, e, n, i) {
    var r = this._seg0.p1,
        o = Tn.angle(r, this._seg0.p0),
        s = Tn.angleBetweenOriented(this._seg0.p0, r, this._seg1.p1) / 2,
        a = Tn.normalize(o + s),
        u = Tn.normalize(a + Math.PI),
        l = i * n,
        c = n - l * Math.abs(Math.sin(s)),
        p = r.x + l * Math.cos(u),
        h = r.y + l * Math.sin(u),
        f = new C(p, h),
        g = new dn(r, f),
        d = g.pointAlongOffset(1, c),
        y = g.pointAlongOffset(1, -c);
    this._side === Se.LEFT ? (this._segList.addPt(d), this._segList.addPt(y)) : (this._segList.addPt(y), this._segList.addPt(d));
  }, Pn.prototype.computeOffsetSegment = function (t, e, n, i) {
    var r = e === Se.LEFT ? 1 : -1,
        o = t.p1.x - t.p0.x,
        s = t.p1.y - t.p0.y,
        a = Math.sqrt(o * o + s * s),
        u = r * n * o / a,
        l = r * n * s / a;
    i.p0.x = t.p0.x - l, i.p0.y = t.p0.y + u, i.p1.x = t.p1.x - l, i.p1.y = t.p1.y + u;
  }, Pn.prototype.addFilletArc = function (t, e, n, i, r) {
    var o = i === at.CLOCKWISE ? -1 : 1,
        s = Math.abs(e - n),
        a = Math.trunc(s / this._filletAngleQuantum + .5);
    if (a < 1) return null;

    for (var u = s / a, l = 0, c = new C(); l < s;) {
      var p = e + o * l;
      c.x = t.x + r * Math.cos(p), c.y = t.y + r * Math.sin(p), this._segList.addPt(c), l += u;
    }
  }, Pn.prototype.addInsideTurn = function (t, e) {
    if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);else {
      if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
        var n = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));

        this._segList.addPt(n);

        var i = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));

        this._segList.addPt(i);
      } else this._segList.addPt(this._s1);

      this._segList.addPt(this._offset1.p0);
    }
  }, Pn.prototype.createCircle = function (t) {
    var e = new C(t.x + this._distance, t.y);
    this._segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
  }, Pn.prototype.addBevelJoin = function (t, e) {
    this._segList.addPt(t.p1), this._segList.addPt(e.p0);
  }, Pn.prototype.init = function (t) {
    this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
  }, Pn.prototype.addCollinear = function (t) {
    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);

    this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));
  }, Pn.prototype.closeRing = function () {
    this._segList.closeRing();
  }, Pn.prototype.hasNarrowConcaveAngle = function () {
    return this._hasNarrowConcaveAngle;
  }, Pn.prototype.interfaces_ = function () {
    return [];
  }, Pn.prototype.getClass = function () {
    return Pn;
  }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () {
    return .001;
  }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {
    return .001;
  }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {
    return 1e-6;
  }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function () {
    return 80;
  }, Object.defineProperties(Pn, Dn);

  var Mn = function () {
    this._distance = 0, this._precisionModel = null, this._bufParams = null;
    var t = arguments[0],
        e = arguments[1];
    this._precisionModel = t, this._bufParams = e;
  };

  Mn.prototype.getOffsetCurve = function (t, e) {
    if (this._distance = e, 0 === e) return null;
    var n = e < 0,
        i = Math.abs(e),
        r = this.getSegGen(i);
    t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);
    var o = r.getCoordinates();
    return n && Lt.reverse(o), o;
  }, Mn.prototype.computeSingleSidedBufferCurve = function (t, e, n) {
    var i = this.simplifyTolerance(this._distance);

    if (e) {
      n.addSegments(t, !0);
      var r = Ln.simplify(t, -i),
          o = r.length - 1;
      n.initSideSegments(r[o], r[o - 1], Se.LEFT), n.addFirstSegment();

      for (var s = o - 2; s >= 0; s--) n.addNextSegment(r[s], !0);
    } else {
      n.addSegments(t, !1);
      var a = Ln.simplify(t, i),
          u = a.length - 1;
      n.initSideSegments(a[0], a[1], Se.LEFT), n.addFirstSegment();

      for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0);
    }

    n.addLastSegment(), n.closeRing();
  }, Mn.prototype.computeRingBufferCurve = function (t, e, n) {
    var i = this.simplifyTolerance(this._distance);
    e === Se.RIGHT && (i = -i);
    var r = Ln.simplify(t, i),
        o = r.length - 1;
    n.initSideSegments(r[o - 1], r[0], e);

    for (var s = 1; s <= o; s++) {
      var a = 1 !== s;
      n.addNextSegment(r[s], a);
    }

    n.closeRing();
  }, Mn.prototype.computeLineBufferCurve = function (t, e) {
    var n = this.simplifyTolerance(this._distance),
        i = Ln.simplify(t, n),
        r = i.length - 1;
    e.initSideSegments(i[0], i[1], Se.LEFT);

    for (var o = 2; o <= r; o++) e.addNextSegment(i[o], !0);

    e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]);
    var s = Ln.simplify(t, -n),
        a = s.length - 1;
    e.initSideSegments(s[a], s[a - 1], Se.LEFT);

    for (var u = a - 2; u >= 0; u--) e.addNextSegment(s[u], !0);

    e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing();
  }, Mn.prototype.computePointCurve = function (t, e) {
    switch (this._bufParams.getEndCapStyle()) {
      case Cn.CAP_ROUND:
        e.createCircle(t);
        break;

      case Cn.CAP_SQUARE:
        e.createSquare(t);
    }
  }, Mn.prototype.getLineCurve = function (t, e) {
    if (this._distance = e, e < 0 && !this._bufParams.isSingleSided()) return null;
    if (0 === e) return null;
    var n = Math.abs(e),
        i = this.getSegGen(n);
    if (t.length <= 1) this.computePointCurve(t[0], i);else if (this._bufParams.isSingleSided()) {
      var r = e < 0;
      this.computeSingleSidedBufferCurve(t, r, i);
    } else this.computeLineBufferCurve(t, i);
    return i.getCoordinates();
  }, Mn.prototype.getBufferParameters = function () {
    return this._bufParams;
  }, Mn.prototype.simplifyTolerance = function (t) {
    return t * this._bufParams.getSimplifyFactor();
  }, Mn.prototype.getRingCurve = function (t, e, n) {
    if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n);
    if (0 === n) return Mn.copyCoordinates(t);
    var i = this.getSegGen(n);
    return this.computeRingBufferCurve(t, e, i), i.getCoordinates();
  }, Mn.prototype.computeOffsetCurve = function (t, e, n) {
    var i = this.simplifyTolerance(this._distance);

    if (e) {
      var r = Ln.simplify(t, -i),
          o = r.length - 1;
      n.initSideSegments(r[o], r[o - 1], Se.LEFT), n.addFirstSegment();

      for (var s = o - 2; s >= 0; s--) n.addNextSegment(r[s], !0);
    } else {
      var a = Ln.simplify(t, i),
          u = a.length - 1;
      n.initSideSegments(a[0], a[1], Se.LEFT), n.addFirstSegment();

      for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0);
    }

    n.addLastSegment();
  }, Mn.prototype.getSegGen = function (t) {
    return new Pn(this._precisionModel, this._bufParams, t);
  }, Mn.prototype.interfaces_ = function () {
    return [];
  }, Mn.prototype.getClass = function () {
    return Mn;
  }, Mn.copyCoordinates = function (t) {
    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new C(t[n]);

    return e;
  };

  var An = function () {
    this._subgraphs = null, this._seg = new dn(), this._cga = new at();
    var t = arguments[0];
    this._subgraphs = t;
  },
      Fn = {
    DepthSegment: {
      configurable: !0
    }
  };

  An.prototype.findStabbedSegments = function () {
    if (1 === arguments.length) {
      for (var t = arguments[0], e = new Nt(), n = this._subgraphs.iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.getEnvelope();
        t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e);
      }

      return e;
    }

    if (3 === arguments.length) if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze) for (var o = arguments[0], s = arguments[1], a = arguments[2], u = s.getEdge().getCoordinates(), l = 0; l < u.length - 1; l++) {
      this._seg.p0 = u[l], this._seg.p1 = u[l + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();

      if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o.x) && !(this._seg.isHorizontal() || o.y < this._seg.p0.y || o.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o) === at.RIGHT)) {
        var c = s.getDepth(Se.LEFT);
        this._seg.p0.equals(u[l]) || (c = s.getDepth(Se.RIGHT));
        var p = new Gn(this._seg, c);
        a.add(p);
      }
    } else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt)) for (var h = arguments[0], f = arguments[1], g = arguments[2], d = f.iterator(); d.hasNext();) {
      var y = d.next();
      y.isForward() && this.findStabbedSegments(h, y, g);
    }
  }, An.prototype.getDepth = function (t) {
    var e = this.findStabbedSegments(t);
    if (0 === e.size()) return 0;
    return $e.min(e)._leftDepth;
  }, An.prototype.interfaces_ = function () {
    return [];
  }, An.prototype.getClass = function () {
    return An;
  }, Fn.DepthSegment.get = function () {
    return Gn;
  }, Object.defineProperties(An, Fn);

  var Gn = function () {
    this._upwardSeg = null, this._leftDepth = null;
    var t = arguments[0],
        e = arguments[1];
    this._upwardSeg = new dn(t), this._leftDepth = e;
  };

  Gn.prototype.compareTo = function (t) {
    var e = t;
    if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
    if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;

    var n = this._upwardSeg.orientationIndex(e._upwardSeg);

    return 0 !== n ? n : 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg);
  }, Gn.prototype.compareX = function (t, e) {
    var n = t.p0.compareTo(e.p0);
    return 0 !== n ? n : t.p1.compareTo(e.p1);
  }, Gn.prototype.toString = function () {
    return this._upwardSeg.toString();
  }, Gn.prototype.interfaces_ = function () {
    return [E];
  }, Gn.prototype.getClass = function () {
    return Gn;
  };

  var qn = function (t, e, n) {
    this.p0 = t || null, this.p1 = e || null, this.p2 = n || null;
  };

  qn.prototype.area = function () {
    return qn.area(this.p0, this.p1, this.p2);
  }, qn.prototype.signedArea = function () {
    return qn.signedArea(this.p0, this.p1, this.p2);
  }, qn.prototype.interpolateZ = function (t) {
    if (null === t) throw new m("Supplied point is null.");
    return qn.interpolateZ(t, this.p0, this.p1, this.p2);
  }, qn.prototype.longestSideLength = function () {
    return qn.longestSideLength(this.p0, this.p1, this.p2);
  }, qn.prototype.isAcute = function () {
    return qn.isAcute(this.p0, this.p1, this.p2);
  }, qn.prototype.circumcentre = function () {
    return qn.circumcentre(this.p0, this.p1, this.p2);
  }, qn.prototype.area3D = function () {
    return qn.area3D(this.p0, this.p1, this.p2);
  }, qn.prototype.centroid = function () {
    return qn.centroid(this.p0, this.p1, this.p2);
  }, qn.prototype.inCentre = function () {
    return qn.inCentre(this.p0, this.p1, this.p2);
  }, qn.prototype.interfaces_ = function () {
    return [];
  }, qn.prototype.getClass = function () {
    return qn;
  }, qn.area = function (t, e, n) {
    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);
  }, qn.signedArea = function (t, e, n) {
    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;
  }, qn.det = function (t, e, n, i) {
    return t * i - e * n;
  }, qn.interpolateZ = function (t, e, n, i) {
    var r = e.x,
        o = e.y,
        s = n.x - r,
        a = i.x - r,
        u = n.y - o,
        l = i.y - o,
        c = s * l - a * u,
        p = t.x - r,
        h = t.y - o,
        f = (l * p - a * h) / c,
        g = (-u * p + s * h) / c;
    return e.z + f * (n.z - e.z) + g * (i.z - e.z);
  }, qn.longestSideLength = function (t, e, n) {
    var i = t.distance(e),
        r = e.distance(n),
        o = n.distance(t),
        s = i;
    return r > s && (s = r), o > s && (s = o), s;
  }, qn.isAcute = function (t, e, n) {
    return !!Tn.isAcute(t, e, n) && !!Tn.isAcute(e, n, t) && !!Tn.isAcute(n, t, e);
  }, qn.circumcentre = function (t, e, n) {
    var i = n.x,
        r = n.y,
        o = t.x - i,
        s = t.y - r,
        a = e.x - i,
        u = e.y - r,
        l = 2 * qn.det(o, s, a, u),
        c = qn.det(s, o * o + s * s, u, a * a + u * u),
        p = qn.det(o, o * o + s * s, a, a * a + u * u);
    return new C(i - c / l, r + p / l);
  }, qn.perpendicularBisector = function (t, e) {
    var n = e.x - t.x,
        i = e.y - t.y,
        r = new k(t.x + n / 2, t.y + i / 2, 1),
        o = new k(t.x - i + n / 2, t.y + n + i / 2, 1);
    return new k(r, o);
  }, qn.angleBisector = function (t, e, n) {
    var i = e.distance(t),
        r = i / (i + e.distance(n)),
        o = n.x - t.x,
        s = n.y - t.y;
    return new C(t.x + r * o, t.y + r * s);
  }, qn.area3D = function (t, e, n) {
    var i = e.x - t.x,
        r = e.y - t.y,
        o = e.z - t.z,
        s = n.x - t.x,
        a = n.y - t.y,
        u = n.z - t.z,
        l = r * u - o * a,
        c = o * s - i * u,
        p = i * a - r * s,
        h = l * l + c * c + p * p,
        f = Math.sqrt(h) / 2;
    return f;
  }, qn.centroid = function (t, e, n) {
    var i = (t.x + e.x + n.x) / 3,
        r = (t.y + e.y + n.y) / 3;
    return new C(i, r);
  }, qn.inCentre = function (t, e, n) {
    var i = e.distance(n),
        r = t.distance(n),
        o = t.distance(e),
        s = i + r + o,
        a = (i * t.x + r * e.x + o * n.x) / s,
        u = (i * t.y + r * e.y + o * n.y) / s;
    return new C(a, u);
  };

  var Bn = function () {
    this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2];
    this._inputGeom = t, this._distance = e, this._curveBuilder = n;
  };

  Bn.prototype.addPoint = function (t) {
    if (this._distance <= 0) return null;

    var e = t.getCoordinates(),
        n = this._curveBuilder.getLineCurve(e, this._distance);

    this.addCurve(n, w.EXTERIOR, w.INTERIOR);
  }, Bn.prototype.addPolygon = function (t) {
    var e = this._distance,
        n = Se.LEFT;
    this._distance < 0 && (e = -this._distance, n = Se.RIGHT);
    var i = t.getExteriorRing(),
        r = Lt.removeRepeatedPoints(i.getCoordinates());
    if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null;
    if (this._distance <= 0 && r.length < 3) return null;
    this.addPolygonRing(r, e, n, w.EXTERIOR, w.INTERIOR);

    for (var o = 0; o < t.getNumInteriorRing(); o++) {
      var s = t.getInteriorRingN(o),
          a = Lt.removeRepeatedPoints(s.getCoordinates());
      this._distance > 0 && this.isErodedCompletely(s, -this._distance) || this.addPolygonRing(a, e, Se.opposite(n), w.INTERIOR, w.EXTERIOR);
    }
  }, Bn.prototype.isTriangleErodedCompletely = function (t, e) {
    var n = new qn(t[0], t[1], t[2]),
        i = n.inCentre();
    return at.distancePointLine(i, n.p0, n.p1) < Math.abs(e);
  }, Bn.prototype.addLineString = function (t) {
    if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;

    var e = Lt.removeRepeatedPoints(t.getCoordinates()),
        n = this._curveBuilder.getLineCurve(e, this._distance);

    this.addCurve(n, w.EXTERIOR, w.INTERIOR);
  }, Bn.prototype.addCurve = function (t, e, n) {
    if (null === t || t.length < 2) return null;
    var i = new gn(t, new Pe(0, w.BOUNDARY, e, n));

    this._curveList.add(i);
  }, Bn.prototype.getCurves = function () {
    return this.add(this._inputGeom), this._curveList;
  }, Bn.prototype.addPolygonRing = function (t, e, n, i, r) {
    if (0 === e && t.length < ee.MINIMUM_VALID_SIZE) return null;
    var o = i,
        s = r;
    t.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t) && (o = r, s = i, n = Se.opposite(n));

    var a = this._curveBuilder.getRingCurve(t, n, e);

    this.addCurve(a, o, s);
  }, Bn.prototype.add = function (t) {
    if (t.isEmpty()) return null;
    t instanceof $t ? this.addPolygon(t) : t instanceof Kt ? this.addLineString(t) : t instanceof Qt ? this.addPoint(t) : t instanceof te ? this.addCollection(t) : t instanceof Xt ? this.addCollection(t) : t instanceof ne ? this.addCollection(t) : t instanceof zt && this.addCollection(t);
  }, Bn.prototype.isErodedCompletely = function (t, e) {
    var n = t.getCoordinates();
    if (n.length < 4) return e < 0;
    if (4 === n.length) return this.isTriangleErodedCompletely(n, e);
    var i = t.getEnvelopeInternal(),
        r = Math.min(i.getHeight(), i.getWidth());
    return e < 0 && 2 * Math.abs(e) > r;
  }, Bn.prototype.addCollection = function (t) {
    for (var e = 0; e < t.getNumGeometries(); e++) {
      var n = t.getGeometryN(e);
      this.add(n);
    }
  }, Bn.prototype.interfaces_ = function () {
    return [];
  }, Bn.prototype.getClass = function () {
    return Bn;
  };

  var Vn = function () {};

  Vn.prototype.locate = function (t) {}, Vn.prototype.interfaces_ = function () {
    return [];
  }, Vn.prototype.getClass = function () {
    return Vn;
  };

  var Un = function () {
    this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
    var t = arguments[0];
    this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries();
  };

  Un.prototype.next = function () {
    if (this._atStart) return this._atStart = !1, Un.isAtomic(this._parent) && this._index++, this._parent;

    if (null !== this._subcollectionIterator) {
      if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
      this._subcollectionIterator = null;
    }

    if (this._index >= this._max) throw new i();

    var t = this._parent.getGeometryN(this._index++);

    return t instanceof zt ? (this._subcollectionIterator = new Un(t), this._subcollectionIterator.next()) : t;
  }, Un.prototype.remove = function () {
    throw new Error(this.getClass().getName());
  }, Un.prototype.hasNext = function () {
    if (this._atStart) return !0;

    if (null !== this._subcollectionIterator) {
      if (this._subcollectionIterator.hasNext()) return !0;
      this._subcollectionIterator = null;
    }

    return !(this._index >= this._max);
  }, Un.prototype.interfaces_ = function () {
    return [Et];
  }, Un.prototype.getClass = function () {
    return Un;
  }, Un.isAtomic = function (t) {
    return !(t instanceof zt);
  };

  var zn = function () {
    this._geom = null;
    var t = arguments[0];
    this._geom = t;
  };

  zn.prototype.locate = function (t) {
    return zn.locate(t, this._geom);
  }, zn.prototype.interfaces_ = function () {
    return [Vn];
  }, zn.prototype.getClass = function () {
    return zn;
  }, zn.isPointInRing = function (t, e) {
    return !!e.getEnvelopeInternal().intersects(t) && at.isPointInRing(t, e.getCoordinates());
  }, zn.containsPointInPolygon = function (t, e) {
    if (e.isEmpty()) return !1;
    var n = e.getExteriorRing();
    if (!zn.isPointInRing(t, n)) return !1;

    for (var i = 0; i < e.getNumInteriorRing(); i++) {
      var r = e.getInteriorRingN(i);
      if (zn.isPointInRing(t, r)) return !1;
    }

    return !0;
  }, zn.containsPoint = function (t, e) {
    if (e instanceof $t) return zn.containsPointInPolygon(t, e);
    if (e instanceof zt) for (var n = new Un(e); n.hasNext();) {
      var i = n.next();
      if (i !== e && zn.containsPoint(t, i)) return !0;
    }
    return !1;
  }, zn.locate = function (t, e) {
    return e.isEmpty() ? w.EXTERIOR : zn.containsPoint(t, e) ? w.INTERIOR : w.EXTERIOR;
  };

  var Xn = function () {
    this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];
  };

  Xn.prototype.getNextCW = function (t) {
    this.getEdges();

    var e = this._edgeList.indexOf(t),
        n = e - 1;

    return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n);
  }, Xn.prototype.propagateSideLabels = function (t) {
    for (var e = w.NONE, n = this.iterator(); n.hasNext();) {
      var i = n.next().getLabel();
      i.isArea(t) && i.getLocation(t, Se.LEFT) !== w.NONE && (e = i.getLocation(t, Se.LEFT));
    }

    if (e === w.NONE) return null;

    for (var r = e, o = this.iterator(); o.hasNext();) {
      var s = o.next(),
          a = s.getLabel();

      if (a.getLocation(t, Se.ON) === w.NONE && a.setLocation(t, Se.ON, r), a.isArea(t)) {
        var u = a.getLocation(t, Se.LEFT),
            l = a.getLocation(t, Se.RIGHT);

        if (l !== w.NONE) {
          if (l !== r) throw new we("side location conflict", s.getCoordinate());
          u === w.NONE && et.shouldNeverReachHere("found single null side (at " + s.getCoordinate() + ")"), r = u;
        } else et.isTrue(a.getLocation(t, Se.LEFT) === w.NONE, "found single null side"), a.setLocation(t, Se.RIGHT, r), a.setLocation(t, Se.LEFT, r);
      }
    }
  }, Xn.prototype.getCoordinate = function () {
    var t = this.iterator();
    if (!t.hasNext()) return null;
    return t.next().getCoordinate();
  }, Xn.prototype.print = function (t) {
    Y.out.println("EdgeEndStar:   " + this.getCoordinate());

    for (var e = this.iterator(); e.hasNext();) {
      e.next().print(t);
    }
  }, Xn.prototype.isAreaLabelsConsistent = function (t) {
    return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
  }, Xn.prototype.checkAreaLabelsConsistent = function (t) {
    var e = this.getEdges();
    if (e.size() <= 0) return !0;
    var n = e.size() - 1,
        i = e.get(n).getLabel().getLocation(t, Se.LEFT);
    et.isTrue(i !== w.NONE, "Found unlabelled area edge");

    for (var r = i, o = this.iterator(); o.hasNext();) {
      var s = o.next().getLabel();
      et.isTrue(s.isArea(t), "Found non-area edge");
      var a = s.getLocation(t, Se.LEFT),
          u = s.getLocation(t, Se.RIGHT);
      if (a === u) return !1;
      if (u !== r) return !1;
      r = a;
    }

    return !0;
  }, Xn.prototype.findIndex = function (t) {
    this.iterator();

    for (var e = 0; e < this._edgeList.size(); e++) {
      if (this._edgeList.get(e) === t) return e;
    }

    return -1;
  }, Xn.prototype.iterator = function () {
    return this.getEdges().iterator();
  }, Xn.prototype.getEdges = function () {
    return null === this._edgeList && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;
  }, Xn.prototype.getLocation = function (t, e, n) {
    return this._ptInAreaLocation[t] === w.NONE && (this._ptInAreaLocation[t] = zn.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t];
  }, Xn.prototype.toString = function () {
    var t = new D();
    t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");

    for (var e = this.iterator(); e.hasNext();) {
      var n = e.next();
      t.append(n), t.append("\n");
    }

    return t.toString();
  }, Xn.prototype.computeEdgeEndLabels = function (t) {
    for (var e = this.iterator(); e.hasNext();) {
      e.next().computeLabel(t);
    }
  }, Xn.prototype.computeLabelling = function (t) {
    this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);

    for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var i = n.next().getLabel(), r = 0; r < 2; r++) i.isLine(r) && i.getLocation(r) === w.BOUNDARY && (e[r] = !0);

    for (var o = this.iterator(); o.hasNext();) for (var s = o.next(), a = s.getLabel(), u = 0; u < 2; u++) if (a.isAnyNull(u)) {
      var l = w.NONE;
      if (e[u]) l = w.EXTERIOR;else {
        var c = s.getCoordinate();
        l = this.getLocation(u, c, t);
      }
      a.setAllLocationsIfNull(u, l);
    }
  }, Xn.prototype.getDegree = function () {
    return this._edgeMap.size();
  }, Xn.prototype.insertEdgeEnd = function (t, e) {
    this._edgeMap.put(t, e), this._edgeList = null;
  }, Xn.prototype.interfaces_ = function () {
    return [];
  }, Xn.prototype.getClass = function () {
    return Xn;
  };

  var Yn = function (t) {
    function e() {
      t.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.linkResultDirectedEdges = function () {
      this.getResultAreaEdges();

      for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, i = 0; i < this._resultAreaEdgeList.size(); i++) {
        var r = this._resultAreaEdgeList.get(i),
            o = r.getSym();

        if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {
          case this._SCANNING_FOR_INCOMING:
            if (!o.isInResult()) continue;
            e = o, n = this._LINKING_TO_OUTGOING;
            break;

          case this._LINKING_TO_OUTGOING:
            if (!r.isInResult()) continue;
            e.setNext(r), n = this._SCANNING_FOR_INCOMING;
        }
      }

      if (n === this._LINKING_TO_OUTGOING) {
        if (null === t) throw new we("no outgoing dirEdge found", this.getCoordinate());
        et.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t);
      }
    }, e.prototype.insert = function (t) {
      var e = t;
      this.insertEdgeEnd(e, e);
    }, e.prototype.getRightmostEdge = function () {
      var t = this.getEdges(),
          e = t.size();
      if (e < 1) return null;
      var n = t.get(0);
      if (1 === e) return n;
      var i = t.get(e - 1),
          r = n.getQuadrant(),
          o = i.getQuadrant();
      return Be.isNorthern(r) && Be.isNorthern(o) ? n : Be.isNorthern(r) || Be.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i;
    }, e.prototype.print = function (t) {
      Y.out.println("DirectedEdgeStar: " + this.getCoordinate());

      for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();
        t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println();
      }
    }, e.prototype.getResultAreaEdges = function () {
      if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
      this._resultAreaEdgeList = new Nt();

      for (var t = this.iterator(); t.hasNext();) {
        var e = t.next();
        (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e);
      }

      return this._resultAreaEdgeList;
    }, e.prototype.updateLabelling = function (t) {
      for (var e = this.iterator(); e.hasNext();) {
        var n = e.next().getLabel();
        n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1));
      }
    }, e.prototype.linkAllDirectedEdges = function () {
      this.getEdges();

      for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {
        var i = this._edgeList.get(n),
            r = i.getSym();

        null === e && (e = r), null !== t && r.setNext(t), t = i;
      }

      e.setNext(t);
    }, e.prototype.computeDepths = function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = this.findIndex(t),
            n = t.getDepth(Se.LEFT),
            i = t.getDepth(Se.RIGHT),
            r = this.computeDepths(e + 1, this._edgeList.size(), n);
        if (this.computeDepths(0, e, r) !== i) throw new we("depth mismatch at " + t.getCoordinate());
      } else if (3 === arguments.length) {
        for (var o = arguments[0], s = arguments[1], a = arguments[2], u = o; u < s; u++) {
          var l = this._edgeList.get(u);

          l.setEdgeDepths(Se.RIGHT, a), a = l.getDepth(Se.LEFT);
        }

        return a;
      }
    }, e.prototype.mergeSymLabels = function () {
      for (var t = this.iterator(); t.hasNext();) {
        var e = t.next();
        e.getLabel().merge(e.getSym().getLabel());
      }
    }, e.prototype.linkMinimalDirectedEdges = function (t) {
      for (var e = null, n = null, i = this._SCANNING_FOR_INCOMING, r = this._resultAreaEdgeList.size() - 1; r >= 0; r--) {
        var o = this._resultAreaEdgeList.get(r),
            s = o.getSym();

        switch (null === e && o.getEdgeRing() === t && (e = o), i) {
          case this._SCANNING_FOR_INCOMING:
            if (s.getEdgeRing() !== t) continue;
            n = s, i = this._LINKING_TO_OUTGOING;
            break;

          case this._LINKING_TO_OUTGOING:
            if (o.getEdgeRing() !== t) continue;
            n.setNextMin(o), i = this._SCANNING_FOR_INCOMING;
        }
      }

      i === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e, "found null for first outgoing dirEdge"), et.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e));
    }, e.prototype.getOutgoingDegree = function () {
      if (0 === arguments.length) {
        for (var t = 0, e = this.iterator(); e.hasNext();) {
          e.next().isInResult() && t++;
        }

        return t;
      }

      if (1 === arguments.length) {
        for (var n = arguments[0], i = 0, r = this.iterator(); r.hasNext();) {
          r.next().getEdgeRing() === n && i++;
        }

        return i;
      }
    }, e.prototype.getLabel = function () {
      return this._label;
    }, e.prototype.findCoveredLineEdges = function () {
      for (var t = w.NONE, e = this.iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getSym();

        if (!n.isLineEdge()) {
          if (n.isInResult()) {
            t = w.INTERIOR;
            break;
          }

          if (i.isInResult()) {
            t = w.EXTERIOR;
            break;
          }
        }
      }

      if (t === w.NONE) return null;

      for (var r = t, o = this.iterator(); o.hasNext();) {
        var s = o.next(),
            a = s.getSym();
        s.isLineEdge() ? s.getEdge().setCovered(r === w.INTERIOR) : (s.isInResult() && (r = w.EXTERIOR), a.isInResult() && (r = w.INTERIOR));
      }
    }, e.prototype.computeLabelling = function (e) {
      t.prototype.computeLabelling.call(this, e), this._label = new Pe(w.NONE);

      for (var n = this.iterator(); n.hasNext();) for (var i = n.next().getEdge().getLabel(), r = 0; r < 2; r++) {
        var o = i.getLocation(r);
        o !== w.INTERIOR && o !== w.BOUNDARY || this._label.setLocation(r, w.INTERIOR);
      }
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(Xn),
      kn = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createNode = function (t) {
      return new Ge(t, new Yn());
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(Xe),
      jn = function t() {
    this._pts = null, this._orientation = null;
    var e = arguments[0];
    this._pts = e, this._orientation = t.orientation(e);
  };

  jn.prototype.compareTo = function (t) {
    var e = t;
    return jn.compareOriented(this._pts, this._orientation, e._pts, e._orientation);
  }, jn.prototype.interfaces_ = function () {
    return [E];
  }, jn.prototype.getClass = function () {
    return jn;
  }, jn.orientation = function (t) {
    return 1 === Lt.increasingDirection(t);
  }, jn.compareOriented = function (t, e, n, i) {
    for (var r = e ? 1 : -1, o = i ? 1 : -1, s = e ? t.length : -1, a = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1;;) {
      var c = t[u].compareTo(n[l]);
      if (0 !== c) return c;
      var p = (u += r) === s,
          h = (l += o) === a;
      if (p && !h) return -1;
      if (!p && h) return 1;
      if (p && h) return 0;
    }
  };

  var Hn = function () {
    this._edges = new Nt(), this._ocaMap = new p();
  };

  Hn.prototype.print = function (t) {
    t.print("MULTILINESTRING ( ");

    for (var e = 0; e < this._edges.size(); e++) {
      var n = this._edges.get(e);

      e > 0 && t.print(","), t.print("(");

      for (var i = n.getCoordinates(), r = 0; r < i.length; r++) r > 0 && t.print(","), t.print(i[r].x + " " + i[r].y);

      t.println(")");
    }

    t.print(")  ");
  }, Hn.prototype.addAll = function (t) {
    for (var e = t.iterator(); e.hasNext();) this.add(e.next());
  }, Hn.prototype.findEdgeIndex = function (t) {
    for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;

    return -1;
  }, Hn.prototype.iterator = function () {
    return this._edges.iterator();
  }, Hn.prototype.getEdges = function () {
    return this._edges;
  }, Hn.prototype.get = function (t) {
    return this._edges.get(t);
  }, Hn.prototype.findEqualEdge = function (t) {
    var e = new jn(t.getCoordinates());
    return this._ocaMap.get(e);
  }, Hn.prototype.add = function (t) {
    this._edges.add(t);

    var e = new jn(t.getCoordinates());

    this._ocaMap.put(e, t);
  }, Hn.prototype.interfaces_ = function () {
    return [];
  }, Hn.prototype.getClass = function () {
    return Hn;
  };

  var Wn = function () {};

  Wn.prototype.processIntersections = function (t, e, n, i) {}, Wn.prototype.isDone = function () {}, Wn.prototype.interfaces_ = function () {
    return [];
  }, Wn.prototype.getClass = function () {
    return Wn;
  };

  var Kn = function () {
    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
    var t = arguments[0];
    this._li = t;
  };

  Kn.prototype.isTrivialIntersection = function (t, e, n, i) {
    if (t === n && 1 === this._li.getIntersectionNum()) {
      if (Kn.isAdjacentSegments(e, i)) return !0;

      if (t.isClosed()) {
        var r = t.size() - 1;
        if (0 === e && i === r || 0 === i && e === r) return !0;
      }
    }

    return !1;
  }, Kn.prototype.getProperIntersectionPoint = function () {
    return this._properIntersectionPoint;
  }, Kn.prototype.hasProperInteriorIntersection = function () {
    return this._hasProperInterior;
  }, Kn.prototype.getLineIntersector = function () {
    return this._li;
  }, Kn.prototype.hasProperIntersection = function () {
    return this._hasProper;
  }, Kn.prototype.processIntersections = function (t, e, n, i) {
    if (t === n && e === i) return null;
    this.numTests++;
    var r = t.getCoordinates()[e],
        o = t.getCoordinates()[e + 1],
        s = n.getCoordinates()[i],
        a = n.getCoordinates()[i + 1];
    this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
  }, Kn.prototype.hasIntersection = function () {
    return this._hasIntersection;
  }, Kn.prototype.isDone = function () {
    return !1;
  }, Kn.prototype.hasInteriorIntersection = function () {
    return this._hasInterior;
  }, Kn.prototype.interfaces_ = function () {
    return [Wn];
  }, Kn.prototype.getClass = function () {
    return Kn;
  }, Kn.isAdjacentSegments = function (t, e) {
    return 1 === Math.abs(t - e);
  };

  var Jn = function () {
    this.coord = null, this.segmentIndex = null, this.dist = null;
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2];
    this.coord = new C(t), this.segmentIndex = e, this.dist = n;
  };

  Jn.prototype.getSegmentIndex = function () {
    return this.segmentIndex;
  }, Jn.prototype.getCoordinate = function () {
    return this.coord;
  }, Jn.prototype.print = function (t) {
    t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist);
  }, Jn.prototype.compareTo = function (t) {
    var e = t;
    return this.compare(e.segmentIndex, e.dist);
  }, Jn.prototype.isEndPoint = function (t) {
    return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;
  }, Jn.prototype.toString = function () {
    return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
  }, Jn.prototype.getDistance = function () {
    return this.dist;
  }, Jn.prototype.compare = function (t, e) {
    return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;
  }, Jn.prototype.interfaces_ = function () {
    return [E];
  }, Jn.prototype.getClass = function () {
    return Jn;
  };

  var Qn = function () {
    this._nodeMap = new p(), this.edge = null;
    var t = arguments[0];
    this.edge = t;
  };

  Qn.prototype.print = function (t) {
    t.println("Intersections:");

    for (var e = this.iterator(); e.hasNext();) {
      e.next().print(t);
    }
  }, Qn.prototype.iterator = function () {
    return this._nodeMap.values().iterator();
  }, Qn.prototype.addSplitEdges = function (t) {
    this.addEndpoints();

    for (var e = this.iterator(), n = e.next(); e.hasNext();) {
      var i = e.next(),
          r = this.createSplitEdge(n, i);
      t.add(r), n = i;
    }
  }, Qn.prototype.addEndpoints = function () {
    var t = this.edge.pts.length - 1;
    this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);
  }, Qn.prototype.createSplitEdge = function (t, e) {
    var n = e.segmentIndex - t.segmentIndex + 2,
        i = this.edge.pts[e.segmentIndex],
        r = e.dist > 0 || !e.coord.equals2D(i);
    r || n--;
    var o = new Array(n).fill(null),
        s = 0;
    o[s++] = new C(t.coord);

    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.pts[a];

    return r && (o[s] = e.coord), new ni(o, new Pe(this.edge._label));
  }, Qn.prototype.add = function (t, e, n) {
    var i = new Jn(t, e, n),
        r = this._nodeMap.get(i);

    return null !== r ? r : (this._nodeMap.put(i, i), i);
  }, Qn.prototype.isIntersection = function (t) {
    for (var e = this.iterator(); e.hasNext();) {
      if (e.next().coord.equals(t)) return !0;
    }

    return !1;
  }, Qn.prototype.interfaces_ = function () {
    return [];
  }, Qn.prototype.getClass = function () {
    return Qn;
  };

  var Zn = function () {};

  Zn.prototype.getChainStartIndices = function (t) {
    var e = 0,
        n = new Nt();
    n.add(new M(e));

    do {
      var i = this.findChainEnd(t, e);
      n.add(new M(i)), e = i;
    } while (e < t.length - 1);

    return Zn.toIntArray(n);
  }, Zn.prototype.findChainEnd = function (t, e) {
    for (var n = Be.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {
      if (Be.quadrant(t[i - 1], t[i]) !== n) break;
      i++;
    }

    return i - 1;
  }, Zn.prototype.interfaces_ = function () {
    return [];
  }, Zn.prototype.getClass = function () {
    return Zn;
  }, Zn.toIntArray = function (t) {
    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();

    return e;
  };

  var $n = function () {
    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();
    var t = arguments[0];
    this.e = t, this.pts = t.getCoordinates();
    var e = new Zn();
    this.startIndex = e.getChainStartIndices(this.pts);
  };

  $n.prototype.getCoordinates = function () {
    return this.pts;
  }, $n.prototype.getMaxX = function (t) {
    var e = this.pts[this.startIndex[t]].x,
        n = this.pts[this.startIndex[t + 1]].x;
    return e > n ? e : n;
  }, $n.prototype.getMinX = function (t) {
    var e = this.pts[this.startIndex[t]].x,
        n = this.pts[this.startIndex[t + 1]].x;
    return e < n ? e : n;
  }, $n.prototype.computeIntersectsForChain = function () {
    if (4 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = arguments[3];
      this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);
    } else if (6 === arguments.length) {
      var r = arguments[0],
          o = arguments[1],
          s = arguments[2],
          a = arguments[3],
          u = arguments[4],
          l = arguments[5],
          c = this.pts[r],
          p = this.pts[o],
          h = s.pts[a],
          f = s.pts[u];
      if (o - r == 1 && u - a == 1) return l.addIntersections(this.e, r, s.e, a), null;
      if (this.env1.init(c, p), this.env2.init(h, f), !this.env1.intersects(this.env2)) return null;
      var g = Math.trunc((r + o) / 2),
          d = Math.trunc((a + u) / 2);
      r < g && (a < d && this.computeIntersectsForChain(r, g, s, a, d, l), d < u && this.computeIntersectsForChain(r, g, s, d, u, l)), g < o && (a < d && this.computeIntersectsForChain(g, o, s, a, d, l), d < u && this.computeIntersectsForChain(g, o, s, d, u, l));
    }
  }, $n.prototype.getStartIndexes = function () {
    return this.startIndex;
  }, $n.prototype.computeIntersects = function (t, e) {
    for (var n = 0; n < this.startIndex.length - 1; n++) for (var i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e);
  }, $n.prototype.interfaces_ = function () {
    return [];
  }, $n.prototype.getClass = function () {
    return $n;
  };

  var ti = function t() {
    this._depth = Array(2).fill().map(function () {
      return Array(3);
    });

    for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE;
  },
      ei = {
    NULL_VALUE: {
      configurable: !0
    }
  };

  ti.prototype.getDepth = function (t, e) {
    return this._depth[t][e];
  }, ti.prototype.setDepth = function (t, e, n) {
    this._depth[t][e] = n;
  }, ti.prototype.isNull = function () {
    if (0 === arguments.length) {
      for (var t = 0; t < 2; t++) for (var e = 0; e < 3; e++) if (this._depth[t][e] !== ti.NULL_VALUE) return !1;

      return !0;
    }

    if (1 === arguments.length) {
      var n = arguments[0];
      return this._depth[n][1] === ti.NULL_VALUE;
    }

    if (2 === arguments.length) {
      var i = arguments[0],
          r = arguments[1];
      return this._depth[i][r] === ti.NULL_VALUE;
    }
  }, ti.prototype.normalize = function () {
    for (var t = 0; t < 2; t++) if (!this.isNull(t)) {
      var e = this._depth[t][1];
      this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);

      for (var n = 1; n < 3; n++) {
        var i = 0;
        this._depth[t][n] > e && (i = 1), this._depth[t][n] = i;
      }
    }
  }, ti.prototype.getDelta = function (t) {
    return this._depth[t][Se.RIGHT] - this._depth[t][Se.LEFT];
  }, ti.prototype.getLocation = function (t, e) {
    return this._depth[t][e] <= 0 ? w.EXTERIOR : w.INTERIOR;
  }, ti.prototype.toString = function () {
    return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
  }, ti.prototype.add = function () {
    if (1 === arguments.length) for (var t = arguments[0], e = 0; e < 2; e++) for (var n = 1; n < 3; n++) {
      var i = t.getLocation(e, n);
      i !== w.EXTERIOR && i !== w.INTERIOR || (this.isNull(e, n) ? this._depth[e][n] = ti.depthAtLocation(i) : this._depth[e][n] += ti.depthAtLocation(i));
    } else if (3 === arguments.length) {
      var r = arguments[0],
          o = arguments[1];
      arguments[2] === w.INTERIOR && this._depth[r][o]++;
    }
  }, ti.prototype.interfaces_ = function () {
    return [];
  }, ti.prototype.getClass = function () {
    return ti;
  }, ti.depthAtLocation = function (t) {
    return t === w.EXTERIOR ? 0 : t === w.INTERIOR ? 1 : ti.NULL_VALUE;
  }, ei.NULL_VALUE.get = function () {
    return -1;
  }, Object.defineProperties(ti, ei);

  var ni = function (t) {
    function e() {
      if (t.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new ti(), this._depthDelta = 0, 1 === arguments.length) {
        var n = arguments[0];
        e.call(this, n, null);
      } else if (2 === arguments.length) {
        var i = arguments[0],
            r = arguments[1];
        this.pts = i, this._label = r;
      }
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDepth = function () {
      return this._depth;
    }, e.prototype.getCollapsedEdge = function () {
      var t = new Array(2).fill(null);
      t[0] = this.pts[0], t[1] = this.pts[1];
      return new e(t, Pe.toLineLabel(this._label));
    }, e.prototype.isIsolated = function () {
      return this._isIsolated;
    }, e.prototype.getCoordinates = function () {
      return this.pts;
    }, e.prototype.setIsolated = function (t) {
      this._isIsolated = t;
    }, e.prototype.setName = function (t) {
      this._name = t;
    }, e.prototype.equals = function (t) {
      if (!(t instanceof e)) return !1;
      var n = t;
      if (this.pts.length !== n.pts.length) return !1;

      for (var i = !0, r = !0, o = this.pts.length, s = 0; s < this.pts.length; s++) if (this.pts[s].equals2D(n.pts[s]) || (i = !1), this.pts[s].equals2D(n.pts[--o]) || (r = !1), !i && !r) return !1;

      return !0;
    }, e.prototype.getCoordinate = function () {
      if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;

      if (1 === arguments.length) {
        var t = arguments[0];
        return this.pts[t];
      }
    }, e.prototype.print = function (t) {
      t.print("edge " + this._name + ": "), t.print("LINESTRING (");

      for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);

      t.print(")  " + this._label + " " + this._depthDelta);
    }, e.prototype.computeIM = function (t) {
      e.updateIM(this._label, t);
    }, e.prototype.isCollapsed = function () {
      return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);
    }, e.prototype.isClosed = function () {
      return this.pts[0].equals(this.pts[this.pts.length - 1]);
    }, e.prototype.getMaximumSegmentIndex = function () {
      return this.pts.length - 1;
    }, e.prototype.getDepthDelta = function () {
      return this._depthDelta;
    }, e.prototype.getNumPoints = function () {
      return this.pts.length;
    }, e.prototype.printReverse = function (t) {
      t.print("edge " + this._name + ": ");

      for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + " ");

      t.println("");
    }, e.prototype.getMonotoneChainEdge = function () {
      return null === this._mce && (this._mce = new $n(this)), this._mce;
    }, e.prototype.getEnvelope = function () {
      if (null === this._env) {
        this._env = new j();

        for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t]);
      }

      return this._env;
    }, e.prototype.addIntersection = function (t, e, n, i) {
      var r = new C(t.getIntersection(i)),
          o = e,
          s = t.getEdgeDistance(n, i),
          a = o + 1;

      if (a < this.pts.length) {
        var u = this.pts[a];
        r.equals2D(u) && (o = a, s = 0);
      }

      this.eiList.add(r, o, s);
    }, e.prototype.toString = function () {
      var t = new D();
      t.append("edge " + this._name + ": "), t.append("LINESTRING (");

      for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);

      return t.append(")  " + this._label + " " + this._depthDelta), t.toString();
    }, e.prototype.isPointwiseEqual = function (t) {
      if (this.pts.length !== t.pts.length) return !1;

      for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;

      return !0;
    }, e.prototype.setDepthDelta = function (t) {
      this._depthDelta = t;
    }, e.prototype.getEdgeIntersectionList = function () {
      return this.eiList;
    }, e.prototype.addIntersections = function (t, e, n) {
      for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e.updateIM = function () {
      if (2 !== arguments.length) return t.prototype.updateIM.apply(this, arguments);
      var e = arguments[0],
          n = arguments[1];
      n.setAtLeastIfValid(e.getLocation(0, Se.ON), e.getLocation(1, Se.ON), 1), e.isArea() && (n.setAtLeastIfValid(e.getLocation(0, Se.LEFT), e.getLocation(1, Se.LEFT), 2), n.setAtLeastIfValid(e.getLocation(0, Se.RIGHT), e.getLocation(1, Se.RIGHT), 2));
    }, e;
  }(Fe),
      ii = function (t) {
    this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t || null;
  };

  ii.prototype.setWorkingPrecisionModel = function (t) {
    this._workingPrecisionModel = t;
  }, ii.prototype.insertUniqueEdge = function (t) {
    var e = this._edgeList.findEqualEdge(t);

    if (null !== e) {
      var n = e.getLabel(),
          i = t.getLabel();
      e.isPointwiseEqual(t) || (i = new Pe(t.getLabel())).flip(), n.merge(i);
      var r = ii.depthDelta(i),
          o = e.getDepthDelta() + r;
      e.setDepthDelta(o);
    } else this._edgeList.add(t), t.setDepthDelta(ii.depthDelta(t.getLabel()));
  }, ii.prototype.buildSubgraphs = function (t, e) {
    for (var n = new Nt(), i = t.iterator(); i.hasNext();) {
      var r = i.next(),
          o = r.getRightmostCoordinate(),
          s = new An(n).getDepth(o);
      r.computeDepth(s), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes());
    }
  }, ii.prototype.createSubgraphs = function (t) {
    for (var e = new Nt(), n = t.getNodes().iterator(); n.hasNext();) {
      var i = n.next();

      if (!i.isVisited()) {
        var r = new Te();
        r.create(i), e.add(r);
      }
    }

    return $e.sort(e, $e.reverseOrder()), e;
  }, ii.prototype.createEmptyResultGeometry = function () {
    return this._geomFact.createPolygon();
  }, ii.prototype.getNoder = function (t) {
    if (null !== this._workingNoder) return this._workingNoder;
    var e = new xn(),
        n = new rt();
    return n.setPrecisionModel(t), e.setSegmentIntersector(new Kn(n)), e;
  }, ii.prototype.buffer = function (t, e) {
    var n = this._workingPrecisionModel;
    null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();
    var i = new Mn(n, this._bufParams),
        r = new Bn(t, e, i).getCurves();
    if (r.size() <= 0) return this.createEmptyResultGeometry();
    this.computeNodedEdges(r, n), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());
    var o = this.createSubgraphs(this._graph),
        s = new ke(this._geomFact);
    this.buildSubgraphs(o, s);
    var a = s.getPolygons();
    if (a.size() <= 0) return this.createEmptyResultGeometry();
    return this._geomFact.buildGeometry(a);
  }, ii.prototype.computeNodedEdges = function (t, e) {
    var n = this.getNoder(e);
    n.computeNodes(t);

    for (var i = n.getNodedSubstrings().iterator(); i.hasNext();) {
      var r = i.next(),
          o = r.getCoordinates();

      if (2 !== o.length || !o[0].equals2D(o[1])) {
        var s = r.getData(),
            a = new ni(r.getCoordinates(), new Pe(s));
        this.insertUniqueEdge(a);
      }
    }
  }, ii.prototype.setNoder = function (t) {
    this._workingNoder = t;
  }, ii.prototype.interfaces_ = function () {
    return [];
  }, ii.prototype.getClass = function () {
    return ii;
  }, ii.depthDelta = function (t) {
    var e = t.getLocation(0, Se.LEFT),
        n = t.getLocation(0, Se.RIGHT);
    return e === w.INTERIOR && n === w.EXTERIOR ? 1 : e === w.EXTERIOR && n === w.INTERIOR ? -1 : 0;
  }, ii.convertSegStrings = function (t) {
    for (var e = new _e(), n = new Nt(); t.hasNext();) {
      var i = t.next(),
          r = e.createLineString(i.getCoordinates());
      n.add(r);
    }

    return e.buildGeometry(n);
  };

  var ri = function () {
    if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      this._noder = t, this._scaleFactor = e, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
    } else if (4 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2],
          o = arguments[3];
      this._noder = n, this._scaleFactor = i, this._offsetX = r, this._offsetY = o, this._isScaled = !this.isIntegerPrecision();
    }
  };

  ri.prototype.rescale = function () {
    if (T(arguments[0], It)) for (var t = arguments[0].iterator(); t.hasNext();) {
      var e = t.next();
      this.rescale(e.getCoordinates());
    } else if (arguments[0] instanceof Array) {
      for (var n = arguments[0], i = 0; i < n.length; i++) n[i].x = n[i].x / this._scaleFactor + this._offsetX, n[i].y = n[i].y / this._scaleFactor + this._offsetY;

      2 === n.length && n[0].equals2D(n[1]) && Y.out.println(n);
    }
  }, ri.prototype.scale = function () {
    if (T(arguments[0], It)) {
      for (var t = arguments[0], e = new Nt(), n = t.iterator(); n.hasNext();) {
        var i = n.next();
        e.add(new gn(this.scale(i.getCoordinates()), i.getData()));
      }

      return e;
    }

    if (arguments[0] instanceof Array) {
      for (var r = arguments[0], o = new Array(r.length).fill(null), s = 0; s < r.length; s++) o[s] = new C(Math.round((r[s].x - this._offsetX) * this._scaleFactor), Math.round((r[s].y - this._offsetY) * this._scaleFactor), r[s].z);

      return Lt.removeRepeatedPoints(o);
    }
  }, ri.prototype.isIntegerPrecision = function () {
    return 1 === this._scaleFactor;
  }, ri.prototype.getNodedSubstrings = function () {
    var t = this._noder.getNodedSubstrings();

    return this._isScaled && this.rescale(t), t;
  }, ri.prototype.computeNodes = function (t) {
    var e = t;
    this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);
  }, ri.prototype.interfaces_ = function () {
    return [In];
  }, ri.prototype.getClass = function () {
    return ri;
  };

  var oi = function () {
    this._li = new rt(), this._segStrings = null;
    var t = arguments[0];
    this._segStrings = t;
  },
      si = {
    fact: {
      configurable: !0
    }
  };

  oi.prototype.checkEndPtVertexIntersections = function () {
    if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {
      var e = t.next().getCoordinates();
      this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings);
    } else if (2 === arguments.length) for (var n = arguments[0], i = arguments[1].iterator(); i.hasNext();) for (var r = i.next().getCoordinates(), o = 1; o < r.length - 1; o++) if (r[o].equals(n)) throw new $("found endpt/interior pt intersection at index " + o + " :pt " + n);
  }, oi.prototype.checkInteriorIntersections = function () {
    if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) {
      var i = n.next();
      this.checkInteriorIntersections(e, i);
    } else if (2 === arguments.length) for (var r = arguments[0], o = arguments[1], s = r.getCoordinates(), a = o.getCoordinates(), u = 0; u < s.length - 1; u++) for (var l = 0; l < a.length - 1; l++) this.checkInteriorIntersections(r, u, o, l);else if (4 === arguments.length) {
      var c = arguments[0],
          p = arguments[1],
          h = arguments[2],
          f = arguments[3];
      if (c === h && p === f) return null;
      var g = c.getCoordinates()[p],
          d = c.getCoordinates()[p + 1],
          y = h.getCoordinates()[f],
          _ = h.getCoordinates()[f + 1];
      if (this._li.computeIntersection(g, d, y, _), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g, d) || this.hasInteriorIntersection(this._li, y, _))) throw new $("found non-noded intersection at " + g + "-" + d + " and " + y + "-" + _);
    }
  }, oi.prototype.checkValid = function () {
    this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
  }, oi.prototype.checkCollapses = function () {
    if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {
      var e = t.next();
      this.checkCollapses(e);
    } else if (1 === arguments.length) for (var n = arguments[0].getCoordinates(), i = 0; i < n.length - 2; i++) this.checkCollapse(n[i], n[i + 1], n[i + 2]);
  }, oi.prototype.hasInteriorIntersection = function (t, e, n) {
    for (var i = 0; i < t.getIntersectionNum(); i++) {
      var r = t.getIntersection(i);
      if (!r.equals(e) && !r.equals(n)) return !0;
    }

    return !1;
  }, oi.prototype.checkCollapse = function (t, e, n) {
    if (t.equals(n)) throw new $("found non-noded collapse at " + oi.fact.createLineString([t, e, n]));
  }, oi.prototype.interfaces_ = function () {
    return [];
  }, oi.prototype.getClass = function () {
    return oi;
  }, si.fact.get = function () {
    return new _e();
  }, Object.defineProperties(oi, si);

  var ai = function () {
    this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2];
    if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new m("Scale factor must be non-zero");
    1 !== e && (this._pt = new C(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);
  },
      ui = {
    SAFE_ENV_EXPANSION_FACTOR: {
      configurable: !0
    }
  };

  ai.prototype.intersectsScaled = function (t, e) {
    var n = Math.min(t.x, e.x),
        i = Math.max(t.x, e.x),
        r = Math.min(t.y, e.y),
        o = Math.max(t.y, e.y),
        s = this._maxx < n || this._minx > i || this._maxy < r || this._miny > o;
    if (s) return !1;
    var a = this.intersectsToleranceSquare(t, e);
    return et.isTrue(!(s && a), "Found bad envelope test"), a;
  }, ai.prototype.initCorners = function (t) {
    this._minx = t.x - .5, this._maxx = t.x + .5, this._miny = t.y - .5, this._maxy = t.y + .5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);
  }, ai.prototype.intersects = function (t, e) {
    return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
  }, ai.prototype.scale = function (t) {
    return Math.round(t * this._scaleFactor);
  }, ai.prototype.getCoordinate = function () {
    return this._originalPt;
  }, ai.prototype.copyScaled = function (t, e) {
    e.x = this.scale(t.x), e.y = this.scale(t.y);
  }, ai.prototype.getSafeEnvelope = function () {
    if (null === this._safeEnv) {
      var t = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
      this._safeEnv = new j(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t);
    }

    return this._safeEnv;
  }, ai.prototype.intersectsPixelClosure = function (t, e) {
    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
  }, ai.prototype.intersectsToleranceSquare = function (t, e) {
    var n = !1,
        i = !1;
    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!n || !i) || !!t.equals(this._pt) || !!e.equals(this._pt))));
  }, ai.prototype.addSnappedNode = function (t, e) {
    var n = t.getCoordinate(e),
        i = t.getCoordinate(e + 1);
    return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0);
  }, ai.prototype.interfaces_ = function () {
    return [];
  }, ai.prototype.getClass = function () {
    return ai;
  }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function () {
    return .75;
  }, Object.defineProperties(ai, ui);

  var li = function () {
    this.tempEnv1 = new j(), this.selectedSegment = new dn();
  };

  li.prototype.select = function () {
    if (1 === arguments.length) ;else if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment);
    }
  }, li.prototype.interfaces_ = function () {
    return [];
  }, li.prototype.getClass = function () {
    return li;
  };

  var ci = function () {
    this._index = null;
    var t = arguments[0];
    this._index = t;
  },
      pi = {
    HotPixelSnapAction: {
      configurable: !0
    }
  };

  ci.prototype.snap = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.snap(t, null, -1);
    }

    if (3 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2],
          r = e.getSafeEnvelope(),
          o = new hi(e, n, i);
      return this._index.query(r, {
        interfaces_: function () {
          return [Ke];
        },
        visitItem: function (t) {
          t.select(r, o);
        }
      }), o.isNodeAdded();
    }
  }, ci.prototype.interfaces_ = function () {
    return [];
  }, ci.prototype.getClass = function () {
    return ci;
  }, pi.HotPixelSnapAction.get = function () {
    return hi;
  }, Object.defineProperties(ci, pi);

  var hi = function (t) {
    function e() {
      t.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2];
      this._hotPixel = e, this._parentEdge = n, this._hotPixelVertexIndex = i;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isNodeAdded = function () {
      return this._isNodeAdded;
    }, e.prototype.select = function () {
      if (2 !== arguments.length) return t.prototype.select.apply(this, arguments);
      var e = arguments[0],
          n = arguments[1],
          i = e.getContext();
      if (null !== this._parentEdge && i === this._parentEdge && n === this._hotPixelVertexIndex) return null;
      this._isNodeAdded = this._hotPixel.addSnappedNode(i, n);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(li),
      fi = function () {
    this._li = null, this._interiorIntersections = null;
    var t = arguments[0];
    this._li = t, this._interiorIntersections = new Nt();
  };

  fi.prototype.processIntersections = function (t, e, n, i) {
    if (t === n && e === i) return null;
    var r = t.getCoordinates()[e],
        o = t.getCoordinates()[e + 1],
        s = n.getCoordinates()[i],
        a = n.getCoordinates()[i + 1];

    if (this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
      for (var u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u));

      t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1);
    }
  }, fi.prototype.isDone = function () {
    return !1;
  }, fi.prototype.getInteriorIntersections = function () {
    return this._interiorIntersections;
  }, fi.prototype.interfaces_ = function () {
    return [Wn];
  }, fi.prototype.getClass = function () {
    return fi;
  };

  var gi = function () {
    this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
    var t = arguments[0];
    this._pm = t, this._li = new rt(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale();
  };

  gi.prototype.checkCorrectness = function (t) {
    var e = gn.getNodedSubstrings(t),
        n = new oi(e);

    try {
      n.checkValid();
    } catch (t) {
      if (!(t instanceof z)) throw t;
      t.printStackTrace();
    }
  }, gi.prototype.getNodedSubstrings = function () {
    return gn.getNodedSubstrings(this._nodedSegStrings);
  }, gi.prototype.snapRound = function (t, e) {
    var n = this.findInteriorIntersections(t, e);
    this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);
  }, gi.prototype.findInteriorIntersections = function (t, e) {
    var n = new fi(e);
    return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections();
  }, gi.prototype.computeVertexSnaps = function () {
    if (T(arguments[0], It)) for (var t = arguments[0].iterator(); t.hasNext();) {
      var e = t.next();
      this.computeVertexSnaps(e);
    } else if (arguments[0] instanceof gn) for (var n = arguments[0], i = n.getCoordinates(), r = 0; r < i.length; r++) {
      var o = new ai(i[r], this._scaleFactor, this._li);
      this._pointSnapper.snap(o, n, r) && n.addIntersection(i[r], r);
    }
  }, gi.prototype.computeNodes = function (t) {
    this._nodedSegStrings = t, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t, this._li);
  }, gi.prototype.computeIntersectionSnaps = function (t) {
    for (var e = t.iterator(); e.hasNext();) {
      var n = e.next(),
          i = new ai(n, this._scaleFactor, this._li);

      this._pointSnapper.snap(i);
    }
  }, gi.prototype.interfaces_ = function () {
    return [In];
  }, gi.prototype.getClass = function () {
    return gi;
  };

  var di = function () {
    if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
      var t = arguments[0];
      this._argGeom = t;
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      this._argGeom = e, this._bufParams = n;
    }
  },
      yi = {
    CAP_ROUND: {
      configurable: !0
    },
    CAP_BUTT: {
      configurable: !0
    },
    CAP_FLAT: {
      configurable: !0
    },
    CAP_SQUARE: {
      configurable: !0
    },
    MAX_PRECISION_DIGITS: {
      configurable: !0
    }
  };

  di.prototype.bufferFixedPrecision = function (t) {
    var e = new ri(new gi(new fe(1)), t.getScale()),
        n = new ii(this._bufParams);
    n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance);
  }, di.prototype.bufferReducedPrecision = function () {
    var t = this;

    if (0 === arguments.length) {
      for (var e = di.MAX_PRECISION_DIGITS; e >= 0; e--) {
        try {
          t.bufferReducedPrecision(e);
        } catch (e) {
          if (!(e instanceof we)) throw e;
          t._saveException = e;
        }

        if (null !== t._resultGeometry) return null;
      }

      throw this._saveException;
    }

    if (1 === arguments.length) {
      var n = arguments[0],
          i = di.precisionScaleFactor(this._argGeom, this._distance, n),
          r = new fe(i);
      this.bufferFixedPrecision(r);
    }
  }, di.prototype.computeGeometry = function () {
    if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;

    var t = this._argGeom.getFactory().getPrecisionModel();

    t.getType() === fe.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();
  }, di.prototype.setQuadrantSegments = function (t) {
    this._bufParams.setQuadrantSegments(t);
  }, di.prototype.bufferOriginalPrecision = function () {
    try {
      var t = new ii(this._bufParams);
      this._resultGeometry = t.buffer(this._argGeom, this._distance);
    } catch (t) {
      if (!(t instanceof $)) throw t;
      this._saveException = t;
    }
  }, di.prototype.getResultGeometry = function (t) {
    return this._distance = t, this.computeGeometry(), this._resultGeometry;
  }, di.prototype.setEndCapStyle = function (t) {
    this._bufParams.setEndCapStyle(t);
  }, di.prototype.interfaces_ = function () {
    return [];
  }, di.prototype.getClass = function () {
    return di;
  }, di.bufferOp = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      return new di(t).getResultGeometry(e);
    }

    if (3 === arguments.length) {
      if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
        var n = arguments[0],
            i = arguments[1],
            r = arguments[2],
            o = new di(n);
        o.setQuadrantSegments(r);
        return o.getResultGeometry(i);
      }

      if (arguments[2] instanceof Cn && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
        var s = arguments[0],
            a = arguments[1],
            u = arguments[2];
        return new di(s, u).getResultGeometry(a);
      }
    } else if (4 === arguments.length) {
      var l = arguments[0],
          c = arguments[1],
          p = arguments[2],
          h = arguments[3],
          f = new di(l);
      f.setQuadrantSegments(p), f.setEndCapStyle(h);
      return f.getResultGeometry(c);
    }
  }, di.precisionScaleFactor = function (t, e, n) {
    var i = t.getEnvelopeInternal(),
        r = R.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())) + 2 * (e > 0 ? e : 0),
        o = n - Math.trunc(Math.log(r) / Math.log(10) + 1);
    return Math.pow(10, o);
  }, yi.CAP_ROUND.get = function () {
    return Cn.CAP_ROUND;
  }, yi.CAP_BUTT.get = function () {
    return Cn.CAP_FLAT;
  }, yi.CAP_FLAT.get = function () {
    return Cn.CAP_FLAT;
  }, yi.CAP_SQUARE.get = function () {
    return Cn.CAP_SQUARE;
  }, yi.MAX_PRECISION_DIGITS.get = function () {
    return 12;
  }, Object.defineProperties(di, yi);

  var _i = function () {
    this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = !0;
  };

  _i.prototype.getCoordinates = function () {
    return this._pt;
  }, _i.prototype.getCoordinate = function (t) {
    return this._pt[t];
  }, _i.prototype.setMinimum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMinimum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      if (this._isNull) return this.initialize(e, n), null;
      var i = e.distance(n);
      i < this._distance && this.initialize(e, n, i);
    }
  }, _i.prototype.initialize = function () {
    if (0 === arguments.length) this._isNull = !0;else if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];
      this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = r, this._isNull = !1;
    }
  }, _i.prototype.getDistance = function () {
    return this._distance;
  }, _i.prototype.setMaximum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMaximum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      if (this._isNull) return this.initialize(e, n), null;
      var i = e.distance(n);
      i > this._distance && this.initialize(e, n, i);
    }
  }, _i.prototype.interfaces_ = function () {
    return [];
  }, _i.prototype.getClass = function () {
    return _i;
  };

  var mi = function () {};

  mi.prototype.interfaces_ = function () {
    return [];
  }, mi.prototype.getClass = function () {
    return mi;
  }, mi.computeDistance = function () {
    if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C) for (var t = arguments[0], e = arguments[1], n = arguments[2], i = t.getCoordinates(), r = new dn(), o = 0; o < i.length - 1; o++) {
      r.setCoordinates(i[o], i[o + 1]);
      var s = r.closestPoint(e);
      n.setMinimum(s, e);
    } else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {
      var a = arguments[0],
          u = arguments[1],
          l = arguments[2];
      mi.computeDistance(a.getExteriorRing(), u, l);

      for (var c = 0; c < a.getNumInteriorRing(); c++) mi.computeDistance(a.getInteriorRingN(c), u, l);
    } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {
      var p = arguments[0],
          h = arguments[1],
          f = arguments[2];
      if (p instanceof Kt) mi.computeDistance(p, h, f);else if (p instanceof $t) mi.computeDistance(p, h, f);else if (p instanceof zt) for (var g = p, d = 0; d < g.getNumGeometries(); d++) {
        var y = g.getGeometryN(d);
        mi.computeDistance(y, h, f);
      } else f.setMinimum(p.getCoordinate(), h);
    } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {
      var _ = arguments[0],
          m = arguments[1],
          v = arguments[2],
          I = _.closestPoint(m);

      v.setMinimum(I, m);
    }
  };

  var vi = function (t) {
    this._maxPtDist = new _i(), this._inputGeom = t || null;
  },
      Ii = {
    MaxPointDistanceFilter: {
      configurable: !0
    },
    MaxMidpointDistanceFilter: {
      configurable: !0
    }
  };

  vi.prototype.computeMaxMidpointDistance = function (t) {
    var e = new xi(this._inputGeom);
    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());
  }, vi.prototype.computeMaxVertexDistance = function (t) {
    var e = new Ei(this._inputGeom);
    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());
  }, vi.prototype.findDistance = function (t) {
    return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance();
  }, vi.prototype.getDistancePoints = function () {
    return this._maxPtDist;
  }, vi.prototype.interfaces_ = function () {
    return [];
  }, vi.prototype.getClass = function () {
    return vi;
  }, Ii.MaxPointDistanceFilter.get = function () {
    return Ei;
  }, Ii.MaxMidpointDistanceFilter.get = function () {
    return xi;
  }, Object.defineProperties(vi, Ii);

  var Ei = function (t) {
    this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t || null;
  };

  Ei.prototype.filter = function (t) {
    this._minPtDist.initialize(), mi.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
  }, Ei.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }, Ei.prototype.interfaces_ = function () {
    return [ft];
  }, Ei.prototype.getClass = function () {
    return Ei;
  };

  var xi = function (t) {
    this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t || null;
  };

  xi.prototype.filter = function (t, e) {
    if (0 === e) return null;
    var n = t.getCoordinate(e - 1),
        i = t.getCoordinate(e),
        r = new C((n.x + i.x) / 2, (n.y + i.y) / 2);
    this._minPtDist.initialize(), mi.computeDistance(this._geom, r, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
  }, xi.prototype.isDone = function () {
    return !1;
  }, xi.prototype.isGeometryChanged = function () {
    return !1;
  }, xi.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }, xi.prototype.interfaces_ = function () {
    return [Ut];
  }, xi.prototype.getClass = function () {
    return xi;
  };

  var Ni = function (t) {
    this._comps = t || null;
  };

  Ni.prototype.filter = function (t) {
    t instanceof $t && this._comps.add(t);
  }, Ni.prototype.interfaces_ = function () {
    return [Vt];
  }, Ni.prototype.getClass = function () {
    return Ni;
  }, Ni.getPolygons = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return Ni.getPolygons(t, new Nt());
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return e instanceof $t ? n.add(e) : e instanceof zt && e.apply(new Ni(n)), n;
    }
  };

  var Ci = function () {
    if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) {
      var t = arguments[0];
      this._lines = t;
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      this._lines = e, this._isForcedToLineString = n;
    }
  };

  Ci.prototype.filter = function (t) {
    if (this._isForcedToLineString && t instanceof ee) {
      var e = t.getFactory().createLineString(t.getCoordinateSequence());
      return this._lines.add(e), null;
    }

    t instanceof Kt && this._lines.add(t);
  }, Ci.prototype.setForceToLineString = function (t) {
    this._isForcedToLineString = t;
  }, Ci.prototype.interfaces_ = function () {
    return [lt];
  }, Ci.prototype.getClass = function () {
    return Ci;
  }, Ci.getGeometry = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return t.getFactory().buildGeometry(Ci.getLines(t));
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return e.getFactory().buildGeometry(Ci.getLines(e, n));
    }
  }, Ci.getLines = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return Ci.getLines(t, !1);
    }

    if (2 === arguments.length) {
      if (T(arguments[0], It) && T(arguments[1], It)) {
        for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext();) {
          var r = i.next();
          Ci.getLines(r, n);
        }

        return n;
      }

      if (arguments[0] instanceof ct && "boolean" == typeof arguments[1]) {
        var o = arguments[0],
            s = arguments[1],
            a = new Nt();
        return o.apply(new Ci(a, s)), a;
      }

      if (arguments[0] instanceof ct && T(arguments[1], It)) {
        var u = arguments[0],
            l = arguments[1];
        return u instanceof Kt ? l.add(u) : u.apply(new Ci(l)), l;
      }
    } else if (3 === arguments.length) {
      if ("boolean" == typeof arguments[2] && T(arguments[0], It) && T(arguments[1], It)) {
        for (var c = arguments[0], p = arguments[1], h = arguments[2], f = c.iterator(); f.hasNext();) {
          var g = f.next();
          Ci.getLines(g, p, h);
        }

        return p;
      }

      if ("boolean" == typeof arguments[2] && arguments[0] instanceof ct && T(arguments[1], It)) {
        var d = arguments[0],
            y = arguments[1],
            _ = arguments[2];
        return d.apply(new Ci(y, _)), y;
      }
    }
  };

  var Si = function () {
    if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];
      if (null === t) throw new m("Rule must be non-null");
      this._boundaryRule = t;
    }
  };

  Si.prototype.locateInternal = function () {
    if (arguments[0] instanceof C && arguments[1] instanceof $t) {
      var t = arguments[0],
          e = arguments[1];
      if (e.isEmpty()) return w.EXTERIOR;
      var n = e.getExteriorRing(),
          i = this.locateInPolygonRing(t, n);
      if (i === w.EXTERIOR) return w.EXTERIOR;
      if (i === w.BOUNDARY) return w.BOUNDARY;

      for (var r = 0; r < e.getNumInteriorRing(); r++) {
        var o = e.getInteriorRingN(r),
            s = this.locateInPolygonRing(t, o);
        if (s === w.INTERIOR) return w.EXTERIOR;
        if (s === w.BOUNDARY) return w.BOUNDARY;
      }

      return w.INTERIOR;
    }

    if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
      var a = arguments[0],
          u = arguments[1];
      if (!u.getEnvelopeInternal().intersects(a)) return w.EXTERIOR;
      var l = u.getCoordinates();
      return u.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? at.isOnLine(a, l) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;
    }

    if (arguments[0] instanceof C && arguments[1] instanceof Qt) {
      var c = arguments[0];
      return arguments[1].getCoordinate().equals2D(c) ? w.INTERIOR : w.EXTERIOR;
    }
  }, Si.prototype.locateInPolygonRing = function (t, e) {
    return e.getEnvelopeInternal().intersects(t) ? at.locatePointInRing(t, e.getCoordinates()) : w.EXTERIOR;
  }, Si.prototype.intersects = function (t, e) {
    return this.locate(t, e) !== w.EXTERIOR;
  }, Si.prototype.updateLocationInfo = function (t) {
    t === w.INTERIOR && (this._isIn = !0), t === w.BOUNDARY && this._numBoundaries++;
  }, Si.prototype.computeLocation = function (t, e) {
    if (e instanceof Qt && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Kt) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof $t) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof Xt) for (var n = e, i = 0; i < n.getNumGeometries(); i++) {
      var r = n.getGeometryN(i);
      this.updateLocationInfo(this.locateInternal(t, r));
    } else if (e instanceof ne) for (var o = e, s = 0; s < o.getNumGeometries(); s++) {
      var a = o.getGeometryN(s);
      this.updateLocationInfo(this.locateInternal(t, a));
    } else if (e instanceof zt) for (var u = new Un(e); u.hasNext();) {
      var l = u.next();
      l !== e && this.computeLocation(t, l);
    }
  }, Si.prototype.locate = function (t, e) {
    return e.isEmpty() ? w.EXTERIOR : e instanceof Kt ? this.locateInternal(t, e) : e instanceof $t ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);
  }, Si.prototype.interfaces_ = function () {
    return [];
  }, Si.prototype.getClass = function () {
    return Si;
  };

  var Li = function t() {
    if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      t.call(this, e, t.INSIDE_AREA, n);
    } else if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2];
      this._component = i, this._segIndex = r, this._pt = o;
    }
  },
      bi = {
    INSIDE_AREA: {
      configurable: !0
    }
  };

  Li.prototype.isInsideArea = function () {
    return this._segIndex === Li.INSIDE_AREA;
  }, Li.prototype.getCoordinate = function () {
    return this._pt;
  }, Li.prototype.getGeometryComponent = function () {
    return this._component;
  }, Li.prototype.getSegmentIndex = function () {
    return this._segIndex;
  }, Li.prototype.interfaces_ = function () {
    return [];
  }, Li.prototype.getClass = function () {
    return Li;
  }, bi.INSIDE_AREA.get = function () {
    return -1;
  }, Object.defineProperties(Li, bi);

  var wi = function (t) {
    this._pts = t || null;
  };

  wi.prototype.filter = function (t) {
    t instanceof Qt && this._pts.add(t);
  }, wi.prototype.interfaces_ = function () {
    return [Vt];
  }, wi.prototype.getClass = function () {
    return wi;
  }, wi.getPoints = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return t instanceof Qt ? $e.singletonList(t) : wi.getPoints(t, new Nt());
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return e instanceof Qt ? n.add(e) : e instanceof zt && e.apply(new wi(n)), n;
    }
  };

  var Oi = function () {
    this._locations = null;
    var t = arguments[0];
    this._locations = t;
  };

  Oi.prototype.filter = function (t) {
    (t instanceof Qt || t instanceof Kt || t instanceof $t) && this._locations.add(new Li(t, 0, t.getCoordinate()));
  }, Oi.prototype.interfaces_ = function () {
    return [Vt];
  }, Oi.prototype.getClass = function () {
    return Oi;
  }, Oi.getLocations = function (t) {
    var e = new Nt();
    return t.apply(new Oi(e)), e;
  };

  var Ti = function () {
    if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      this._geom = [t, e], this._terminateDistance = 0;
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];
      this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = i, this._terminateDistance = r;
    }
  };

  Ti.prototype.computeContainmentDistance = function () {
    if (0 === arguments.length) {
      var t = new Array(2).fill(null);
      if (this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance) return null;
      this.computeContainmentDistance(1, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = 1 - e,
          r = Ni.getPolygons(this._geom[e]);

      if (r.size() > 0) {
        var o = Oi.getLocations(this._geom[i]);
        if (this.computeContainmentDistance(o, r, n), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[i] = n[0], this._minDistanceLocation[e] = n[1], null;
      }
    } else if (3 === arguments.length) if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {
      for (var s = arguments[0], a = arguments[1], u = arguments[2], l = 0; l < s.size(); l++) for (var c = s.get(l), p = 0; p < a.size(); p++) if (this.computeContainmentDistance(c, a.get(p), u), this._minDistance <= this._terminateDistance) return null;
    } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {
      var h = arguments[0],
          f = arguments[1],
          g = arguments[2],
          d = h.getCoordinate();
      if (w.EXTERIOR !== this._ptLocator.locate(d, f)) return this._minDistance = 0, g[0] = h, g[1] = new Li(f, d), null;
    }
  }, Ti.prototype.computeMinDistanceLinesPoints = function (t, e, n) {
    for (var i = 0; i < t.size(); i++) for (var r = t.get(i), o = 0; o < e.size(); o++) {
      var s = e.get(o);
      if (this.computeMinDistance(r, s, n), this._minDistance <= this._terminateDistance) return null;
    }
  }, Ti.prototype.computeFacetDistance = function () {
    var t = new Array(2).fill(null),
        e = Ci.getLines(this._geom[0]),
        n = Ci.getLines(this._geom[1]),
        i = wi.getPoints(this._geom[0]),
        r = wi.getPoints(this._geom[1]);
    return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(i, r, t), void this.updateMinDistance(t, !1))));
  }, Ti.prototype.nearestLocations = function () {
    return this.computeMinDistance(), this._minDistanceLocation;
  }, Ti.prototype.updateMinDistance = function (t, e) {
    if (null === t[0]) return null;
    e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1]);
  }, Ti.prototype.nearestPoints = function () {
    this.computeMinDistance();
    return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
  }, Ti.prototype.computeMinDistance = function () {
    if (0 === arguments.length) {
      if (null !== this._minDistanceLocation) return null;
      if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance) return null;
      this.computeFacetDistance();
    } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2];
      if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance) return null;

      for (var i = t.getCoordinates(), r = e.getCoordinate(), o = 0; o < i.length - 1; o++) {
        var s = at.distancePointLine(r, i[o], i[o + 1]);

        if (s < this._minDistance) {
          this._minDistance = s;
          var a = new dn(i[o], i[o + 1]).closestPoint(r);
          n[0] = new Li(t, o, a), n[1] = new Li(e, 0, r);
        }

        if (this._minDistance <= this._terminateDistance) return null;
      }
    } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {
      var u = arguments[0],
          l = arguments[1],
          c = arguments[2];
      if (u.getEnvelopeInternal().distance(l.getEnvelopeInternal()) > this._minDistance) return null;

      for (var p = u.getCoordinates(), h = l.getCoordinates(), f = 0; f < p.length - 1; f++) for (var g = 0; g < h.length - 1; g++) {
        var d = at.distanceLineLine(p[f], p[f + 1], h[g], h[g + 1]);

        if (d < this._minDistance) {
          this._minDistance = d;

          var y = new dn(p[f], p[f + 1]),
              _ = new dn(h[g], h[g + 1]),
              m = y.closestPoints(_);

          c[0] = new Li(u, f, m[0]), c[1] = new Li(l, g, m[1]);
        }

        if (this._minDistance <= this._terminateDistance) return null;
      }
    }
  }, Ti.prototype.computeMinDistancePoints = function (t, e, n) {
    for (var i = 0; i < t.size(); i++) for (var r = t.get(i), o = 0; o < e.size(); o++) {
      var s = e.get(o),
          a = r.getCoordinate().distance(s.getCoordinate());
      if (a < this._minDistance && (this._minDistance = a, n[0] = new Li(r, 0, r.getCoordinate()), n[1] = new Li(s, 0, s.getCoordinate())), this._minDistance <= this._terminateDistance) return null;
    }
  }, Ti.prototype.distance = function () {
    if (null === this._geom[0] || null === this._geom[1]) throw new m("null geometries are not supported");
    return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
  }, Ti.prototype.computeMinDistanceLines = function (t, e, n) {
    for (var i = 0; i < t.size(); i++) for (var r = t.get(i), o = 0; o < e.size(); o++) {
      var s = e.get(o);
      if (this.computeMinDistance(r, s, n), this._minDistance <= this._terminateDistance) return null;
    }
  }, Ti.prototype.interfaces_ = function () {
    return [];
  }, Ti.prototype.getClass = function () {
    return Ti;
  }, Ti.distance = function (t, e) {
    return new Ti(t, e).distance();
  }, Ti.isWithinDistance = function (t, e, n) {
    return new Ti(t, e, n).distance() <= n;
  }, Ti.nearestPoints = function (t, e) {
    return new Ti(t, e).nearestPoints();
  };

  var Ri = function () {
    this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = !0;
  };

  Ri.prototype.getCoordinates = function () {
    return this._pt;
  }, Ri.prototype.getCoordinate = function (t) {
    return this._pt[t];
  }, Ri.prototype.setMinimum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMinimum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      if (this._isNull) return this.initialize(e, n), null;
      var i = e.distance(n);
      i < this._distance && this.initialize(e, n, i);
    }
  }, Ri.prototype.initialize = function () {
    if (0 === arguments.length) this._isNull = !0;else if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];
      this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = r, this._isNull = !1;
    }
  }, Ri.prototype.toString = function () {
    return Z.toLineString(this._pt[0], this._pt[1]);
  }, Ri.prototype.getDistance = function () {
    return this._distance;
  }, Ri.prototype.setMaximum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMaximum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      if (this._isNull) return this.initialize(e, n), null;
      var i = e.distance(n);
      i > this._distance && this.initialize(e, n, i);
    }
  }, Ri.prototype.interfaces_ = function () {
    return [];
  }, Ri.prototype.getClass = function () {
    return Ri;
  };

  var Pi = function () {};

  Pi.prototype.interfaces_ = function () {
    return [];
  }, Pi.prototype.getClass = function () {
    return Pi;
  }, Pi.computeDistance = function () {
    if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C) for (var t = arguments[0], e = arguments[1], n = arguments[2], i = new dn(), r = t.getCoordinates(), o = 0; o < r.length - 1; o++) {
      i.setCoordinates(r[o], r[o + 1]);
      var s = i.closestPoint(e);
      n.setMinimum(s, e);
    } else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {
      var a = arguments[0],
          u = arguments[1],
          l = arguments[2];
      Pi.computeDistance(a.getExteriorRing(), u, l);

      for (var c = 0; c < a.getNumInteriorRing(); c++) Pi.computeDistance(a.getInteriorRingN(c), u, l);
    } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {
      var p = arguments[0],
          h = arguments[1],
          f = arguments[2];
      if (p instanceof Kt) Pi.computeDistance(p, h, f);else if (p instanceof $t) Pi.computeDistance(p, h, f);else if (p instanceof zt) for (var g = p, d = 0; d < g.getNumGeometries(); d++) {
        var y = g.getGeometryN(d);
        Pi.computeDistance(y, h, f);
      } else f.setMinimum(p.getCoordinate(), h);
    } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {
      var _ = arguments[0],
          m = arguments[1],
          v = arguments[2],
          I = _.closestPoint(m);

      v.setMinimum(I, m);
    }
  };

  var Di = function () {
    this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;
    var t = arguments[0],
        e = arguments[1];
    this._g0 = t, this._g1 = e;
  },
      Mi = {
    MaxPointDistanceFilter: {
      configurable: !0
    },
    MaxDensifiedByFractionDistanceFilter: {
      configurable: !0
    }
  };

  Di.prototype.getCoordinates = function () {
    return this._ptDist.getCoordinates();
  }, Di.prototype.setDensifyFraction = function (t) {
    if (t > 1 || t <= 0) throw new m("Fraction is not in range (0.0 - 1.0]");
    this._densifyFrac = t;
  }, Di.prototype.compute = function (t, e) {
    this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist);
  }, Di.prototype.distance = function () {
    return this.compute(this._g0, this._g1), this._ptDist.getDistance();
  }, Di.prototype.computeOrientedDistance = function (t, e, n) {
    var i = new Ai(e);

    if (t.apply(i), n.setMaximum(i.getMaxPointDistance()), this._densifyFrac > 0) {
      var r = new Fi(e, this._densifyFrac);
      t.apply(r), n.setMaximum(r.getMaxPointDistance());
    }
  }, Di.prototype.orientedDistance = function () {
    return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
  }, Di.prototype.interfaces_ = function () {
    return [];
  }, Di.prototype.getClass = function () {
    return Di;
  }, Di.distance = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];
      return new Di(t, e).distance();
    }

    if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2],
          o = new Di(n, i);
      return o.setDensifyFraction(r), o.distance();
    }
  }, Mi.MaxPointDistanceFilter.get = function () {
    return Ai;
  }, Mi.MaxDensifiedByFractionDistanceFilter.get = function () {
    return Fi;
  }, Object.defineProperties(Di, Mi);

  var Ai = function () {
    this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;
    var t = arguments[0];
    this._geom = t;
  };

  Ai.prototype.filter = function (t) {
    this._minPtDist.initialize(), Pi.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
  }, Ai.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }, Ai.prototype.interfaces_ = function () {
    return [ft];
  }, Ai.prototype.getClass = function () {
    return Ai;
  };

  var Fi = function () {
    this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;
    var t = arguments[0],
        e = arguments[1];
    this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e));
  };

  Fi.prototype.filter = function (t, e) {
    if (0 === e) return null;

    for (var n = t.getCoordinate(e - 1), i = t.getCoordinate(e), r = (i.x - n.x) / this._numSubSegs, o = (i.y - n.y) / this._numSubSegs, s = 0; s < this._numSubSegs; s++) {
      var a = n.x + s * r,
          u = n.y + s * o,
          l = new C(a, u);
      this._minPtDist.initialize(), Pi.computeDistance(this._geom, l, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
    }
  }, Fi.prototype.isDone = function () {
    return !1;
  }, Fi.prototype.isGeometryChanged = function () {
    return !1;
  }, Fi.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }, Fi.prototype.interfaces_ = function () {
    return [Ut];
  }, Fi.prototype.getClass = function () {
    return Fi;
  };

  var Gi = function (t, e, n) {
    this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._bufDistance = e || null, this._result = n || null;
  },
      qi = {
    VERBOSE: {
      configurable: !0
    },
    MAX_DISTANCE_DIFF_FRAC: {
      configurable: !0
    }
  };

  Gi.prototype.checkMaximumDistance = function (t, e, n) {
    var i = new Di(e, t);

    if (i.setDensifyFraction(.25), this._maxDistanceFound = i.orientedDistance(), this._maxDistanceFound > n) {
      this._isValid = !1;
      var r = i.getCoordinates();
      this._errorLocation = r[1], this._errorIndicator = t.getFactory().createLineString(r), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Z.toLineString(r[0], r[1]) + ")";
    }
  }, Gi.prototype.isValid = function () {
    var t = Math.abs(this._bufDistance),
        e = Gi.MAX_DISTANCE_DIFF_FRAC * t;
    return this._minValidDistance = t - e, this._maxValidDistance = t + e, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
  }, Gi.prototype.checkNegativeValid = function () {
    if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt)) return null;
    var t = this.getPolygonLines(this._input);
    if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid) return null;
    this.checkMaximumDistance(t, this._result, this._maxValidDistance);
  }, Gi.prototype.getErrorIndicator = function () {
    return this._errorIndicator;
  }, Gi.prototype.checkMinimumDistance = function (t, e, n) {
    var i = new Ti(t, e, n);

    if (this._minDistanceFound = i.distance(), this._minDistanceFound < n) {
      this._isValid = !1;
      var r = i.nearestPoints();
      this._errorLocation = i.nearestPoints()[1], this._errorIndicator = t.getFactory().createLineString(r), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Z.toLineString(r[0], r[1]) + " )";
    }
  }, Gi.prototype.checkPositiveValid = function () {
    var t = this._result.getBoundary();

    if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid) return null;
    this.checkMaximumDistance(this._input, t, this._maxValidDistance);
  }, Gi.prototype.getErrorLocation = function () {
    return this._errorLocation;
  }, Gi.prototype.getPolygonLines = function (t) {
    for (var e = new Nt(), n = new Ci(e), i = Ni.getPolygons(t).iterator(); i.hasNext();) {
      i.next().apply(n);
    }

    return t.getFactory().buildGeometry(e);
  }, Gi.prototype.getErrorMessage = function () {
    return this._errMsg;
  }, Gi.prototype.interfaces_ = function () {
    return [];
  }, Gi.prototype.getClass = function () {
    return Gi;
  }, qi.VERBOSE.get = function () {
    return !1;
  }, qi.MAX_DISTANCE_DIFF_FRAC.get = function () {
    return .012;
  }, Object.defineProperties(Gi, qi);

  var Bi = function (t, e, n) {
    this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._distance = e || null, this._result = n || null;
  },
      Vi = {
    VERBOSE: {
      configurable: !0
    },
    MAX_ENV_DIFF_FRAC: {
      configurable: !0
    }
  };

  Bi.prototype.isValid = function () {
    return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
  }, Bi.prototype.checkEnvelope = function () {
    if (this._distance < 0) return null;
    var t = this._distance * Bi.MAX_ENV_DIFF_FRAC;
    0 === t && (t = .001);
    var e = new j(this._input.getEnvelopeInternal());
    e.expandBy(this._distance);
    var n = new j(this._result.getEnvelopeInternal());
    n.expandBy(t), n.contains(e) || (this._isValid = !1, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report("Envelope");
  }, Bi.prototype.checkDistance = function () {
    var t = new Gi(this._input, this._distance, this._result);
    t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()), this.report("Distance");
  }, Bi.prototype.checkArea = function () {
    var t = this._input.getArea(),
        e = this._result.getArea();

    this._distance > 0 && t > e && (this._isValid = !1, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
  }, Bi.prototype.checkPolygonal = function () {
    this._result instanceof $t || this._result instanceof ne || (this._isValid = !1), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
  }, Bi.prototype.getErrorIndicator = function () {
    return this._errorIndicator;
  }, Bi.prototype.getErrorLocation = function () {
    return this._errorLocation;
  }, Bi.prototype.checkExpectedEmpty = function () {
    return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = !1, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
  }, Bi.prototype.report = function (t) {
    if (!Bi.VERBOSE) return null;
    Y.out.println("Check " + t + ": " + (this._isValid ? "passed" : "FAILED"));
  }, Bi.prototype.getErrorMessage = function () {
    return this._errorMsg;
  }, Bi.prototype.interfaces_ = function () {
    return [];
  }, Bi.prototype.getClass = function () {
    return Bi;
  }, Bi.isValidMsg = function (t, e, n) {
    var i = new Bi(t, e, n);
    return i.isValid() ? null : i.getErrorMessage();
  }, Bi.isValid = function (t, e, n) {
    return !!new Bi(t, e, n).isValid();
  }, Vi.VERBOSE.get = function () {
    return !1;
  }, Vi.MAX_ENV_DIFF_FRAC.get = function () {
    return .012;
  }, Object.defineProperties(Bi, Vi);

  var Ui = function () {
    this._pts = null, this._data = null;
    var t = arguments[0],
        e = arguments[1];
    this._pts = t, this._data = e;
  };

  Ui.prototype.getCoordinates = function () {
    return this._pts;
  }, Ui.prototype.size = function () {
    return this._pts.length;
  }, Ui.prototype.getCoordinate = function (t) {
    return this._pts[t];
  }, Ui.prototype.isClosed = function () {
    return this._pts[0].equals(this._pts[this._pts.length - 1]);
  }, Ui.prototype.getSegmentOctant = function (t) {
    return t === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t), this.getCoordinate(t + 1));
  }, Ui.prototype.setData = function (t) {
    this._data = t;
  }, Ui.prototype.getData = function () {
    return this._data;
  }, Ui.prototype.toString = function () {
    return Z.toLineString(new ue(this._pts));
  }, Ui.prototype.interfaces_ = function () {
    return [hn];
  }, Ui.prototype.getClass = function () {
    return Ui;
  };

  var zi = function () {
    this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = !0;
    var t = arguments[0];
    this._li = t, this._interiorIntersection = null;
  };

  zi.prototype.getInteriorIntersection = function () {
    return this._interiorIntersection;
  }, zi.prototype.setCheckEndSegmentsOnly = function (t) {
    this._isCheckEndSegmentsOnly = t;
  }, zi.prototype.getIntersectionSegments = function () {
    return this._intSegments;
  }, zi.prototype.count = function () {
    return this._intersectionCount;
  }, zi.prototype.getIntersections = function () {
    return this._intersections;
  }, zi.prototype.setFindAllIntersections = function (t) {
    this._findAllIntersections = t;
  }, zi.prototype.setKeepIntersections = function (t) {
    this._keepIntersections = t;
  }, zi.prototype.processIntersections = function (t, e, n, i) {
    if (!this._findAllIntersections && this.hasIntersection()) return null;
    if (t === n && e === i) return null;

    if (this._isCheckEndSegmentsOnly) {
      if (!(this.isEndSegment(t, e) || this.isEndSegment(n, i))) return null;
    }

    var r = t.getCoordinates()[e],
        o = t.getCoordinates()[e + 1],
        s = n.getCoordinates()[i],
        a = n.getCoordinates()[i + 1];
    this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r, this._intSegments[1] = o, this._intSegments[2] = s, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
  }, zi.prototype.isEndSegment = function (t, e) {
    return 0 === e || e >= t.size() - 2;
  }, zi.prototype.hasIntersection = function () {
    return null !== this._interiorIntersection;
  }, zi.prototype.isDone = function () {
    return !this._findAllIntersections && null !== this._interiorIntersection;
  }, zi.prototype.interfaces_ = function () {
    return [Wn];
  }, zi.prototype.getClass = function () {
    return zi;
  }, zi.createAllIntersectionsFinder = function (t) {
    var e = new zi(t);
    return e.setFindAllIntersections(!0), e;
  }, zi.createAnyIntersectionFinder = function (t) {
    return new zi(t);
  }, zi.createIntersectionCounter = function (t) {
    var e = new zi(t);
    return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;
  };

  var Xi = function () {
    this._li = new rt(), this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;
    var t = arguments[0];
    this._segStrings = t;
  };

  Xi.prototype.execute = function () {
    if (null !== this._segInt) return null;
    this.checkInteriorIntersections();
  }, Xi.prototype.getIntersections = function () {
    return this._segInt.getIntersections();
  }, Xi.prototype.isValid = function () {
    return this.execute(), this._isValid;
  }, Xi.prototype.setFindAllIntersections = function (t) {
    this._findAllIntersections = t;
  }, Xi.prototype.checkInteriorIntersections = function () {
    this._isValid = !0, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
    var t = new xn();
    if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null;
  }, Xi.prototype.checkValid = function () {
    if (this.execute(), !this._isValid) throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());
  }, Xi.prototype.getErrorMessage = function () {
    if (this._isValid) return "no intersections found";

    var t = this._segInt.getIntersectionSegments();

    return "found non-noded intersection between " + Z.toLineString(t[0], t[1]) + " and " + Z.toLineString(t[2], t[3]);
  }, Xi.prototype.interfaces_ = function () {
    return [];
  }, Xi.prototype.getClass = function () {
    return Xi;
  }, Xi.computeIntersections = function (t) {
    var e = new Xi(t);
    return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();
  };

  var Yi = function t() {
    this._nv = null;
    var e = arguments[0];
    this._nv = new Xi(t.toSegmentStrings(e));
  };

  Yi.prototype.checkValid = function () {
    this._nv.checkValid();
  }, Yi.prototype.interfaces_ = function () {
    return [];
  }, Yi.prototype.getClass = function () {
    return Yi;
  }, Yi.toSegmentStrings = function (t) {
    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {
      var i = n.next();
      e.add(new Ui(i.getCoordinates(), i));
    }

    return e;
  }, Yi.checkValid = function (t) {
    new Yi(t).checkValid();
  };

  var ki = function (t) {
    this._mapOp = t;
  };

  ki.prototype.map = function (t) {
    for (var e = new Nt(), n = 0; n < t.getNumGeometries(); n++) {
      var i = this._mapOp.map(t.getGeometryN(n));

      i.isEmpty() || e.add(i);
    }

    return t.getFactory().createGeometryCollection(_e.toGeometryArray(e));
  }, ki.prototype.interfaces_ = function () {
    return [];
  }, ki.prototype.getClass = function () {
    return ki;
  }, ki.map = function (t, e) {
    return new ki(e).map(t);
  };

  var ji = function () {
    this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2];
    this._op = t, this._geometryFactory = e, this._ptLocator = n;
  };

  ji.prototype.collectLines = function (t) {
    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
      var n = e.next();
      this.collectLineEdge(n, t, this._lineEdgesList), this.collectBoundaryTouchEdge(n, t, this._lineEdgesList);
    }
  }, ji.prototype.labelIsolatedLine = function (t, e) {
    var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));

    t.getLabel().setLocation(e, n);
  }, ji.prototype.build = function (t) {
    return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList;
  }, ji.prototype.collectLineEdge = function (t, e, n) {
    var i = t.getLabel(),
        r = t.getEdge();
    t.isLineEdge() && (t.isVisited() || !Lr.isResultOfOp(i, e) || r.isCovered() || (n.add(r), t.setVisitedEdge(!0)));
  }, ji.prototype.findCoveredLineEdges = function () {
    for (var t = this._op.getGraph().getNodes().iterator(); t.hasNext();) {
      t.next().getEdges().findCoveredLineEdges();
    }

    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
      var n = e.next(),
          i = n.getEdge();

      if (n.isLineEdge() && !i.isCoveredSet()) {
        var r = this._op.isCoveredByA(n.getCoordinate());

        i.setCovered(r);
      }
    }
  }, ji.prototype.labelIsolatedLines = function (t) {
    for (var e = t.iterator(); e.hasNext();) {
      var n = e.next(),
          i = n.getLabel();
      n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1));
    }
  }, ji.prototype.buildLines = function (t) {
    for (var e = this._lineEdgesList.iterator(); e.hasNext();) {
      var n = e.next(),
          i = this._geometryFactory.createLineString(n.getCoordinates());

      this._resultLineList.add(i), n.setInResult(!0);
    }
  }, ji.prototype.collectBoundaryTouchEdge = function (t, e, n) {
    var i = t.getLabel();
    return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (et.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Lr.isResultOfOp(i, e) && e === Lr.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))));
  }, ji.prototype.interfaces_ = function () {
    return [];
  }, ji.prototype.getClass = function () {
    return ji;
  };

  var Hi = function () {
    this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();
    var t = arguments[0],
        e = arguments[1];
    this._op = t, this._geometryFactory = e;
  };

  Hi.prototype.filterCoveredNodeToPoint = function (t) {
    var e = t.getCoordinate();

    if (!this._op.isCoveredByLA(e)) {
      var n = this._geometryFactory.createPoint(e);

      this._resultPointList.add(n);
    }
  }, Hi.prototype.extractNonCoveredResultNodes = function (t) {
    for (var e = this._op.getGraph().getNodes().iterator(); e.hasNext();) {
      var n = e.next();

      if (!n.isInResult() && !n.isIncidentEdgeInResult() && (0 === n.getEdges().getDegree() || t === Lr.INTERSECTION)) {
        var i = n.getLabel();
        Lr.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n);
      }
    }
  }, Hi.prototype.build = function (t) {
    return this.extractNonCoveredResultNodes(t), this._resultPointList;
  }, Hi.prototype.interfaces_ = function () {
    return [];
  }, Hi.prototype.getClass = function () {
    return Hi;
  };

  var Wi = function () {
    this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1;
  };

  Wi.prototype.transformPoint = function (t, e) {
    return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));
  }, Wi.prototype.transformPolygon = function (t, e) {
    var n = !0,
        i = this.transformLinearRing(t.getExteriorRing(), t);
    null !== i && i instanceof ee && !i.isEmpty() || (n = !1);

    for (var r = new Nt(), o = 0; o < t.getNumInteriorRing(); o++) {
      var s = this.transformLinearRing(t.getInteriorRingN(o), t);
      null === s || s.isEmpty() || (s instanceof ee || (n = !1), r.add(s));
    }

    if (n) return this._factory.createPolygon(i, r.toArray([]));
    var a = new Nt();
    return null !== i && a.add(i), a.addAll(r), this._factory.buildGeometry(a);
  }, Wi.prototype.createCoordinateSequence = function (t) {
    return this._factory.getCoordinateSequenceFactory().create(t);
  }, Wi.prototype.getInputGeometry = function () {
    return this._inputGeom;
  }, Wi.prototype.transformMultiLineString = function (t, e) {
    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {
      var r = this.transformLineString(t.getGeometryN(i), t);
      null !== r && (r.isEmpty() || n.add(r));
    }

    return this._factory.buildGeometry(n);
  }, Wi.prototype.transformCoordinates = function (t, e) {
    return this.copy(t);
  }, Wi.prototype.transformLineString = function (t, e) {
    return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));
  }, Wi.prototype.transformMultiPoint = function (t, e) {
    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {
      var r = this.transformPoint(t.getGeometryN(i), t);
      null !== r && (r.isEmpty() || n.add(r));
    }

    return this._factory.buildGeometry(n);
  }, Wi.prototype.transformMultiPolygon = function (t, e) {
    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {
      var r = this.transformPolygon(t.getGeometryN(i), t);
      null !== r && (r.isEmpty() || n.add(r));
    }

    return this._factory.buildGeometry(n);
  }, Wi.prototype.copy = function (t) {
    return t.copy();
  }, Wi.prototype.transformGeometryCollection = function (t, e) {
    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {
      var r = this.transform(t.getGeometryN(i));
      null !== r && (this._pruneEmptyGeometry && r.isEmpty() || n.add(r));
    }

    return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n)) : this._factory.buildGeometry(n);
  }, Wi.prototype.transform = function (t) {
    if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Qt) return this.transformPoint(t, null);
    if (t instanceof te) return this.transformMultiPoint(t, null);
    if (t instanceof ee) return this.transformLinearRing(t, null);
    if (t instanceof Kt) return this.transformLineString(t, null);
    if (t instanceof Xt) return this.transformMultiLineString(t, null);
    if (t instanceof $t) return this.transformPolygon(t, null);
    if (t instanceof ne) return this.transformMultiPolygon(t, null);
    if (t instanceof zt) return this.transformGeometryCollection(t, null);
    throw new m("Unknown Geometry subtype: " + t.getClass().getName());
  }, Wi.prototype.transformLinearRing = function (t, e) {
    var n = this.transformCoordinates(t.getCoordinateSequence(), t);
    if (null === n) return this._factory.createLinearRing(null);
    var i = n.size();
    return i > 0 && i < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n);
  }, Wi.prototype.interfaces_ = function () {
    return [];
  }, Wi.prototype.getClass = function () {
    return Wi;
  };

  var Ki = function t() {
    if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Kt && "number" == typeof arguments[1]) {
      var e = arguments[0],
          n = arguments[1];
      t.call(this, e.getCoordinates(), n);
    } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
      var i = arguments[0],
          r = arguments[1];
      this._srcPts = i, this._isClosed = t.isClosed(i), this._snapTolerance = r;
    }
  };

  Ki.prototype.snapVertices = function (t, e) {
    for (var n = this._isClosed ? t.size() - 1 : t.size(), i = 0; i < n; i++) {
      var r = t.get(i),
          o = this.findSnapForVertex(r, e);
      null !== o && (t.set(i, new C(o)), 0 === i && this._isClosed && t.set(t.size() - 1, new C(o)));
    }
  }, Ki.prototype.findSnapForVertex = function (t, e) {
    for (var n = 0; n < e.length; n++) {
      if (t.equals2D(e[n])) return null;
      if (t.distance(e[n]) < this._snapTolerance) return e[n];
    }

    return null;
  }, Ki.prototype.snapTo = function (t) {
    var e = new St(this._srcPts);
    this.snapVertices(e, t), this.snapSegments(e, t);
    return e.toCoordinateArray();
  }, Ki.prototype.snapSegments = function (t, e) {
    if (0 === e.length) return null;
    var n = e.length;
    e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);

    for (var i = 0; i < n; i++) {
      var r = e[i],
          o = this.findSegmentIndexToSnap(r, t);
      o >= 0 && t.add(o + 1, new C(r), !1);
    }
  }, Ki.prototype.findSegmentIndexToSnap = function (t, e) {
    for (var n = v.MAX_VALUE, i = -1, r = 0; r < e.size() - 1; r++) {
      if (this._seg.p0 = e.get(r), this._seg.p1 = e.get(r + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) {
        if (this._allowSnappingToSourceVertices) continue;
        return -1;
      }

      var o = this._seg.distance(t);

      o < this._snapTolerance && o < n && (n = o, i = r);
    }

    return i;
  }, Ki.prototype.setAllowSnappingToSourceVertices = function (t) {
    this._allowSnappingToSourceVertices = t;
  }, Ki.prototype.interfaces_ = function () {
    return [];
  }, Ki.prototype.getClass = function () {
    return Ki;
  }, Ki.isClosed = function (t) {
    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]);
  };

  var Ji = function (t) {
    this._srcGeom = t || null;
  },
      Qi = {
    SNAP_PRECISION_FACTOR: {
      configurable: !0
    }
  };

  Ji.prototype.snapTo = function (t, e) {
    var n = this.extractTargetCoordinates(t);
    return new Zi(e, n).transform(this._srcGeom);
  }, Ji.prototype.snapToSelf = function (t, e) {
    var n = this.extractTargetCoordinates(this._srcGeom),
        i = new Zi(t, n, !0).transform(this._srcGeom),
        r = i;
    return e && T(r, Zt) && (r = i.buffer(0)), r;
  }, Ji.prototype.computeSnapTolerance = function (t) {
    return this.computeMinimumSegmentLength(t) / 10;
  }, Ji.prototype.extractTargetCoordinates = function (t) {
    for (var e = new f(), n = t.getCoordinates(), i = 0; i < n.length; i++) e.add(n[i]);

    return e.toArray(new Array(0).fill(null));
  }, Ji.prototype.computeMinimumSegmentLength = function (t) {
    for (var e = v.MAX_VALUE, n = 0; n < t.length - 1; n++) {
      var i = t[n].distance(t[n + 1]);
      i < e && (e = i);
    }

    return e;
  }, Ji.prototype.interfaces_ = function () {
    return [];
  }, Ji.prototype.getClass = function () {
    return Ji;
  }, Ji.snap = function (t, e, n) {
    var i = new Array(2).fill(null),
        r = new Ji(t);
    i[0] = r.snapTo(e, n);
    var o = new Ji(e);
    return i[1] = o.snapTo(i[0], n), i;
  }, Ji.computeOverlaySnapTolerance = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = Ji.computeSizeBasedSnapTolerance(t),
          n = t.getPrecisionModel();

      if (n.getType() === fe.FIXED) {
        var i = 1 / n.getScale() * 2 / 1.415;
        i > e && (e = i);
      }

      return e;
    }

    if (2 === arguments.length) {
      var r = arguments[0],
          o = arguments[1];
      return Math.min(Ji.computeOverlaySnapTolerance(r), Ji.computeOverlaySnapTolerance(o));
    }
  }, Ji.computeSizeBasedSnapTolerance = function (t) {
    var e = t.getEnvelopeInternal();
    return Math.min(e.getHeight(), e.getWidth()) * Ji.SNAP_PRECISION_FACTOR;
  }, Ji.snapToSelf = function (t, e, n) {
    return new Ji(t).snapToSelf(e, n);
  }, Qi.SNAP_PRECISION_FACTOR.get = function () {
    return 1e-9;
  }, Object.defineProperties(Ji, Qi);

  var Zi = function (t) {
    function e(e, n, i) {
      t.call(this), this._snapTolerance = e || null, this._snapPts = n || null, this._isSelfSnap = void 0 !== i && i;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.snapLine = function (t, e) {
      var n = new Ki(t, this._snapTolerance);
      return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e);
    }, e.prototype.transformCoordinates = function (t, e) {
      var n = t.toCoordinateArray(),
          i = this.snapLine(n, this._snapPts);
      return this._factory.getCoordinateSequenceFactory().create(i);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(Wi),
      $i = function () {
    this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
  };

  $i.prototype.getCommon = function () {
    return v.longBitsToDouble(this._commonBits);
  }, $i.prototype.add = function (t) {
    var e = v.doubleToLongBits(t);
    if (this._isFirst) return this._commonBits = e, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = !1, null;
    if ($i.signExpBits(e) !== this._commonSignExp) return this._commonBits = 0, null;
    this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
  }, $i.prototype.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = v.longBitsToDouble(t),
          n = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t),
          i = n.substring(n.length - 64);
      return i.substring(0, 1) + "  " + i.substring(1, 12) + "(exp) " + i.substring(12) + " [ " + e + " ]";
    }
  }, $i.prototype.interfaces_ = function () {
    return [];
  }, $i.prototype.getClass = function () {
    return $i;
  }, $i.getBit = function (t, e) {
    return 0 != (t & 1 << e) ? 1 : 0;
  }, $i.signExpBits = function (t) {
    return t >> 52;
  }, $i.zeroLowerBits = function (t, e) {
    return t & ~((1 << e) - 1);
  }, $i.numCommonMostSigMantissaBits = function (t, e) {
    for (var n = 0, i = 52; i >= 0; i--) {
      if ($i.getBit(t, i) !== $i.getBit(e, i)) return n;
      n++;
    }

    return 52;
  };

  var tr = function () {
    this._commonCoord = null, this._ccFilter = new nr();
  },
      er = {
    CommonCoordinateFilter: {
      configurable: !0
    },
    Translater: {
      configurable: !0
    }
  };

  tr.prototype.addCommonBits = function (t) {
    var e = new ir(this._commonCoord);
    t.apply(e), t.geometryChanged();
  }, tr.prototype.removeCommonBits = function (t) {
    if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t;
    var e = new C(this._commonCoord);
    e.x = -e.x, e.y = -e.y;
    var n = new ir(e);
    return t.apply(n), t.geometryChanged(), t;
  }, tr.prototype.getCommonCoordinate = function () {
    return this._commonCoord;
  }, tr.prototype.add = function (t) {
    t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
  }, tr.prototype.interfaces_ = function () {
    return [];
  }, tr.prototype.getClass = function () {
    return tr;
  }, er.CommonCoordinateFilter.get = function () {
    return nr;
  }, er.Translater.get = function () {
    return ir;
  }, Object.defineProperties(tr, er);

  var nr = function () {
    this._commonBitsX = new $i(), this._commonBitsY = new $i();
  };

  nr.prototype.filter = function (t) {
    this._commonBitsX.add(t.x), this._commonBitsY.add(t.y);
  }, nr.prototype.getCommonCoordinate = function () {
    return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
  }, nr.prototype.interfaces_ = function () {
    return [ft];
  }, nr.prototype.getClass = function () {
    return nr;
  };

  var ir = function () {
    this.trans = null;
    var t = arguments[0];
    this.trans = t;
  };

  ir.prototype.filter = function (t, e) {
    var n = t.getOrdinate(e, 0) + this.trans.x,
        i = t.getOrdinate(e, 1) + this.trans.y;
    t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i);
  }, ir.prototype.isDone = function () {
    return !1;
  }, ir.prototype.isGeometryChanged = function () {
    return !0;
  }, ir.prototype.interfaces_ = function () {
    return [Ut];
  }, ir.prototype.getClass = function () {
    return ir;
  };

  var rr = function (t, e) {
    this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance();
  };

  rr.prototype.selfSnap = function (t) {
    return new Ji(t).snapTo(t, this._snapTolerance);
  }, rr.prototype.removeCommonBits = function (t) {
    this._cbr = new tr(), this._cbr.add(t[0]), this._cbr.add(t[1]);
    var e = new Array(2).fill(null);
    return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e;
  }, rr.prototype.prepareResult = function (t) {
    return this._cbr.addCommonBits(t), t;
  }, rr.prototype.getResultGeometry = function (t) {
    var e = this.snap(this._geom),
        n = Lr.overlayOp(e[0], e[1], t);
    return this.prepareResult(n);
  }, rr.prototype.checkValid = function (t) {
    t.isValid() || Y.out.println("Snapped geometry is invalid");
  }, rr.prototype.computeSnapTolerance = function () {
    this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
  }, rr.prototype.snap = function (t) {
    var e = this.removeCommonBits(t);
    return Ji.snap(e[0], e[1], this._snapTolerance);
  }, rr.prototype.interfaces_ = function () {
    return [];
  }, rr.prototype.getClass = function () {
    return rr;
  }, rr.overlayOp = function (t, e, n) {
    return new rr(t, e).getResultGeometry(n);
  }, rr.union = function (t, e) {
    return rr.overlayOp(t, e, Lr.UNION);
  }, rr.intersection = function (t, e) {
    return rr.overlayOp(t, e, Lr.INTERSECTION);
  }, rr.symDifference = function (t, e) {
    return rr.overlayOp(t, e, Lr.SYMDIFFERENCE);
  }, rr.difference = function (t, e) {
    return rr.overlayOp(t, e, Lr.DIFFERENCE);
  };

  var or = function (t, e) {
    this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e;
  };

  or.prototype.getResultGeometry = function (t) {
    var e = null,
        n = !1,
        i = null;

    try {
      e = Lr.overlayOp(this._geom[0], this._geom[1], t);
      n = !0;
    } catch (t) {
      if (!(t instanceof $)) throw t;
      i = t;
    }

    if (!n) try {
      e = rr.overlayOp(this._geom[0], this._geom[1], t);
    } catch (t) {
      throw t instanceof $ ? i : t;
    }
    return e;
  }, or.prototype.interfaces_ = function () {
    return [];
  }, or.prototype.getClass = function () {
    return or;
  }, or.overlayOp = function (t, e, n) {
    return new or(t, e).getResultGeometry(n);
  }, or.union = function (t, e) {
    return or.overlayOp(t, e, Lr.UNION);
  }, or.intersection = function (t, e) {
    return or.overlayOp(t, e, Lr.INTERSECTION);
  }, or.symDifference = function (t, e) {
    return or.overlayOp(t, e, Lr.SYMDIFFERENCE);
  }, or.difference = function (t, e) {
    return or.overlayOp(t, e, Lr.DIFFERENCE);
  };

  var sr = function () {
    this.mce = null, this.chainIndex = null;
    var t = arguments[0],
        e = arguments[1];
    this.mce = t, this.chainIndex = e;
  };

  sr.prototype.computeIntersections = function (t, e) {
    this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);
  }, sr.prototype.interfaces_ = function () {
    return [];
  }, sr.prototype.getClass = function () {
    return sr;
  };

  var ar = function t() {
    if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      this._eventType = t.DELETE, this._xValue = e, this._insertEvent = n;
    } else if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2];
      this._eventType = t.INSERT, this._label = i, this._xValue = r, this._obj = o;
    }
  },
      ur = {
    INSERT: {
      configurable: !0
    },
    DELETE: {
      configurable: !0
    }
  };

  ar.prototype.isDelete = function () {
    return this._eventType === ar.DELETE;
  }, ar.prototype.setDeleteEventIndex = function (t) {
    this._deleteEventIndex = t;
  }, ar.prototype.getObject = function () {
    return this._obj;
  }, ar.prototype.compareTo = function (t) {
    var e = t;
    return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0;
  }, ar.prototype.getInsertEvent = function () {
    return this._insertEvent;
  }, ar.prototype.isInsert = function () {
    return this._eventType === ar.INSERT;
  }, ar.prototype.isSameLabel = function (t) {
    return null !== this._label && this._label === t._label;
  }, ar.prototype.getDeleteEventIndex = function () {
    return this._deleteEventIndex;
  }, ar.prototype.interfaces_ = function () {
    return [E];
  }, ar.prototype.getClass = function () {
    return ar;
  }, ur.INSERT.get = function () {
    return 1;
  }, ur.DELETE.get = function () {
    return 2;
  }, Object.defineProperties(ar, ur);

  var lr = function () {};

  lr.prototype.interfaces_ = function () {
    return [];
  }, lr.prototype.getClass = function () {
    return lr;
  };

  var cr = function () {
    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2];
    this._li = t, this._includeProper = e, this._recordIsolated = n;
  };

  cr.prototype.isTrivialIntersection = function (t, e, n, i) {
    if (t === n && 1 === this._li.getIntersectionNum()) {
      if (cr.isAdjacentSegments(e, i)) return !0;

      if (t.isClosed()) {
        var r = t.getNumPoints() - 1;
        if (0 === e && i === r || 0 === i && e === r) return !0;
      }
    }

    return !1;
  }, cr.prototype.getProperIntersectionPoint = function () {
    return this._properIntersectionPoint;
  }, cr.prototype.setIsDoneIfProperInt = function (t) {
    this._isDoneWhenProperInt = t;
  }, cr.prototype.hasProperInteriorIntersection = function () {
    return this._hasProperInterior;
  }, cr.prototype.isBoundaryPointInternal = function (t, e) {
    for (var n = e.iterator(); n.hasNext();) {
      var i = n.next().getCoordinate();
      if (t.isIntersection(i)) return !0;
    }

    return !1;
  }, cr.prototype.hasProperIntersection = function () {
    return this._hasProper;
  }, cr.prototype.hasIntersection = function () {
    return this._hasIntersection;
  }, cr.prototype.isDone = function () {
    return this._isDone;
  }, cr.prototype.isBoundaryPoint = function (t, e) {
    return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1]));
  }, cr.prototype.setBoundaryNodes = function (t, e) {
    this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e;
  }, cr.prototype.addIntersections = function (t, e, n, i) {
    if (t === n && e === i) return null;
    this.numTests++;
    var r = t.getCoordinates()[e],
        o = t.getCoordinates()[e + 1],
        s = n.getCoordinates()[i],
        a = n.getCoordinates()[i + 1];
    this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))));
  }, cr.prototype.interfaces_ = function () {
    return [];
  }, cr.prototype.getClass = function () {
    return cr;
  }, cr.isAdjacentSegments = function (t, e) {
    return 1 === Math.abs(t - e);
  };

  var pr = function (t) {
    function e() {
      t.call(this), this.events = new Nt(), this.nOverlaps = null;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.prepareEvents = function () {
      $e.sort(this.events);

      for (var t = 0; t < this.events.size(); t++) {
        var e = this.events.get(t);
        e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t);
      }
    }, e.prototype.computeIntersections = function () {
      if (1 === arguments.length) {
        var t = arguments[0];
        this.nOverlaps = 0, this.prepareEvents();

        for (var e = 0; e < this.events.size(); e++) {
          var n = this.events.get(e);
          if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break;
        }
      } else if (3 === arguments.length) if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {
        var i = arguments[0],
            r = arguments[1],
            o = arguments[2];
        this.addEdges(i, i), this.addEdges(r, r), this.computeIntersections(o);
      } else if ("boolean" == typeof arguments[2] && T(arguments[0], xt) && arguments[1] instanceof cr) {
        var s = arguments[0],
            a = arguments[1];
        arguments[2] ? this.addEdges(s, null) : this.addEdges(s), this.computeIntersections(a);
      }
    }, e.prototype.addEdge = function (t, e) {
      for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), r = 0; r < i.length - 1; r++) {
        var o = new sr(n, r),
            s = new ar(e, n.getMinX(r), o);
        this.events.add(s), this.events.add(new ar(n.getMaxX(r), s));
      }
    }, e.prototype.processOverlaps = function (t, e, n, i) {
      for (var r = n.getObject(), o = t; o < e; o++) {
        var s = this.events.get(o);

        if (s.isInsert()) {
          var a = s.getObject();
          n.isSameLabel(s) || (r.computeIntersections(a, i), this.nOverlaps++);
        }
      }
    }, e.prototype.addEdges = function () {
      if (1 === arguments.length) for (var t = arguments[0].iterator(); t.hasNext();) {
        var e = t.next();
        this.addEdge(e, e);
      } else if (2 === arguments.length) for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext();) {
        var o = r.next();
        this.addEdge(o, i);
      }
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(lr),
      hr = function () {
    this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;
  },
      fr = {
    NodeComparator: {
      configurable: !0
    }
  };

  hr.prototype.getMin = function () {
    return this._min;
  }, hr.prototype.intersects = function (t, e) {
    return !(this._min > e || this._max < t);
  }, hr.prototype.getMax = function () {
    return this._max;
  }, hr.prototype.toString = function () {
    return Z.toLineString(new C(this._min, 0), new C(this._max, 0));
  }, hr.prototype.interfaces_ = function () {
    return [];
  }, hr.prototype.getClass = function () {
    return hr;
  }, fr.NodeComparator.get = function () {
    return gr;
  }, Object.defineProperties(hr, fr);

  var gr = function () {};

  gr.prototype.compare = function (t, e) {
    var n = t,
        i = e,
        r = (n._min + n._max) / 2,
        o = (i._min + i._max) / 2;
    return r < o ? -1 : r > o ? 1 : 0;
  }, gr.prototype.interfaces_ = function () {
    return [N];
  }, gr.prototype.getClass = function () {
    return gr;
  };

  var dr = function (t) {
    function e() {
      t.call(this), this._item = null;
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2];
      this._min = e, this._max = n, this._item = i;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.query = function (t, e, n) {
      if (!this.intersects(t, e)) return null;
      n.visitItem(this._item);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(hr),
      yr = function (t) {
    function e() {
      t.call(this), this._node1 = null, this._node2 = null;
      var e = arguments[0],
          n = arguments[1];
      this._node1 = e, this._node2 = n, this.buildExtent(this._node1, this._node2);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildExtent = function (t, e) {
      this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max);
    }, e.prototype.query = function (t, e, n) {
      if (!this.intersects(t, e)) return null;
      null !== this._node1 && this._node1.query(t, e, n), null !== this._node2 && this._node2.query(t, e, n);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(hr),
      _r = function () {
    this._leaves = new Nt(), this._root = null, this._level = 0;
  };

  _r.prototype.buildTree = function () {
    $e.sort(this._leaves, new hr.NodeComparator());

    for (var t = this._leaves, e = null, n = new Nt();;) {
      if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);
      e = t, t = n, n = e;
    }
  }, _r.prototype.insert = function (t, e, n) {
    if (null !== this._root) throw new Error("Index cannot be added to once it has been queried");

    this._leaves.add(new dr(t, e, n));
  }, _r.prototype.query = function (t, e, n) {
    this.init(), this._root.query(t, e, n);
  }, _r.prototype.buildRoot = function () {
    if (null !== this._root) return null;
    this._root = this.buildTree();
  }, _r.prototype.printNode = function (t) {
    Y.out.println(Z.toLineString(new C(t._min, this._level), new C(t._max, this._level)));
  }, _r.prototype.init = function () {
    if (null !== this._root) return null;
    this.buildRoot();
  }, _r.prototype.buildLevel = function (t, e) {
    this._level++, e.clear();

    for (var n = 0; n < t.size(); n += 2) {
      var i = t.get(n);
      if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(i);else {
        var r = new yr(t.get(n), t.get(n + 1));
        e.add(r);
      }
    }
  }, _r.prototype.interfaces_ = function () {
    return [];
  }, _r.prototype.getClass = function () {
    return _r;
  };

  var mr = function () {
    this._items = new Nt();
  };

  mr.prototype.visitItem = function (t) {
    this._items.add(t);
  }, mr.prototype.getItems = function () {
    return this._items;
  }, mr.prototype.interfaces_ = function () {
    return [Ke];
  }, mr.prototype.getClass = function () {
    return mr;
  };

  var vr = function () {
    this._index = null;
    var t = arguments[0];
    if (!T(t, Zt)) throw new m("Argument must be Polygonal");
    this._index = new xr(t);
  },
      Ir = {
    SegmentVisitor: {
      configurable: !0
    },
    IntervalIndexedGeometry: {
      configurable: !0
    }
  };

  vr.prototype.locate = function (t) {
    var e = new st(t),
        n = new Er(e);
    return this._index.query(t.y, t.y, n), e.getLocation();
  }, vr.prototype.interfaces_ = function () {
    return [Vn];
  }, vr.prototype.getClass = function () {
    return vr;
  }, Ir.SegmentVisitor.get = function () {
    return Er;
  }, Ir.IntervalIndexedGeometry.get = function () {
    return xr;
  }, Object.defineProperties(vr, Ir);

  var Er = function () {
    this._counter = null;
    var t = arguments[0];
    this._counter = t;
  };

  Er.prototype.visitItem = function (t) {
    var e = t;

    this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));
  }, Er.prototype.interfaces_ = function () {
    return [Ke];
  }, Er.prototype.getClass = function () {
    return Er;
  };

  var xr = function () {
    this._index = new _r();
    var t = arguments[0];
    this.init(t);
  };

  xr.prototype.init = function (t) {
    for (var e = Ci.getLines(t).iterator(); e.hasNext();) {
      var n = e.next().getCoordinates();
      this.addLine(n);
    }
  }, xr.prototype.addLine = function (t) {
    for (var e = 1; e < t.length; e++) {
      var n = new dn(t[e - 1], t[e]),
          i = Math.min(n.p0.y, n.p1.y),
          r = Math.max(n.p0.y, n.p1.y);

      this._index.insert(i, r, n);
    }
  }, xr.prototype.query = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = new mr();
      return this._index.query(t, e, n), n.getItems();
    }

    if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2];

      this._index.query(i, r, o);
    }
  }, xr.prototype.interfaces_ = function () {
    return [];
  }, xr.prototype.getClass = function () {
    return xr;
  };

  var Nr = function (t) {
    function e() {
      if (t.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), 2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1],
            i = gt.OGC_SFS_BOUNDARY_RULE;
        this._argIndex = e, this._parentGeom = n, this._boundaryNodeRule = i, null !== n && this.add(n);
      } else if (3 === arguments.length) {
        var r = arguments[0],
            o = arguments[1],
            s = arguments[2];
        this._argIndex = r, this._parentGeom = o, this._boundaryNodeRule = s, null !== o && this.add(o);
      }
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertBoundaryPoint = function (t, n) {
      var i = this._nodes.addNode(n).getLabel(),
          r = 1;

      w.NONE;
      i.getLocation(t, Se.ON) === w.BOUNDARY && r++;
      var o = e.determineBoundary(this._boundaryNodeRule, r);
      i.setLocation(t, o);
    }, e.prototype.computeSelfNodes = function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];
        return this.computeSelfNodes(t, e, !1);
      }

      if (3 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = arguments[2],
            o = new cr(n, !0, !1);
        o.setIsDoneIfProperInt(r);
        var s = this.createEdgeSetIntersector(),
            a = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne,
            u = i || !a;
        return s.computeIntersections(this._edges, o, u), this.addSelfIntersectionNodes(this._argIndex), o;
      }
    }, e.prototype.computeSplitEdges = function (t) {
      for (var e = this._edges.iterator(); e.hasNext();) {
        e.next().eiList.addSplitEdges(t);
      }
    }, e.prototype.computeEdgeIntersections = function (t, e, n) {
      var i = new cr(e, n, !0);
      i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes());
      return this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, i), i;
    }, e.prototype.getGeometry = function () {
      return this._parentGeom;
    }, e.prototype.getBoundaryNodeRule = function () {
      return this._boundaryNodeRule;
    }, e.prototype.hasTooFewPoints = function () {
      return this._hasTooFewPoints;
    }, e.prototype.addPoint = function () {
      if (arguments[0] instanceof Qt) {
        var t = arguments[0].getCoordinate();
        this.insertPoint(this._argIndex, t, w.INTERIOR);
      } else if (arguments[0] instanceof C) {
        var e = arguments[0];
        this.insertPoint(this._argIndex, e, w.INTERIOR);
      }
    }, e.prototype.addPolygon = function (t) {
      this.addPolygonRing(t.getExteriorRing(), w.EXTERIOR, w.INTERIOR);

      for (var e = 0; e < t.getNumInteriorRing(); e++) {
        var n = t.getInteriorRingN(e);
        this.addPolygonRing(n, w.INTERIOR, w.EXTERIOR);
      }
    }, e.prototype.addEdge = function (t) {
      this.insertEdge(t);
      var e = t.getCoordinates();
      this.insertPoint(this._argIndex, e[0], w.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], w.BOUNDARY);
    }, e.prototype.addLineString = function (t) {
      var e = Lt.removeRepeatedPoints(t.getCoordinates());
      if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;
      var n = new ni(e, new Pe(this._argIndex, w.INTERIOR));
      this._lineEdgeMap.put(t, n), this.insertEdge(n), et.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1]);
    }, e.prototype.getInvalidPoint = function () {
      return this._invalidPoint;
    }, e.prototype.getBoundaryPoints = function () {
      for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, i = t.iterator(); i.hasNext();) {
        var r = i.next();
        e[n++] = r.getCoordinate().copy();
      }

      return e;
    }, e.prototype.getBoundaryNodes = function () {
      return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
    }, e.prototype.addSelfIntersectionNode = function (t, e, n) {
      if (this.isBoundaryNode(t, e)) return null;
      n === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n);
    }, e.prototype.addPolygonRing = function (t, e, n) {
      if (t.isEmpty()) return null;
      var i = Lt.removeRepeatedPoints(t.getCoordinates());
      if (i.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = i[0], null;
      var r = e,
          o = n;
      at.isCCW(i) && (r = n, o = e);
      var s = new ni(i, new Pe(this._argIndex, w.BOUNDARY, r, o));
      this._lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this._argIndex, i[0], w.BOUNDARY);
    }, e.prototype.insertPoint = function (t, e, n) {
      var i = this._nodes.addNode(e),
          r = i.getLabel();

      null === r ? i._label = new Pe(t, n) : r.setLocation(t, n);
    }, e.prototype.createEdgeSetIntersector = function () {
      return new pr();
    }, e.prototype.addSelfIntersectionNodes = function (t) {
      for (var e = this._edges.iterator(); e.hasNext();) for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.eiList.iterator(); r.hasNext();) {
        var o = r.next();
        this.addSelfIntersectionNode(t, o.coord, i);
      }
    }, e.prototype.add = function () {
      if (1 !== arguments.length) return t.prototype.add.apply(this, arguments);
      var e = arguments[0];
      if (e.isEmpty()) return null;
      if (e instanceof ne && (this._useBoundaryDeterminationRule = !1), e instanceof $t) this.addPolygon(e);else if (e instanceof Kt) this.addLineString(e);else if (e instanceof Qt) this.addPoint(e);else if (e instanceof te) this.addCollection(e);else if (e instanceof Xt) this.addCollection(e);else if (e instanceof ne) this.addCollection(e);else {
        if (!(e instanceof zt)) throw new Error(e.getClass().getName());
        this.addCollection(e);
      }
    }, e.prototype.addCollection = function (t) {
      for (var e = 0; e < t.getNumGeometries(); e++) {
        var n = t.getGeometryN(e);
        this.add(n);
      }
    }, e.prototype.locate = function (t) {
      return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom);
    }, e.prototype.findEdge = function () {
      if (1 === arguments.length) {
        var e = arguments[0];
        return this._lineEdgeMap.get(e);
      }

      return t.prototype.findEdge.apply(this, arguments);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e.determineBoundary = function (t, e) {
      return t.isInBoundary(e) ? w.BOUNDARY : w.INTERIOR;
    }, e;
  }(Ye),
      Cr = function () {
    if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
      var t = arguments[0];
      this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = gt.OGC_SFS_BOUNDARY_RULE;
      e.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e, i), this._arg[1] = new Nr(1, n, i);
    } else if (3 === arguments.length) {
      var r = arguments[0],
          o = arguments[1],
          s = arguments[2];
      r.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r, s), this._arg[1] = new Nr(1, o, s);
    }
  };

  Cr.prototype.getArgGeometry = function (t) {
    return this._arg[t].getGeometry();
  }, Cr.prototype.setComputationPrecision = function (t) {
    this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel);
  }, Cr.prototype.interfaces_ = function () {
    return [];
  }, Cr.prototype.getClass = function () {
    return Cr;
  };

  var Sr = function () {};

  Sr.prototype.interfaces_ = function () {
    return [];
  }, Sr.prototype.getClass = function () {
    return Sr;
  }, Sr.map = function () {
    if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {
      for (var t = arguments[0], e = arguments[1], n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {
        var r = e.map(t.getGeometryN(i));
        null !== r && n.add(r);
      }

      return t.getFactory().buildGeometry(n);
    }

    if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {
      for (var o = arguments[0], s = arguments[1], a = new Nt(), u = o.iterator(); u.hasNext();) {
        var l = u.next(),
            c = s.map(l);
        null !== c && a.add(c);
      }

      return a;
    }
  }, Sr.MapOp = function () {};

  var Lr = function (t) {
    function e() {
      var e = arguments[0],
          n = arguments[1];
      t.call(this, e, n), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e.getFactory();
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertUniqueEdge = function (t) {
      var e = this._edgeList.findEqualEdge(t);

      if (null !== e) {
        var n = e.getLabel(),
            i = t.getLabel();
        e.isPointwiseEqual(t) || (i = new Pe(t.getLabel())).flip();
        var r = e.getDepth();
        r.isNull() && r.add(n), r.add(i), n.merge(i);
      } else this._edgeList.add(t);
    }, e.prototype.getGraph = function () {
      return this._graph;
    }, e.prototype.cancelDuplicateResultEdges = function () {
      for (var t = this._graph.getEdgeEnds().iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getSym();
        e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1));
      }
    }, e.prototype.isCoveredByLA = function (t) {
      return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList);
    }, e.prototype.computeGeometry = function (t, n, i, r) {
      var o = new Nt();
      return o.addAll(t), o.addAll(n), o.addAll(i), o.isEmpty() ? e.createEmptyResult(r, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o);
    }, e.prototype.mergeSymLabels = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
        t.next().getEdges().mergeSymLabels();
      }
    }, e.prototype.isCovered = function (t, e) {
      for (var n = e.iterator(); n.hasNext();) {
        var i = n.next();
        if (this._ptLocator.locate(t, i) !== w.EXTERIOR) return !0;
      }

      return !1;
    }, e.prototype.replaceCollapsedEdges = function () {
      for (var t = new Nt(), e = this._edgeList.iterator(); e.hasNext();) {
        var n = e.next();
        n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()));
      }

      this._edgeList.addAll(t);
    }, e.prototype.updateNodeLabelling = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getEdges().getLabel();
        e.getLabel().merge(n);
      }
    }, e.prototype.getResultGeometry = function (t) {
      return this.computeOverlay(t), this._resultGeom;
    }, e.prototype.insertUniqueEdges = function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();
        this.insertUniqueEdge(n);
      }
    }, e.prototype.computeOverlay = function (t) {
      this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
      var e = new Nt();
      this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
      var n = new ke(this._geomFact);
      n.add(this._graph), this._resultPolyList = n.getPolygons();
      var i = new ji(this, this._geomFact, this._ptLocator);
      this._resultLineList = i.build(t);
      var r = new Hi(this, this._geomFact, this._ptLocator);
      this._resultPointList = r.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t);
    }, e.prototype.labelIncompleteNode = function (t, e) {
      var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());

      t.getLabel().setLocation(e, n);
    }, e.prototype.copyPoints = function (t) {
      for (var e = this._arg[t].getNodeIterator(); e.hasNext();) {
        var n = e.next();

        this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t));
      }
    }, e.prototype.findResultAreaEdges = function (t) {
      for (var n = this._graph.getEdgeEnds().iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.getLabel();
        r.isArea() && !i.isInteriorAreaEdge() && e.isResultOfOp(r.getLocation(0, Se.RIGHT), r.getLocation(1, Se.RIGHT), t) && i.setInResult(!0);
      }
    }, e.prototype.computeLabelsFromDepths = function () {
      for (var t = this._edgeList.iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getLabel(),
            i = e.getDepth();

        if (!i.isNull()) {
          i.normalize();

          for (var r = 0; r < 2; r++) n.isNull(r) || !n.isArea() || i.isNull(r) || (0 === i.getDelta(r) ? n.toLine(r) : (et.isTrue(!i.isNull(r, Se.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(r, Se.LEFT, i.getLocation(r, Se.LEFT)), et.isTrue(!i.isNull(r, Se.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(r, Se.RIGHT, i.getLocation(r, Se.RIGHT))));
        }
      }
    }, e.prototype.computeLabelling = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
        t.next().getEdges().computeLabelling(this._arg);
      }

      this.mergeSymLabels(), this.updateNodeLabelling();
    }, e.prototype.labelIncompleteNodes = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getLabel();
        e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n);
      }
    }, e.prototype.isCoveredByA = function (t) {
      return !!this.isCovered(t, this._resultPolyList);
    }, e.prototype.interfaces_ = function () {
      return [];
    }, e.prototype.getClass = function () {
      return e;
    }, e;
  }(Cr);

  Lr.overlayOp = function (t, e, n) {
    return new Lr(t, e).getResultGeometry(n);
  }, Lr.intersection = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) return Lr.createEmptyResult(Lr.INTERSECTION, t, e, t.getFactory());

    if (t.isGeometryCollection()) {
      var n = e;
      return ki.map(t, {
        interfaces_: function () {
          return [Sr.MapOp];
        },
        map: function (t) {
          return t.intersection(n);
        }
      });
    }

    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.INTERSECTION);
  }, Lr.symDifference = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty()) return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t, e, t.getFactory());
      if (t.isEmpty()) return e.copy();
      if (e.isEmpty()) return t.copy();
    }

    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.SYMDIFFERENCE);
  }, Lr.resultDimension = function (t, e, n) {
    var i = e.getDimension(),
        r = n.getDimension(),
        o = -1;

    switch (t) {
      case Lr.INTERSECTION:
        o = Math.min(i, r);
        break;

      case Lr.UNION:
        o = Math.max(i, r);
        break;

      case Lr.DIFFERENCE:
        o = i;
        break;

      case Lr.SYMDIFFERENCE:
        o = Math.max(i, r);
    }

    return o;
  }, Lr.createEmptyResult = function (t, e, n, i) {
    var r = null;

    switch (Lr.resultDimension(t, e, n)) {
      case -1:
        r = i.createGeometryCollection(new Array(0).fill(null));
        break;

      case 0:
        r = i.createPoint();
        break;

      case 1:
        r = i.createLineString();
        break;

      case 2:
        r = i.createPolygon();
    }

    return r;
  }, Lr.difference = function (t, e) {
    return t.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.DIFFERENCE));
  }, Lr.isResultOfOp = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = t.getLocation(0),
          i = t.getLocation(1);
      return Lr.isResultOfOp(n, i, e);
    }

    if (3 === arguments.length) {
      var r = arguments[0],
          o = arguments[1],
          s = arguments[2];

      switch (r === w.BOUNDARY && (r = w.INTERIOR), o === w.BOUNDARY && (o = w.INTERIOR), s) {
        case Lr.INTERSECTION:
          return r === w.INTERIOR && o === w.INTERIOR;

        case Lr.UNION:
          return r === w.INTERIOR || o === w.INTERIOR;

        case Lr.DIFFERENCE:
          return r === w.INTERIOR && o !== w.INTERIOR;

        case Lr.SYMDIFFERENCE:
          return r === w.INTERIOR && o !== w.INTERIOR || r !== w.INTERIOR && o === w.INTERIOR;
      }

      return !1;
    }
  }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;

  var br = function () {
    this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();
    var t = arguments[0],
        e = arguments[1];
    this._g = t, this._boundaryDistanceTolerance = e, this._linework = this.extractLinework(t);
  };

  br.prototype.isWithinToleranceOfBoundary = function (t) {
    for (var e = 0; e < this._linework.getNumGeometries(); e++) for (var n = this._linework.getGeometryN(e).getCoordinateSequence(), i = 0; i < n.size() - 1; i++) {
      n.getCoordinate(i, this._seg.p0), n.getCoordinate(i + 1, this._seg.p1);
      if (this._seg.distance(t) <= this._boundaryDistanceTolerance) return !0;
    }

    return !1;
  }, br.prototype.getLocation = function (t) {
    return this.isWithinToleranceOfBoundary(t) ? w.BOUNDARY : this._ptLocator.locate(t, this._g);
  }, br.prototype.extractLinework = function (t) {
    var e = new wr();
    t.apply(e);

    var n = e.getLinework(),
        i = _e.toLineStringArray(n);

    return t.getFactory().createMultiLineString(i);
  }, br.prototype.interfaces_ = function () {
    return [];
  }, br.prototype.getClass = function () {
    return br;
  };

  var wr = function () {
    this._linework = null, this._linework = new Nt();
  };

  wr.prototype.getLinework = function () {
    return this._linework;
  }, wr.prototype.filter = function (t) {
    if (t instanceof $t) {
      var e = t;

      this._linework.add(e.getExteriorRing());

      for (var n = 0; n < e.getNumInteriorRing(); n++) this._linework.add(e.getInteriorRingN(n));
    }
  }, wr.prototype.interfaces_ = function () {
    return [Vt];
  }, wr.prototype.getClass = function () {
    return wr;
  };

  var Or = function () {
    this._g = null, this._doLeft = !0, this._doRight = !0;
    var t = arguments[0];
    this._g = t;
  };

  Or.prototype.extractPoints = function (t, e, n) {
    for (var i = t.getCoordinates(), r = 0; r < i.length - 1; r++) this.computeOffsetPoints(i[r], i[r + 1], e, n);
  }, Or.prototype.setSidesToGenerate = function (t, e) {
    this._doLeft = t, this._doRight = e;
  }, Or.prototype.getPoints = function (t) {
    for (var e = new Nt(), n = Ci.getLines(this._g).iterator(); n.hasNext();) {
      var i = n.next();
      this.extractPoints(i, t, e);
    }

    return e;
  }, Or.prototype.computeOffsetPoints = function (t, e, n, i) {
    var r = e.x - t.x,
        o = e.y - t.y,
        s = Math.sqrt(r * r + o * o),
        a = n * r / s,
        u = n * o / s,
        l = (e.x + t.x) / 2,
        c = (e.y + t.y) / 2;

    if (this._doLeft) {
      var p = new C(l - u, c + a);
      i.add(p);
    }

    if (this._doRight) {
      var h = new C(l + u, c - a);
      i.add(h);
    }
  }, Or.prototype.interfaces_ = function () {
    return [];
  }, Or.prototype.getClass = function () {
    return Or;
  };

  var Tr = function t() {
    this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t.TOLERANCE, this._testCoords = new Nt();
    var e = arguments[0],
        n = arguments[1],
        i = arguments[2];
    this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(e, n), this._geom = [e, n, i], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];
  },
      Rr = {
    TOLERANCE: {
      configurable: !0
    }
  };

  Tr.prototype.reportResult = function (t, e, n) {
    Y.out.println("Overlay result invalid - A:" + w.toLocationSymbol(e[0]) + " B:" + w.toLocationSymbol(e[1]) + " expected:" + (n ? "i" : "e") + " actual:" + w.toLocationSymbol(e[2]));
  }, Tr.prototype.isValid = function (t) {
    this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
    var e = this.checkValid(t);
    return e;
  }, Tr.prototype.checkValid = function () {
    if (1 === arguments.length) {
      for (var t = arguments[0], e = 0; e < this._testCoords.size(); e++) {
        var n = this._testCoords.get(e);

        if (!this.checkValid(t, n)) return this._invalidLocation = n, !1;
      }

      return !0;
    }

    if (2 === arguments.length) {
      var i = arguments[0],
          r = arguments[1];
      return this._location[0] = this._locFinder[0].getLocation(r), this._location[1] = this._locFinder[1].getLocation(r), this._location[2] = this._locFinder[2].getLocation(r), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i, this._location);
    }
  }, Tr.prototype.addTestPts = function (t) {
    var e = new Or(t);

    this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance));
  }, Tr.prototype.isValidResult = function (t, e) {
    var n = Lr.isResultOfOp(e[0], e[1], t),
        i = !(n ^ e[2] === w.INTERIOR);
    return i || this.reportResult(t, e, n), i;
  }, Tr.prototype.getInvalidLocation = function () {
    return this._invalidLocation;
  }, Tr.prototype.interfaces_ = function () {
    return [];
  }, Tr.prototype.getClass = function () {
    return Tr;
  }, Tr.hasLocation = function (t, e) {
    for (var n = 0; n < 3; n++) if (t[n] === e) return !0;

    return !1;
  }, Tr.computeBoundaryDistanceTolerance = function (t, e) {
    return Math.min(Ji.computeSizeBasedSnapTolerance(t), Ji.computeSizeBasedSnapTolerance(e));
  }, Tr.isValid = function (t, e, n, i) {
    return new Tr(t, e, i).isValid(n);
  }, Rr.TOLERANCE.get = function () {
    return 1e-6;
  }, Object.defineProperties(Tr, Rr);

  var Pr = function t(e) {
    this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = t.extractFactory(e), this._inputGeoms = e;
  };

  Pr.prototype.extractElements = function (t, e) {
    if (null === t) return null;

    for (var n = 0; n < t.getNumGeometries(); n++) {
      var i = t.getGeometryN(n);
      this._skipEmpty && i.isEmpty() || e.add(i);
    }
  }, Pr.prototype.combine = function () {
    for (var t = new Nt(), e = this._inputGeoms.iterator(); e.hasNext();) {
      var n = e.next();
      this.extractElements(n, t);
    }

    return 0 === t.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t);
  }, Pr.prototype.interfaces_ = function () {
    return [];
  }, Pr.prototype.getClass = function () {
    return Pr;
  }, Pr.combine = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return new Pr(t).combine();
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return new Pr(Pr.createList(e, n)).combine();
    }

    if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2];
      return new Pr(Pr.createList(i, r, o)).combine();
    }
  }, Pr.extractFactory = function (t) {
    return t.isEmpty() ? null : t.iterator().next().getFactory();
  }, Pr.createList = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = new Nt();
      return n.add(t), n.add(e), n;
    }

    if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          o = arguments[2],
          s = new Nt();
      return s.add(i), s.add(r), s.add(o), s;
    }
  };

  var Dr = function () {
    this._inputPolys = null, this._geomFactory = null;
    var t = arguments[0];
    this._inputPolys = t, null === this._inputPolys && (this._inputPolys = new Nt());
  },
      Mr = {
    STRTREE_NODE_CAPACITY: {
      configurable: !0
    }
  };

  Dr.prototype.reduceToGeometries = function (t) {
    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {
      var i = n.next(),
          r = null;
      T(i, xt) ? r = this.unionTree(i) : i instanceof ct && (r = i), e.add(r);
    }

    return e;
  }, Dr.prototype.extractByEnvelope = function (t, e, n) {
    for (var i = new Nt(), r = 0; r < e.getNumGeometries(); r++) {
      var o = e.getGeometryN(r);
      o.getEnvelopeInternal().intersects(t) ? i.add(o) : n.add(o);
    }

    return this._geomFactory.buildGeometry(i);
  }, Dr.prototype.unionOptimized = function (t, e) {
    var n = t.getEnvelopeInternal(),
        i = e.getEnvelopeInternal();

    if (!n.intersects(i)) {
      return Pr.combine(t, e);
    }

    if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);
    var r = n.intersection(i);
    return this.unionUsingEnvelopeIntersection(t, e, r);
  }, Dr.prototype.union = function () {
    if (null === this._inputPolys) throw new Error("union() method cannot be called twice");
    if (this._inputPolys.isEmpty()) return null;
    this._geomFactory = this._inputPolys.iterator().next().getFactory();

    for (var t = new sn(Dr.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext();) {
      var n = e.next();
      t.insert(n.getEnvelopeInternal(), n);
    }

    this._inputPolys = null;
    var i = t.itemsTree();
    return this.unionTree(i);
  }, Dr.prototype.binaryUnion = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.binaryUnion(t, 0, t.size());
    }

    if (3 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2];

      if (i - n <= 1) {
        var r = Dr.getGeometry(e, n);
        return this.unionSafe(r, null);
      }

      if (i - n == 2) return this.unionSafe(Dr.getGeometry(e, n), Dr.getGeometry(e, n + 1));
      var o = Math.trunc((i + n) / 2),
          s = this.binaryUnion(e, n, o),
          a = this.binaryUnion(e, o, i);
      return this.unionSafe(s, a);
    }
  }, Dr.prototype.repeatedUnion = function (t) {
    for (var e = null, n = t.iterator(); n.hasNext();) {
      var i = n.next();
      e = null === e ? i.copy() : e.union(i);
    }

    return e;
  }, Dr.prototype.unionSafe = function (t, e) {
    return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e);
  }, Dr.prototype.unionActual = function (t, e) {
    return Dr.restrictToPolygons(t.union(e));
  }, Dr.prototype.unionTree = function (t) {
    var e = this.reduceToGeometries(t);
    return this.binaryUnion(e);
  }, Dr.prototype.unionUsingEnvelopeIntersection = function (t, e, n) {
    var i = new Nt(),
        r = this.extractByEnvelope(n, t, i),
        o = this.extractByEnvelope(n, e, i),
        s = this.unionActual(r, o);
    i.add(s);
    return Pr.combine(i);
  }, Dr.prototype.bufferUnion = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return t.get(0).getFactory().buildGeometry(t).buffer(0);
    }

    if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      return e.getFactory().createGeometryCollection([e, n]).buffer(0);
    }
  }, Dr.prototype.interfaces_ = function () {
    return [];
  }, Dr.prototype.getClass = function () {
    return Dr;
  }, Dr.restrictToPolygons = function (t) {
    if (T(t, Zt)) return t;
    var e = Ni.getPolygons(t);
    return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(_e.toPolygonArray(e));
  }, Dr.getGeometry = function (t, e) {
    return e >= t.size() ? null : t.get(e);
  }, Dr.union = function (t) {
    return new Dr(t).union();
  }, Mr.STRTREE_NODE_CAPACITY.get = function () {
    return 4;
  }, Object.defineProperties(Dr, Mr);

  var Ar = function () {};

  Ar.prototype.interfaces_ = function () {
    return [];
  }, Ar.prototype.getClass = function () {
    return Ar;
  }, Ar.union = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty()) return Lr.createEmptyResult(Lr.UNION, t, e, t.getFactory());
      if (t.isEmpty()) return e.copy();
      if (e.isEmpty()) return t.copy();
    }

    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.UNION);
  }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/***/ (function(module) {

module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}

/***/ }),

/***/ "./src/js/front/modules/filters.js":
/*!*****************************************!*\
  !*** ./src/js/front/modules/filters.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Filters; }
/* harmony export */ });
/* harmony import */ var _select2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select2 */ "./src/js/front/modules/select2.js");



const $ = jQuery.noConflict();
class Filters {
  constructor(filters) {
    this.filters = filters;
    document.getElementById('js-twer-filters-close').addEventListener('click', e => {
      e.preventDefault();
      document.getElementById('js-twer-store-locator-filters-area').classList.add('hide');
    });
    this.initStoreLocatorMapFilters();
  }

  initStoreLocatorMapFilters() {
    if (!lodash.isEmpty(this.filters)) {
      document.getElementById('js-twer-filters').innerHTML = '';

      for (const [key, filter] of Object.entries(this.filters)) {
        switch (filter.type) {
          case 'select':
            const $selectTemplate = document.getElementById('js-twer-filter-select').content;
            const $selectFilter = document.importNode($selectTemplate, true).querySelector('.js-twer-filter-form-select');
            const $selectLabel = $selectFilter.getElementsByClassName('js-twer-filter-label')[0];
            const $select = $selectFilter.getElementsByClassName('js-twer-filter-select')[0];
            $selectLabel.innerText = filter.name;
            $selectLabel.setAttribute('for', filter.key);
            $select.id = filter.key;
            $select.setAttribute('name', filter.key);

            while ($select.options.length > 0) {
              $select.remove(0);
            }

            if (filter.value.length > 0) {
              for (let i = 0; i < filter.value.length; i++) {
                const option = document.createElement('option');
                option.text = filter.value[i].label;
                option.value = filter.value[i].value;

                if (filter.value[i].value === filter.selected) {
                  option.selected = filter.selected;
                }

                $select.appendChild(option);
              }
            }

            document.getElementById('js-twer-filters').appendChild($selectFilter);
            break;

          case 'categories':
            const $categoriesTemplate = document.getElementById('js-twer-filter-categories').content;
            const $categoriesFilter = document.importNode($categoriesTemplate, true).querySelector('.js-twer-filter-form-categories');
            $categoriesFilter.dataset.filterId = filter.key;
            const $categoriesLabel = $categoriesFilter.getElementsByClassName('js-twer-filter-label')[0];
            const $categoriesSelect = $categoriesFilter.getElementsByClassName('js-twer-filter-categories')[0];
            $categoriesLabel.innerText = filter.name;
            $categoriesLabel.setAttribute('for', filter.key);
            $categoriesSelect.id = filter.key;
            $categoriesSelect.setAttribute('name', `${filter.key}[]`);

            if (filter.value.length > 0) {
              for (let i = 0; i < filter.value.length; i++) {
                const option = document.createElement('option');

                if (typeof filter.value[i] === 'object') {
                  option.innerHTML = filter.value[i].label;
                  option.value = filter.value[i].value;
                  option.dataset.routes = filter.value[i].route;

                  for (let j = 0; j < filter.selected.length; j++) {
                    if (filter.value[i].value === filter.selected[j]) {
                      option.selected = true;
                    }
                  }
                } else {
                  option.innerHTML = filter.value[i];
                  option.value = i;
                }

                $categoriesSelect.appendChild(option);
              }
            }

            document.getElementById('js-twer-filters').appendChild($categoriesFilter);
            break;

          case 'multiselect':
            const $multiselectTemplate = document.getElementById('js-twer-filter-multiselect').content;
            const $multiselectFilter = document.importNode($multiselectTemplate, true).querySelector('.js-twer-filter-form-multiselect');
            $multiselectFilter.dataset.filterId = filter.key;
            const $multiselectLabel = $multiselectFilter.getElementsByClassName('js-twer-filter-label')[0];
            const $multiselectSelect = $multiselectFilter.getElementsByClassName('js-twer-filter-multiselect')[0];
            $multiselectLabel.innerText = filter.name;
            $multiselectLabel.setAttribute('for', filter.key);
            $multiselectSelect.id = filter.key;
            $multiselectSelect.setAttribute('name', `${filter.key}[]`);

            if (filter.value.length > 0) {
              for (let i = 0; i < filter.value.length; i++) {
                const option = document.createElement('option');

                if (typeof filter.value[i] === 'object') {
                  option.innerHTML = filter.value[i].label;
                  option.value = filter.value[i].value;

                  for (let j = 0; j < filter.selected.length; j++) {
                    if (filter.value[i].value === filter.selected[j]) {
                      option.selected = true;
                    }
                  }
                } else {
                  option.innerHTML = filter.value[i];
                  option.value = i;
                }

                $multiselectSelect.appendChild(option);
              }
            }

            document.getElementById('js-twer-filters').appendChild($multiselectFilter);
            break;

          case 'true_false':
            const $trueFalseTemplate = document.getElementById('js-twer-filter-true-false').content;
            const $trueFalseFilter = document.importNode($trueFalseTemplate, true).querySelector('.js-twer-filter-form-true-false');
            $trueFalseFilter.dataset.filterId = filter.key;
            const $trueFalseLabel = $trueFalseFilter.getElementsByClassName('js-twer-filter-label')[0];
            const $trueFalseSwitcherLabel = $trueFalseFilter.getElementsByClassName('js-twer-filter-switcher-label')[0];
            const $trueFalseCheckbox = $trueFalseFilter.getElementsByClassName('js-twer-filter-true-false-checkbox')[0];
            const $trueFalseHiddenCheckbox = $trueFalseFilter.getElementsByClassName('js-twer-filter-true-false-hidden-checkbox')[0];
            $trueFalseLabel.innerText = filter.name;
            $trueFalseLabel.setAttribute('for', filter.key);
            $trueFalseCheckbox.id = filter.key;
            $trueFalseCheckbox.setAttribute('name', `${filter.key}[]`);
            $trueFalseHiddenCheckbox.setAttribute('name', filter.key);
            $trueFalseSwitcherLabel.setAttribute('for', filter.key);
            document.getElementById('js-twer-filters').appendChild($trueFalseFilter);
            break;

          case 'range':
            const $rangeTemplate = document.getElementById('js-twer-filter-range').content;
            const $rangeFilter = document.importNode($rangeTemplate, true).querySelector('.js-twer-filter-form-range');
            $rangeFilter.dataset.filterId = filter.key;
            $rangeFilter.getElementsByClassName('js-twer-filter-label')[0].innerText = filter.name;
            const $prefix = $rangeFilter.getElementsByClassName('js-twer-filter-prefix');
            const $suffix = $rangeFilter.getElementsByClassName('js-twer-filter-suffix');

            for (let $prefixItem of $prefix) {
              $prefixItem.innerText = filter.prefix.trim();
            }

            for (let $suffixItem of $suffix) {
              $suffixItem.innerText = filter.suffix.trim();
            }

            const $start = $rangeFilter.getElementsByClassName('js-twer-filter-range-value-start')[0];
            const $end = $rangeFilter.getElementsByClassName('js-twer-filter-range-value-end')[0];
            $start.setAttribute('min', filter.value.min);
            $start.setAttribute('max', filter.value.max);
            $start.setAttribute('name', `${filter.key}[start]`);
            $end.setAttribute('min', filter.value.min);
            $end.setAttribute('max', filter.value.max);
            $end.setAttribute('name', `${filter.key}[end]`);
            $start.value = filter.value.min;
            $end.value = filter.value.max;
            $rangeFilter.getElementsByClassName('js-twer-slider')[0].dataset.defaultValueMin = filter.defaultRangeValue.min;
            $rangeFilter.getElementsByClassName('js-twer-slider')[0].dataset.defaultValueMax = filter.defaultRangeValue.max;
            document.getElementById('js-twer-filters').appendChild($rangeFilter);
            break;
        }
      }
    }
  }

}

/***/ }),

/***/ "./src/js/front/modules/select2.js":
/*!*****************************************!*\
  !*** ./src/js/front/modules/select2.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Select2; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! select2 */ "./node_modules/select2/dist/js/select2.js");
/* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(select2__WEBPACK_IMPORTED_MODULE_1__);



const $ = jQuery.noConflict();

class Select2 {
  constructor(options, $select) {
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "$select", null);

    const Defaults = $.fn.select2.amd.require('select2/defaults');

    $.extend(Defaults.defaults, {
      searchInputPlaceholder: ''
    });

    const SearchDropdown = $.fn.select2.amd.require('select2/dropdown/search');

    const _renderSearchDropdown = SearchDropdown.prototype.render;

    SearchDropdown.prototype.render = function (decorated) {
      // invoke parent method
      const $rendered = _renderSearchDropdown.apply(this, Array.prototype.slice.apply(arguments));

      this.$search.attr('placeholder', this.options.get('searchInputPlaceholder'));
      return $rendered;
    };

    const defaults = {
      minimumResultsForSearch: Infinity,
      width: '100%',
      dropdownCssClass: 'twer-select2-ddl',
      selectionCssClass: 'twer-select-control'
    };
    const settings = $.extend(true, defaults, options);
    this.$select = $select.select2(settings);
  }

}

/***/ }),

/***/ "./src/js/front/modules/twer-store-locator-control/events.js":
/*!*******************************************************************!*\
  !*** ./src/js/front/modules/twer-store-locator-control/events.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var nanoid = (__webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js").nanoid);
/**
 * Construct a new mapbox event client to send interaction events to the mapbox event service
 * @param {Object} options options with which to create the service
 * @param {String} options.accessToken the mapbox access token to make requests
 * @param {Number} [options.flushInterval=1000] the number of ms after which to flush the event queue
 * @param {Number} [options.maxQueueSize=100] the number of events to queue before flushing
 * @private
 */


function MapboxEventManager(options) {
  this.origin = options.origin || 'https://api.mapbox.com';
  this.endpoint = 'events/v2';
  this.access_token = options.accessToken;
  this.version = '0.2.0';
  this.sessionID = this.generateSessionID();
  this.userAgent = this.getUserAgent();
  this.options = options;
  this.send = this.send.bind(this); // parse global options to be sent with each request

  this.countries = options.countries ? options.countries.split(",") : null;
  this.types = options.types ? options.types.split(",") : null;
  this.bbox = options.bbox ? options.bbox : null;
  this.language = options.language ? options.language.split(",") : null;
  this.limit = options.limit ? +options.limit : null;
  this.locale = navigator.language || null;
  this.enableEventLogging = this.shouldEnableLogging(options);
  this.eventQueue = new Array();
  this.flushInterval = options.flushInterval || 1000;
  this.maxQueueSize = options.maxQueueSize || 100;
  this.timer = this.flushInterval ? setTimeout(this.flush.bind(this), this.flushInterval) : null; // keep some state to deduplicate requests if necessary

  this.lastSentInput = "";
  this.lastSentIndex = 0;
}

MapboxEventManager.prototype = {
  /**
   * Send a search.select event to the mapbox events service
   * This event marks the array index of the item selected by the user out of the array of possible options
   * @private
   * @param {Object} selected the geojson feature selected by the user
   * @param {Object} geocoder a mapbox-gl-geocoder instance
   * @returns {Promise}
   */
  select: function (selected, geocoder) {
    var resultIndex = this.getSelectedIndex(selected, geocoder);
    var payload = this.getEventPayload('search.select', geocoder);
    payload.resultIndex = resultIndex;
    payload.resultPlaceName = selected.place_name;
    payload.resultId = selected.id;

    if (resultIndex === this.lastSentIndex && payload.queryString === this.lastSentInput || resultIndex == -1) {
      // don't log duplicate events if the user re-selected the same feature on the same search
      return;
    }

    this.lastSentIndex = resultIndex;
    this.lastSentInput = payload.queryString;
    if (!payload.queryString) return; // will be rejected

    return this.push(payload);
  },

  /**
   * Send a search-start event to the mapbox events service
   * This turnstile event marks when a user starts a new search
   * @private
   * @param {Object} geocoder a mapbox-gl-geocoder instance
   * @returns {Promise}
   */
  start: function (geocoder) {
    var payload = this.getEventPayload('search.start', geocoder);
    if (!payload.queryString) return; // will be rejected

    return this.push(payload);
  },

  /**
   * Send a search-keyevent event to the mapbox events service
   * This event records each keypress in sequence
   * @private
   * @param {Object} keyEvent the keydown event to log
   * @param {Object} geocoder a mapbox-gl-geocoder instance
   *
   */
  keyevent: function (keyEvent, geocoder) {
    //pass invalid event
    if (!keyEvent.key) return; // don't send events for keys that don't change the input
    // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN

    if (keyEvent.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(keyEvent.keyCode) !== -1) return;
    var payload = this.getEventPayload('search.keystroke', geocoder);
    payload.lastAction = keyEvent.key;
    if (!payload.queryString) return; // will be rejected

    return this.push(payload);
  },

  /**
   * Send an event to the events service
   *
   * The event is skipped if the instance is not enabled to send logging events
   *
   * @private
   * @param {Object} payload the http POST body of the event
   * @param {Function} [callback] a callback function to invoke when the send has completed
   * @returns {Promise}
   */
  send: function (payload, callback) {
    if (!this.enableEventLogging) {
      if (callback) return callback();
      return;
    }

    var options = this.getRequestOptions(payload);
    this.request(options, function (err) {
      if (err) return this.handleError(err, callback);

      if (callback) {
        return callback();
      }
    }.bind(this));
  },

  /**
   * Get http request options
   * @private
   * @param {*} payload
   */
  getRequestOptions: function (payload) {
    if (!Array.isArray(payload)) payload = [payload];
    var options = {
      // events must be sent with POST
      method: "POST",
      host: this.origin,
      path: this.endpoint + "?access_token=" + this.access_token,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload) //events are arrays

    };
    return options;
  },

  /**
   * Get the event payload to send to the events service
   * Most payload properties are shared across all events
   * @private
   * @param {String} event the name of the event to send to the events service. Valid options are 'search.start', 'search.select', 'search.feedback'.
   * @param {Object} geocoder a mapbox-gl-geocoder instance
   * @returns {Object} an event payload
   */
  getEventPayload: function (event, geocoder) {
    // Handle proximity, whether null, lat/lng coordinate object, or 'ip'
    var proximity;

    if (!geocoder.options.proximity) {
      proximity = null;
    } else if (typeof geocoder.options.proximity === 'object') {
      proximity = [geocoder.options.proximity.longitude, geocoder.options.proximity.latitude];
    } else if (geocoder.options.proximity === 'ip') {
      proximity = [999, 999]; // Alias for 'ip' in event logs
    } else {
      proximity = geocoder.options.proximity;
    }

    var zoom = geocoder._map ? geocoder._map.getZoom() : undefined;
    var payload = {
      event: event,
      created: +new Date(),
      sessionIdentifier: this.sessionID,
      country: this.countries,
      userAgent: this.userAgent,
      language: this.language,
      bbox: this.bbox,
      types: this.types,
      endpoint: 'mapbox.places',
      autocomplete: geocoder.options.autocomplete,
      fuzzyMatch: geocoder.options.fuzzyMatch,
      proximity: proximity,
      limit: geocoder.options.limit,
      routing: geocoder.options.routing,
      worldview: geocoder.options.worldview,
      mapZoom: zoom,
      keyboardLocale: this.locale
    }; // get the text in the search bar

    if (event === "search.select") {
      payload.queryString = geocoder.inputString;
    } else if (event != "search.select" && geocoder._inputEl) {
      payload.queryString = geocoder._inputEl.value;
    } else {
      payload.queryString = geocoder.inputString;
    }

    return payload;
  },

  /**
   * Wraps the request function for easier testing
   * Make an http request and invoke a callback
   * @private
   * @param {Object} opts options describing the http request to be made
   * @param {Function} callback the callback to invoke when the http request is completed
   */
  request: function (opts, callback) {
    var xhttp = new XMLHttpRequest();

    xhttp.onreadystatechange = function () {
      if (this.readyState == 4) {
        if (this.status == 204) {
          //success
          return callback(null);
        } else {
          return callback(this.statusText);
        }
      }
    };

    xhttp.open(opts.method, opts.host + '/' + opts.path, true);

    for (var header in opts.headers) {
      var headerValue = opts.headers[header];
      xhttp.setRequestHeader(header, headerValue);
    }

    xhttp.send(opts.body);
  },

  /**
   * Handle an error that occurred while making a request
   * @param {Object} err an error instance to log
   * @private
   */
  handleError: function (err, callback) {
    if (callback) return callback(err);
  },

  /**
   * Generate a session ID to be returned with all of the searches made by this geocoder instance
   * ID is random and cannot be tracked across sessions
   * @private
   */
  generateSessionID: function () {
    return nanoid();
  },

  /**
   * Get a user agent string to send with the request to the events service
   * @private
   */
  getUserAgent: function () {
    return 'mapbox-gl-geocoder.' + this.version + "." + navigator.userAgent;
  },

  /**
   * Get the 0-based numeric index of the item that the user selected out of the list of options
   * @private
   * @param {Object} selected the geojson feature selected by the user
   * @param {Object} geocoder a Mapbox-GL-Geocoder instance
   * @returns {Number} the index of the selected result
   */
  getSelectedIndex: function (selected, geocoder) {
    if (!geocoder._typeahead) return;
    var results = geocoder._typeahead.data;
    var selectedID = selected.id;
    var resultIDs = results.map(function (feature) {
      return feature.id;
    });
    var selectedIdx = resultIDs.indexOf(selectedID);
    return selectedIdx;
  },

  /**
   * Check whether events should be logged
   * Clients using a localGeocoder or an origin other than mapbox should not have events logged
   * @private
   */
  shouldEnableLogging: function (options) {
    if (options.enableEventLogging === false) return false;
    if (options.origin && options.origin.indexOf('api.mapbox.com') == -1) return false; // hard to make sense of events when a local instance is suplementing results from origin

    if (options.localGeocoder) return false; // hard to make sense of events when a custom filter is in use

    if (options.filter) return false;
    return true;
  },

  /**
   * Flush out the event queue by sending events to the events service
   * @private
   */
  flush: function () {
    if (this.eventQueue.length > 0) {
      this.send(this.eventQueue);
      this.eventQueue = new Array();
    } // //reset the timer


    if (this.timer) clearTimeout(this.timer);
    if (this.flushInterval) this.timer = setTimeout(this.flush.bind(this), this.flushInterval);
  },

  /**
   * Push event into the pending queue
   * @param {Object} evt the event to send to the events service
   * @param {Boolean} forceFlush indicates that the event queue should be flushed after adding this event regardless of size of the queue
   * @private
   */
  push: function (evt, forceFlush) {
    this.eventQueue.push(evt);

    if (this.eventQueue.length >= this.maxQueueSize || forceFlush) {
      this.flush();
    }
  },

  /**
   * Flush any remaining events from the queue before it is removed
   * @private
   */
  remove: function () {
    this.flush();
  }
};
module.exports = MapboxEventManager;

/***/ }),

/***/ "./src/js/front/modules/twer-store-locator-control/exceptions.js":
/*!***********************************************************************!*\
  !*** ./src/js/front/modules/twer-store-locator-control/exceptions.js ***!
  \***********************************************************************/
/***/ (function(module) {

module.exports = {
  'fr': {
    'name': 'France',
    'bbox': [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  'us': {
    'name': 'United States',
    'bbox': [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  'ru': {
    'name': 'Russia',
    'bbox': [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  'ca': {
    'name': 'Canada',
    'bbox': [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
};

/***/ }),

/***/ "./src/js/front/modules/twer-store-locator-control/index.js":
/*!******************************************************************!*\
  !*** ./src/js/front/modules/twer-store-locator-control/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Typeahead = __webpack_require__(/*! suggestions */ "./node_modules/suggestions/index.js");

const debounce = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");

const extend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

const EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

const exceptions = __webpack_require__(/*! ./exceptions */ "./src/js/front/modules/twer-store-locator-control/exceptions.js");

const MapboxClient = __webpack_require__(/*! @mapbox/mapbox-sdk */ "./node_modules/@mapbox/mapbox-sdk/index.js");

const mbxGeocoder = __webpack_require__(/*! @mapbox/mapbox-sdk/services/geocoding */ "./node_modules/@mapbox/mapbox-sdk/services/geocoding.js");

const MapboxEventManager = __webpack_require__(/*! ./events */ "./src/js/front/modules/twer-store-locator-control/events.js");

const localization = __webpack_require__(/*! ./localization */ "./src/js/front/modules/twer-store-locator-control/localization.js");

const subtag = __webpack_require__(/*! subtag */ "./node_modules/subtag/subtag.js");

const GEOCODE_REQUEST_TYPE = {
  FORWARD: 0,
  LOCAL: 1,
  REVERSE: 2
};
const DOM = {};

DOM.create = function (tagName, className, container) {
  const el = window.document.createElement(tagName);
  if (className !== undefined) el.className = className;
  if (container) container.appendChild(el);
  return el;
};

const warnOnceHistory = {};

function warnOnce(message) {
  if (!warnOnceHistory[message]) {
    if (typeof console !== 'undefined') console.warn(message);
    warnOnceHistory[message] = true;
  }
}

function throttle(fn, time) {
  let pending = false;
  let timerId = null;

  const later = () => {
    timerId = null;

    if (pending) {
      fn();
      timerId = setTimeout(later, time);
      pending = false;
    }
  };

  return () => {
    pending = true;

    if (!timerId) {
      later();
    }

    return timerId;
  };
}

class Event {
  constructor(type) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    extend(this, data);
    this.type = type;
  }

}

class ErrorEvent extends Event {
  constructor(error) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super('error', extend({
      error
    }, data));
  }

}

function _addEventListener(type, listener, listenerList) {
  const listenerExists = listenerList[type] && listenerList[type].indexOf(listener) !== -1;

  if (!listenerExists) {
    listenerList[type] = listenerList[type] || [];
    listenerList[type].push(listener);
  }
}

let supportsGeolocation;

function checkGeolocationSupport(callback) {
  if (supportsGeolocation !== undefined) {
    callback(supportsGeolocation);
  } else if (window.navigator.permissions !== undefined) {
    window.navigator.permissions.query({
      name: 'geolocation'
    }).then(p => {
      supportsGeolocation = p.state !== 'denied';
      callback(supportsGeolocation);
    });
  } else {
    supportsGeolocation = !!window.navigator.geolocation;
    callback(supportsGeolocation);
  }
}

let numberOfWatches = 0;
let noTimeout = false;

function TwerStoreLocatorControl(options) {
  this._eventEmitter = new EventEmitter();
  this.options = extend({}, this.options, options);
  this.inputString = '';
  this.fresh = true;
  this.lastSelected = null;
}

TwerStoreLocatorControl.prototype = {
  options: {
    zoom: 16,
    flyTo: true,
    trackProximity: true,
    minLength: 2,
    reverseGeocode: false,
    limit: 5,
    origin: 'https://api.mapbox.com',
    enableEventLogging: true,
    marker: true,
    mapboxgl: null,
    collapsed: false,
    clearAndBlurOnEsc: false,
    clearOnBlur: false,
    getItemValue: function (item) {
      return item.place_name;
    },
    render: function (item) {
      var placeName = item.place_name.split(',');
      let placeDesc = placeName.splice(1, placeName.length).join(',');

      if (placeDesc.length > 0) {
        placeDesc = `, ${placeDesc}`;
      }

      return '<div class="mapboxgl-ctrl-geocoder--suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title">' + placeName[0] + placeDesc + '</div></div>';
    },
    positionOptions: {
      enableHighAccuracy: false,
      maximumAge: 0,
      timeout: 6000
    },
    fitBoundsOptions: {
      maxZoom: 15
    },
    trackUserLocation: false,
    showAccuracyCircle: true,
    showUserLocation: true,
    showUserHeading: false,
    geolocationControl: false,
    geocoderControl: false,
    radiusControl: false,
    radiusSizes: '',
    radiusDistance: '',
    radiusDefault: ''
  },
  addTo: function (container) {
    function addToExistingContainer(geocoder, container) {
      if (!document.body.contains(container)) {
        throw new Error('Element provided to #addTo() exists, but is not in the DOM');
      }

      const el = geocoder.onAdd(); //returns the input elements, which are then added to the requested html container

      container.appendChild(el);
    } // if the container is a map, add the control like normal


    if (container._controlContainer) {
      //  it's a mapbox-gl map, add like normal
      container.addControl(this);
    } // if the container is an HTMLElement, then set the parent to be that element
    else if (container instanceof HTMLElement) {
      addToExistingContainer(this, container);
    } // if the container is a string, treat it as a CSS query
    else if (typeof container == 'string') {
      const parent = document.querySelectorAll(container);

      if (parent.length === 0) {
        throw new Error('Element ', container, 'not found.');
      }

      if (parent.length > 1) {
        throw new Error('Geocoder can only be added to a single html element');
      }

      addToExistingContainer(this, parent[0]);
    } else {
      throw new Error('Error: addTo must be a mapbox-gl-js map, an html element, or a CSS selector query for a single html element');
    }
  },
  onAdd: function (map) {
    if (map && typeof map != 'string') {
      this._map = map;
    }

    this.setLanguage();

    if (!this.options.localGeocoderOnly) {
      this.geocoderService = mbxGeocoder(MapboxClient({
        accessToken: this.options.accessToken,
        origin: this.options.origin
      }));
    }

    if (this.options.localGeocoderOnly && !this.options.localGeocoder) {
      throw new Error('A localGeocoder function must be specified to use localGeocoderOnly mode');
    }

    this.eventManager = new MapboxEventManager(this.options);
    this._onChange = this._onChange.bind(this);
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onPaste = this._onPaste.bind(this);
    this._onBlur = this._onBlur.bind(this);
    this._showButton = this._showButton.bind(this);
    this._hideButton = this._hideButton.bind(this);
    this._onQueryResult = this._onQueryResult.bind(this);
    this.clear = this.clear.bind(this);
    this._updateProximity = this._updateProximity.bind(this);
    this._collapse = this._collapse.bind(this);
    this._unCollapse = this._unCollapse.bind(this);
    this._clear = this._clear.bind(this);
    this._clearOnBlur = this._clearOnBlur.bind(this); // Start Geolocation

    this._onSuccess = this._onSuccess.bind(this);
    this._onError = this._onError.bind(this);
    this._onZoom = this._onZoom.bind(this);
    this._finish = this._finish.bind(this);
    this._setupUI = this._setupUI.bind(this);
    this._updateCamera = this._updateCamera.bind(this);
    this._updateMarker = this._updateMarker.bind(this);
    this._updateMarkerRotation = this._updateMarkerRotation.bind(this);
    this._onDeviceOrientationListener = this._onDeviceOrientation.bind(this);
    this._updateMarkerRotationThrottled = throttle(this._updateMarkerRotation, 20); // End Geolocation

    let el = this.container = document.createElement('div');
    let storeLocatorClass = `twer-store-locator-geocoder--${this.options.geocoderControl} twer-store-locator-geolocation--${this.options.geolocationControl}`;
    el.className = `mapboxgl-ctrl js-twer-store-locator twer-store-locator ${storeLocatorClass}`;
    this.geocoderElement = document.createElement('div');
    this.geocoderElement.className = 'mapboxgl-ctrl-geocoder twer-store-locator__item twer-store-locator--geocoder'; // Start Geolocation

    this.geolocateElement = DOM.create('div', `mapboxgl-ctrl mapboxgl-ctrl-group twer-store-locator__item twer-store-locator--geolocate`);
    checkGeolocationSupport(this._setupUI); // End Geolocation

    this.filterElement = document.createElement('div'); //this.filterElement.type = 'button';

    this.filterElement.className = 'btn twer-store-locator-filter';
    const leftSideBtn = document.createElement('span');
    leftSideBtn.className = 'twer-store-locator-filter__left-side';
    leftSideBtn.innerText = treweler_params.i18n.filters;
    const rightSideBtn = document.createElement('span');
    rightSideBtn.className = 'twer-store-locator-filter__right-side hide';
    const filtersCounter = document.createElement('span');
    filtersCounter.className = 'twer-store-locator-filter-counter';
    filtersCounter.innerText = '0';
    const filtersClear = document.createElement('span');
    filtersClear.className = 'twer-store-locator-filter-clear';
    rightSideBtn.appendChild(filtersCounter);
    rightSideBtn.appendChild(filtersClear);
    this.filterElement.appendChild(leftSideBtn);
    this.filterElement.appendChild(rightSideBtn);
    this.radiusElement = document.createElement('div');
    this.radiusElement.className = 'twer-store-locator-radius';
    let sizes = JSON.parse(this.options.radiusSizes);

    if (sizes.length > 0) {
      this.radiusSelect = document.createElement('select');
      this.radiusSelect.id = 'js-store-locator-radius';
      let selectedFlag = false;
      const strings = JSON.parse(this.options.strings);

      if (sizes[0] === 'unlim' && sizes.length > 1) {
        sizes.push(sizes.shift());
      }

      for (let i = 0; i < sizes.length; i++) {
        let radiusOption = document.createElement('option');
        let label = sizes[i];
        let value = sizes[i];
        let distance = strings.km;

        switch (this.options.radiusDistance) {
          case 'kilometers':
            distance = strings.km;
            break;

          case 'miles':
            distance = strings.mi;
            break;
        }

        switch (label) {
          case 'unlim':
            label = strings.unlim;
            break;

          default:
            label = `${label} ${distance}`;
            value = parseInt(sizes[i]);
            break;
        }

        radiusOption.value = value;
        radiusOption.innerText = label;

        if (this.options.radiusDefault === value) {
          selectedFlag = true;
          radiusOption.setAttribute('selected', true);
        }

        this.radiusSelect.appendChild(radiusOption);
      }

      if (!selectedFlag) {
        this.radiusSelect[0].setAttribute('selected', true);
      }

      this.radiusElement.appendChild(this.radiusSelect);
    }

    let geoFieldsElement = document.createElement('div');
    geoFieldsElement.className = `twer-store-locator-geoelements`;

    if (this.options.geocoderControl) {
      geoFieldsElement.appendChild(this.geocoderElement);
    }

    if (this.options.geolocationControl) {
      geoFieldsElement.appendChild(this.geolocateElement);
    }

    var searchIcon = this.createIcon('search', '<rect x="0.5" y="0.5" width="10" height="10" rx="5" stroke="black"/>\n' + '<path d="M9.85355 9.14645L9.5 8.79289L8.79289 9.5L9.14645 9.85355L9.85355 9.14645ZM11.6464 12.3536C11.8417 12.5488 12.1583 12.5488 12.3536 12.3536C12.5488 12.1583 12.5488 11.8417 12.3536 11.6464L11.6464 12.3536ZM9.14645 9.85355L11.6464 12.3536L12.3536 11.6464L9.85355 9.14645L9.14645 9.85355Z" fill="black"/>');
    this._inputEl = document.createElement('input');
    this._inputEl.type = 'text';
    this._inputEl.className = 'mapboxgl-ctrl-geocoder--input';
    this.setPlaceholder();

    if (this.options.collapsed) {
      this._collapse();

      this.geocoderElement.addEventListener('mouseenter', this._unCollapse);
      this.geocoderElement.addEventListener('mouseleave', this._collapse);

      this._inputEl.addEventListener('focus', this._unCollapse);
    }

    if (this.options.collapsed || this.options.clearOnBlur) {
      this._inputEl.addEventListener('blur', this._onBlur);
    }

    this._inputEl.addEventListener('keydown', debounce(this._onKeyDown, 200));

    this._inputEl.addEventListener('paste', this._onPaste);

    this._inputEl.addEventListener('change', this._onChange);

    this.geocoderElement.addEventListener('mouseenter', this._showButton);
    this.geocoderElement.addEventListener('mouseleave', this._hideButton);

    this._inputEl.addEventListener('keyup', function (e) {
      this.eventManager.keyevent(e, this);
    }.bind(this));

    var actions = document.createElement('div');
    actions.classList.add('mapboxgl-ctrl-geocoder--pin-right');
    this._clearEl = document.createElement('button');

    this._clearEl.setAttribute('aria-label', 'Clear');

    this._clearEl.addEventListener('click', this.clear);

    this._clearEl.className = 'mapboxgl-ctrl-geocoder--button';
    var buttonIcon = this.createIcon('close', '<path fill-rule="evenodd" clip-rule="evenodd" d="M8.72797 0.242619C8.51496 0.0296055 8.16959 0.0296056 7.95658 0.242619L4.48533 3.71387L1.0141 0.242645C0.801083 0.0296313 0.45572 0.0296311 0.242707 0.242645C0.0296937 0.455658 0.0296937 0.801021 0.242707 1.01403L3.71394 4.48526L0.242689 7.95651C0.0296758 8.16952 0.0296758 8.51489 0.242689 8.7279C0.455702 8.94091 0.801065 8.94091 1.01408 8.7279L4.48533 5.25665L7.9566 8.72793C8.16961 8.94094 8.51497 8.94094 8.72799 8.72793C8.941 8.51491 8.941 8.16955 8.72799 7.95654L5.25671 4.48526L8.72797 1.01401C8.94098 0.800995 8.94098 0.455632 8.72797 0.242619Z" fill="currentColor"/>');

    this._clearEl.appendChild(buttonIcon);

    this._loadingEl = this.createIcon('loading', '<path fill="currentColor" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>');
    actions.appendChild(this._clearEl);
    actions.appendChild(this._loadingEl);
    this.geocoderElement.appendChild(searchIcon);
    this.geocoderElement.appendChild(this._inputEl);
    this.geocoderElement.appendChild(actions);

    if (this.options.geolocationControl || this.options.geocoderControl) {
      el.appendChild(geoFieldsElement);
    }

    if (this.options.filterControl) {
      el.appendChild(this.filterElement);
      this.filterElement.addEventListener('click', e => {
        if (e.target.classList.contains('twer-store-locator-filter-clear')) {
          e.preventDefault();
          return false;
        }

        document.getElementById('js-twer-store-locator-filters-area').classList.remove('hide');
      });
    }

    if (this.options.radiusControl && sizes.length > 0) {
      el.appendChild(this.radiusElement);
    }

    this._typeahead = new Typeahead(this._inputEl, [], {
      filter: false,
      minLength: this.options.minLength,
      limit: this.options.limit
    });
    this.setRenderFunction(this.options.render);
    this._typeahead.getItemValue = this.options.getItemValue;
    this.mapMarker = null;
    this._handleMarker = this._handleMarker.bind(this);

    if (this._map) {
      if (this.options.trackProximity) {
        this._updateProximity();

        this._map.on('moveend', this._updateProximity);
      }

      this._mapboxgl = this.options.mapboxgl;

      if (!this._mapboxgl && this.options.marker) {
        // eslint-disable-next-line no-console
        console.error('No mapboxgl detected in options. Map markers are disabled. Please set options.mapboxgl.');
        this.options.marker = false;
      }
    }

    return el;
  },
  createIcon: function (name, path) {
    let viewBox = '0 0 13 13';
    let width = 13;
    let height = 13;

    if (name === 'close' || name === 'loading') {
      viewBox = '0 0 12 12';
      width = 12;
      height = 12;
    }

    var icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    icon.setAttribute('class', 'mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-' + name);
    icon.setAttribute('viewBox', viewBox);
    icon.setAttribute('xml:space', 'preserve');
    icon.setAttribute('width', width);
    icon.setAttribute('height', height); // IE does not have innerHTML for SVG nodes

    if (!('innerHTML' in icon)) {
      var SVGNodeContainer = document.createElement('div');
      SVGNodeContainer.innerHTML = '<svg>' + path.valueOf().toString() + '</svg>';
      var SVGNode = SVGNodeContainer.firstChild,
          SVGPath = SVGNode.firstChild;
      icon.appendChild(SVGPath);
    } else {
      icon.innerHTML = path;
    }

    return icon;
  },
  onRemove: function () {
    this.geocoderElement.parentNode.removeChild(this.geocoderElement);

    if (this.options.trackProximity && this._map) {
      this._map.off('moveend', this._updateProximity);
    }

    this._removeMarker();

    if (this._geolocationWatchID !== undefined) {
      window.navigator.geolocation.clearWatch(this._geolocationWatchID);
      this._geolocationWatchID = undefined;
    }

    if (this.options.showUserLocation && this._userLocationDotMarker) {
      this._userLocationDotMarker.remove();
    }

    if (this.options.showAccuracyCircle && this._accuracyCircleMarker) {
      this._accuracyCircleMarker.remove();
    }

    this.geolocateElement.remove();

    this._map.off('zoom', this._onZoom);

    numberOfWatches = 0;
    noTimeout = false;
    this._map = null;
    return this;
  },
  // Start Geolocation
  _isOutOfMapMaxBounds: function (position) {
    const bounds = this._map.getMaxBounds();

    const coordinates = position.coords;
    return bounds && (coordinates.longitude < bounds.getWest() || coordinates.longitude > bounds.getEast() || coordinates.latitude < bounds.getSouth() || coordinates.latitude > bounds.getNorth());
  },
  _setErrorState: function () {
    switch (this._watchState) {
      case 'WAITING_ACTIVE':
        this._watchState = 'ACTIVE_ERROR';

        this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');

        this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');

        break;

      case 'ACTIVE_LOCK':
        this._watchState = 'ACTIVE_ERROR';

        this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');

        this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');

        this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');

        break;

      case 'BACKGROUND':
        this._watchState = 'BACKGROUND_ERROR';

        this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');

        this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error');

        this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');

        break;
    }
  },
  _onSuccess: function (position) {},
  _updateCamera: function (position) {},
  _updateMarker: function (position) {},
  _updateCircleRadius: function () {
    const y = this._map._containerHeight / 2;

    const a = this._map.unproject([0, y]);

    const b = this._map.unproject([100, y]);

    const metersPerPixel = a.distanceTo(b) / 100;
    const circleDiameter = Math.ceil(2 * this._accuracy / metersPerPixel);
    this._circleElement.style.width = `${circleDiameter}px`;
    this._circleElement.style.height = `${circleDiameter}px`;
  },
  _onZoom: function () {},
  _updateMarkerRotation: function () {},
  _onError: function (error) {},
  _finish: function () {},
  _setupUI: function (supported) {
    this.geolocateElement.addEventListener('contextmenu', e => e.preventDefault());
    this._geolocateButton = DOM.create('button', `mapboxgl-ctrl-geolocate`, this.geolocateElement);
    DOM.create('span', `mapboxgl-ctrl-icon`, this._geolocateButton).setAttribute('aria-hidden', true);
    this._geolocateButton.type = 'button';

    if (supported === false) {
      warnOnce('Geolocation support is not available so the TwerGeolocateControl will be disabled.');
      const title = 'TwerGeolocateControl.LocationNotAvailable';
      this._geolocateButton.disabled = true;

      this._geolocateButton.setAttribute('aria-label', title);

      if (this._geolocateButton.firstElementChild) this._geolocateButton.firstElementChild.setAttribute('title', title);
    } else {
      const title = 'FindMyLocation';

      this._geolocateButton.setAttribute('aria-label', title);

      if (this._geolocateButton.firstElementChild) this._geolocateButton.firstElementChild.setAttribute('title', title);
    }

    if ('WAITING_ACTIVE' === window.TWER_GEOLOCATE._watchState) {
      this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');

      setTimeout(() => {
        this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
      }, 1000);
    } else {
      this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
    }

    this._geolocateButton.addEventListener('click', e => {
      e.preventDefault();

      this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');

      window.TWER_GEOLOCATE._geolocateButton.click();

      setTimeout(() => {
        this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');
      }, 1000);

      switch (window.TWER_GEOLOCATE._watchState) {
        case 'OFF':
          this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');

          this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-off');

          break;

        default:
          this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-off');

          break;
      }
    });
  },
  _onDeviceOrientation: function (deviceOrientationEvent) {},
  trigger: function () {
    return true;
  },
  _addDeviceOrientationListener: function () {
    const addListener = () => {
      if ('ondeviceorientationabsolute' in window) {
        window.addEventListener('deviceorientationabsolute', this._onDeviceOrientationListener);
      } else {
        window.addEventListener('deviceorientation', this._onDeviceOrientationListener);
      }
    };

    if (typeof window.DeviceMotionEvent !== 'undefined' && typeof window.DeviceMotionEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission().then(response => {
        if (response === 'granted') {
          addListener();
        }
      }).catch(console.error);
    } else {
      addListener();
    }
  },
  _clearWatch: function () {
    window.navigator.geolocation.clearWatch(this._geolocationWatchID);
    window.removeEventListener('deviceorientation', this._onDeviceOrientationListener);
    window.removeEventListener('deviceorientationabsolute', this._onDeviceOrientationListener);
    this._geolocationWatchID = undefined;

    this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');

    this._geolocateButton.setAttribute('aria-pressed', 'false');

    if (this.options.showUserLocation) {
      this._updateMarker(null);
    }
  },
  on: function (type, fn) {
    this._eventEmitter.on(type, fn);

    return this;
  },
  off: function (type, fn) {
    this._eventEmitter.removeListener(type, fn);

    this.eventManager.remove();
    return this;
  },
  once: function (type, listener) {
    if (!listener) {
      return new Promise(resolve => this.once(type, resolve));
    }

    this._oneTimeListeners = this._oneTimeListeners || {};

    _addEventListener(type, listener, this._oneTimeListeners);

    return this;
  },
  fire: function (event, properties) {
    if (typeof event === 'string') {
      event = new Event(event, properties || {});
    }

    const type = event.type;

    if (this.listens(type)) {
      event.target = this;
      const listeners = this._listeners && this._listeners[type] ? this._listeners[type].slice() : [];

      for (const listener of listeners) {
        listener.call(this, event);
      }

      const oneTimeListeners = this._oneTimeListeners && this._oneTimeListeners[type] ? this._oneTimeListeners[type].slice() : [];

      for (const listener of oneTimeListeners) {
        _removeEventListener(type, listener, this._oneTimeListeners);

        listener.call(this, event);
      }

      const parent = this._eventedParent;

      if (parent) {
        extend(event, typeof this._eventedParentData === 'function' ? this._eventedParentData() : this._eventedParentData);
        parent.fire(event);
      }
    } else if (event instanceof ErrorEvent) {
      console.error(event.error);
    }

    return this;
  },
  listens: function (type) {
    return !!(this._listeners && this._listeners[type] && this._listeners[type].length > 0 || this._oneTimeListeners && this._oneTimeListeners[type] && this._oneTimeListeners[type].length > 0 || this._eventedParent && this._eventedParent.listens(type));
  },
  setEventedParent: function (parent, data) {
    this._eventedParent = parent;
    this._eventedParentData = data;
    return this;
  },
  // End Geolocation
  _onPaste: function (e) {
    var value = (e.clipboardData || window.clipboardData).getData('text');

    if (value.length >= this.options.minLength) {
      this._geocode(value);
    }
  },
  _onKeyDown: function (e) {
    var ESC_KEY_CODE = 27,
        TAB_KEY_CODE = 9;

    if (e.keyCode === ESC_KEY_CODE && this.options.clearAndBlurOnEsc) {
      this._clear(e);

      return this._inputEl.blur();
    } // if target has shadowRoot, then get the actual active element inside the shadowRoot


    var target = e.target && e.target.shadowRoot ? e.target.shadowRoot.activeElement : e.target;
    var value = target ? target.value : '';

    if (!value) {
      this.fresh = true; // the user has removed all the text

      if (e.keyCode !== TAB_KEY_CODE) this.clear(e);
      return this._clearEl.style.display = 'none';
    } // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN


    if (e.metaKey || [TAB_KEY_CODE, ESC_KEY_CODE, 37, 39, 13, 38, 40].indexOf(e.keyCode) !== -1) return;

    if (target.value.length >= this.options.minLength) {
      this._geocode(target.value);
    }
  },
  _showButton: function () {
    if (this._typeahead.selected) this._clearEl.style.display = 'block';
  },
  _hideButton: function () {
    if (this._typeahead.selected) this._clearEl.style.display = 'none';
  },
  _onBlur: function (e) {
    if (this.options.clearOnBlur) {
      this._clearOnBlur(e);
    }

    if (this.options.collapsed) {
      this._collapse();
    }
  },
  _onChange: function () {
    var selected = this._typeahead.selected;

    if (selected && JSON.stringify(selected) !== this.lastSelected) {
      this._clearEl.style.display = 'none';

      if (this.options.flyTo) {
        var flyOptions;

        if (selected.properties && exceptions[selected.properties.short_code]) {
          // Certain geocoder search results return (and therefore zoom to fit)
          // an unexpectedly large bounding box: for example, both Russia and the
          // USA span both sides of -180/180, or France includes the island of
          // Reunion in the Indian Ocean. An incomplete list of these exceptions
          // at ./exceptions.json provides "reasonable" bounding boxes as a
          // short-term solution; this may be amended as necessary.
          flyOptions = extend({}, this.options.flyTo);

          if (selected.center) {
            flyOptions.center = selected.center;
          } else if (selected.geometry && selected.geometry.type && selected.geometry.type === 'Point' && selected.geometry.coordinates) {
            flyOptions.center = selected.geometry.coordinates;
          }

          if (this._map) {
            this._map.fitBounds(exceptions[selected.properties.short_code].bbox, flyOptions);
          }
        } else if (selected.bbox) {
          var bbox = selected.bbox;
          flyOptions = extend({}, this.options.flyTo);

          if (selected.center) {
            flyOptions.center = selected.center;
          } else if (selected.geometry && selected.geometry.type && selected.geometry.type === 'Point' && selected.geometry.coordinates) {
            flyOptions.center = selected.geometry.coordinates;
          }

          if (this._map) {
            this._map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], flyOptions);
          }
        } else {
          var defaultFlyOptions = {
            zoom: this.options.zoom
          };
          flyOptions = extend({}, defaultFlyOptions, this.options.flyTo); //  ensure that center is not overriden by custom options

          if (selected.center) {
            flyOptions.center = selected.center;
          } else if (selected.geometry && selected.geometry.type && selected.geometry.type === 'Point' && selected.geometry.coordinates) {
            flyOptions.center = selected.geometry.coordinates;
          }

          if (this._map) {
            this._map.flyTo(flyOptions);
          }
        }
      }

      if (this.options.marker && this._mapboxgl) {
        this._handleMarker(selected);
      } // After selecting a feature, re-focus the textarea and set
      // cursor at start.


      this._inputEl.focus();

      this._inputEl.scrollLeft = 0;

      this._inputEl.setSelectionRange(0, 0);

      this.lastSelected = JSON.stringify(selected);

      this._eventEmitter.emit('result', {
        result: selected
      });

      this.eventManager.select(selected, this);
    }
  },
  _requestType: function (options, search) {
    var type;
    const reverseGeocodeCoordRgx = /^[ ]*(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/;

    if (options.localGeocoderOnly) {
      type = GEOCODE_REQUEST_TYPE.LOCAL;
    } else if (options.reverseGeocode && reverseGeocodeCoordRgx.test(search)) {
      type = GEOCODE_REQUEST_TYPE.REVERSE;
    } else {
      type = GEOCODE_REQUEST_TYPE.FORWARD;
    }

    return type;
  },
  _setupConfig: function (requestType, search) {
    // Possible config properties to pass to client
    const keys = ['bbox', 'limit', 'proximity', 'countries', 'types', 'language', 'reverseMode', 'mode', 'autocomplete', 'fuzzyMatch', 'routing', 'worldview'];
    const spacesOrCommaRgx = /[\s,]+/;
    var self = this;
    var config = keys.reduce(function (config, key) {
      // don't include undefined/null params, but allow boolean, among other, values
      if (self.options[key] === undefined || self.options[key] === null) {
        return config;
      } // countries, types, and language need to be passed in as arrays to client
      // https://github.com/mapbox/mapbox-sdk-js/blob/master/services/geocoding.js#L38-L47


      ['countries', 'types', 'language'].indexOf(key) > -1 ? config[key] = self.options[key].split(spacesOrCommaRgx) : config[key] = self.options[key];
      const isCoordKey = typeof self.options[key].longitude === 'number' && typeof self.options[key].latitude === 'number';

      if (key === 'proximity' && isCoordKey) {
        const lng = self.options[key].longitude;
        const lat = self.options[key].latitude;
        config[key] = [lng, lat];
      }

      return config;
    }, {});

    switch (requestType) {
      case GEOCODE_REQUEST_TYPE.REVERSE:
        {
          var coords = search.split(spacesOrCommaRgx).map(function (c) {
            return parseFloat(c, 10);
          }).reverse(); // client only accepts one type for reverseGeocode, so
          // use first config type if one, if not default to poi

          config.types ? [config.types[0]] : ['poi'];
          config = extend(config, {
            query: coords,
            limit: 1
          }); // Remove config options not supported by the reverseGeocoder

          ['proximity', 'autocomplete', 'fuzzyMatch', 'bbox'].forEach(function (key) {
            if (key in config) {
              delete config[key];
            }
          });
        }
        break;

      case GEOCODE_REQUEST_TYPE.FORWARD:
        {
          // Ensure that any reverse geocoding looking request is cleaned up
          // to be processed as only a forward geocoding request by the server.
          const reverseGeocodeCoordRgx = /^[ ]*(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)*[ ]*$/;

          if (reverseGeocodeCoordRgx.test(search)) {
            search = search.replace(/,/g, ' ');
          }

          config = extend(config, {
            query: search
          });
        }
        break;
    }

    return config;
  },
  _geocode: function (searchInput) {
    this.inputString = searchInput;
    this._loadingEl.style.display = 'block';

    this._eventEmitter.emit('loading', {
      query: searchInput
    });

    const requestType = this._requestType(this.options, searchInput);

    const config = this._setupConfig(requestType, searchInput);

    var request;

    switch (requestType) {
      case GEOCODE_REQUEST_TYPE.LOCAL:
        request = Promise.resolve();
        break;

      case GEOCODE_REQUEST_TYPE.FORWARD:
        request = this.geocoderService.forwardGeocode(config).send();
        break;

      case GEOCODE_REQUEST_TYPE.REVERSE:
        request = this.geocoderService.reverseGeocode(config).send();
        break;
    }

    var localGeocoderRes = this.options.localGeocoder ? this.options.localGeocoder(searchInput) || [] : [];
    var externalGeocoderRes = [];
    var geocoderError = null;
    request.catch(function (error) {
      geocoderError = error;
    }.bind(this)).then(function (response) {
      this._loadingEl.style.display = 'none';
      var res = {};

      if (!response) {
        res = {
          type: 'FeatureCollection',
          features: []
        };
      } else if (response.statusCode == '200') {
        res = response.body;
        res.request = response.request;
        res.headers = response.headers;
      }

      res.config = config;

      if (this.fresh) {
        this.eventManager.start(this);
        this.fresh = false;
      } // supplement Mapbox Geocoding API results with locally populated results


      res.features = res.features ? localGeocoderRes.concat(res.features) : localGeocoderRes;

      if (this.options.externalGeocoder) {
        externalGeocoderRes = this.options.externalGeocoder(searchInput, res.features) || []; // supplement Mapbox Geocoding API results with features returned by a promise

        return externalGeocoderRes.then(function (features) {
          res.features = res.features ? features.concat(res.features) : features;
          return res;
        }, function () {
          // on error, display the original result
          return res;
        });
      }

      return res;
    }.bind(this)).then(function (res) {
      if (geocoderError) {
        throw geocoderError;
      } // apply results filter if provided


      if (this.options.filter && res.features.length) {
        res.features = res.features.filter(this.options.filter);
      }

      if (res.features.length) {
        this._clearEl.style.display = 'block';

        this._eventEmitter.emit('results', res);

        this._typeahead.update(res.features);
      } else {
        this._clearEl.style.display = 'none';
        this._typeahead.selected = null;

        this._renderNoResults();

        this._eventEmitter.emit('results', res);
      }
    }.bind(this)).catch(function (err) {
      this._loadingEl.style.display = 'none'; // in the event of an error in the Mapbox Geocoding API still display results from the localGeocoder

      if (localGeocoderRes.length && this.options.localGeocoder || externalGeocoderRes.length && this.options.externalGeocoder) {
        this._clearEl.style.display = 'block';

        this._typeahead.update(localGeocoderRes);
      } else {
        this._clearEl.style.display = 'none';
        this._typeahead.selected = null;

        this._renderError();
      }

      this._eventEmitter.emit('results', {
        features: localGeocoderRes
      });

      this._eventEmitter.emit('error', {
        error: err
      });
    }.bind(this));
    return request;
  },
  _clear: function (ev) {
    if (ev) ev.preventDefault();
    this._inputEl.value = '';
    this._typeahead.selected = null;

    this._typeahead.clear();

    this._onChange();

    this._clearEl.style.display = 'none';

    this._removeMarker();

    this.lastSelected = null;

    this._eventEmitter.emit('clear');

    this.fresh = true;
  },
  clear: function (ev) {
    this._clear(ev);

    this._inputEl.focus();
  },

  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param {Event} [ev] the blur event
   * @private
   */
  _clearOnBlur: function (ev) {
    var ctx = this;
    /*
     * If relatedTarget is not found, assume user targeted the suggestions list.
     * In that case, do not clear on blur. There are other edge cases where
     * ev.relatedTarget could be null. Clicking on list always results in null
     * relatedtarget because of upstream behavior in `suggestions`.
     *
     * The ideal solution would be to check if ev.relatedTarget is a child of
     * the list. See issue #258 for details on why we can't do that yet.
     */

    if (ev.relatedTarget) {
      ctx._clear(ev);
    }
  },
  _onQueryResult: function (response) {
    var results = response.body;
    if (!results.features.length) return;
    var result = results.features[0];
    this._typeahead.selected = result;
    this._inputEl.value = result.place_name;

    this._onChange();
  },
  _updateProximity: function () {
    // proximity is designed for local scale, if the user is looking at the whole world,
    // it doesn't make sense to factor in the arbitrary centre of the map
    if (!this._map) {
      return;
    }

    if (this._map.getZoom() > 9) {
      var center = this._map.getCenter().wrap();

      this.setProximity({
        longitude: center.lng,
        latitude: center.lat
      });
    } else {
      this.setProximity(null);
    }
  },
  _collapse: function () {
    // do not collapse if input is in focus
    if (!this._inputEl.value && this._inputEl !== document.activeElement) this.geocoderElement.classList.add('mapboxgl-ctrl-geocoder--collapsed');
  },
  _unCollapse: function () {
    this.geocoderElement.classList.remove('mapboxgl-ctrl-geocoder--collapsed');
  },

  /**
   * Set & query the input
   * @param {string} searchInput location name or other search input
   * @returns {TwerStoreLocatorControl} this
   */
  query: function (searchInput) {
    this._geocode(searchInput).then(this._onQueryResult);

    return this;
  },
  _renderError: function () {
    var errorMessage = '<div class=\'mapbox-gl-geocoder--error\'>There was an error reaching the server</div>';

    this._renderMessage(errorMessage);
  },
  _renderNoResults: function () {
    var errorMessage = '<div class=\'mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results\'>No results found</div>';

    this._renderMessage(errorMessage);
  },
  _renderMessage: function (msg) {
    this._typeahead.update([]);

    this._typeahead.selected = null;

    this._typeahead.clear();

    this._typeahead.renderError(msg);
  },

  /**
   * Get the text to use as the search bar placeholder
   *
   * If placeholder is provided in options, then use options.placeholder
   * Otherwise, if language is provided in options, then use the localized string of the first language if available
   * Otherwise use the default
   *
   * @returns {String} the value to use as the search bar placeholder
   * @private
   */
  _getPlaceholderText: function () {
    if (this.options.placeholder) return this.options.placeholder;

    if (this.options.language) {
      var firstLanguage = this.options.language.split(',')[0];
      var language = subtag.language(firstLanguage);
      var localizedValue = localization.placeholder[language];
      if (localizedValue) return localizedValue;
    }

    return 'Search';
  },

  /**
   * Set input
   * @param {string} searchInput location name or other search input
   * @returns {TwerStoreLocatorControl} this
   */
  setInput: function (searchInput) {
    // Set input value to passed value and clear everything else.
    this._inputEl.value = searchInput;
    this._typeahead.selected = null;

    this._typeahead.clear();

    if (searchInput.length >= this.options.minLength) {
      this._geocode(searchInput);
    }

    return this;
  },

  /**
   * Set proximity
   * @param {Object} proximity The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   * @returns {TwerStoreLocatorControl} this
   */
  setProximity: function (proximity) {
    this.options.proximity = proximity;
    return this;
  },

  /**
   * Get proximity
   * @returns {Object} The geocoder proximity
   */
  getProximity: function () {
    return this.options.proximity;
  },

  /**
   * Set the render function used in the results dropdown
   * @param {Function} fn The function to use as a render function. This function accepts a single [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) object as input and returns a string.
   * @returns {TwerStoreLocatorControl} this
   */
  setRenderFunction: function (fn) {
    if (fn && typeof fn == 'function') {
      this._typeahead.render = fn;
    }

    return this;
  },

  /**
   * Get the function used to render the results dropdown
   *
   * @returns {Function} the render function
   */
  getRenderFunction: function () {
    return this._typeahead.render;
  },

  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param {String} language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   * @returns {TwerStoreLocatorControl} this
   */
  setLanguage: function (language) {
    var browserLocale = navigator.language || navigator.userLanguage || navigator.browserLanguage;
    this.options.language = language || this.options.language || browserLocale;
    return this;
  },

  /**
   * Get the language to use in UI elements and when making search requests
   * @returns {String} The language(s) used by the plugin, if any
   */
  getLanguage: function () {
    return this.options.language;
  },

  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns {Number} the map zoom
   */
  getZoom: function () {
    return this.options.zoom;
  },

  /**
   * Set the zoom level
   * @param {Number} zoom The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns {TwerStoreLocatorControl} this
   */
  setZoom: function (zoom) {
    this.options.zoom = zoom;
    return this;
  },

  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns {Boolean|Object} The `flyTo` option
   */
  getFlyTo: function () {
    return this.options.flyTo;
  },

  /**
   * Set the flyTo options
   * @param {Boolean|Object} flyTo If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://docs.mapbox.com/mapbox-gl-js/api/#map#flyto) or [`fitBounds`](https://docs.mapbox.com/mapbox-gl-js/api/#map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo: function (flyTo) {
    this.options.flyTo = flyTo;
    return this;
  },

  /**
   * Get the value of the placeholder string
   * @returns {String} The input element's placeholder value
   */
  getPlaceholder: function () {
    return this.options.placeholder;
  },

  /**
   * Set the value of the input element's placeholder
   * @param {String} placeholder the text to use as the input element's placeholder
   * @returns {TwerStoreLocatorControl} this
   */
  setPlaceholder: function (placeholder) {
    this.placeholder = placeholder ? placeholder : this._getPlaceholderText();
    this._inputEl.placeholder = this.placeholder;

    this._inputEl.setAttribute('aria-label', this.placeholder);

    return this;
  },

  /**
   * Get the bounding box used by the plugin
   * @returns {Array<Number>} the bounding box, if any
   */
  getBbox: function () {
    return this.options.bbox;
  },

  /**
   * Set the bounding box to limit search results to
   * @param {Array<Number>} bbox a bounding box given as an array in the format [minX, minY, maxX, maxY].
   * @returns {TwerStoreLocatorControl} this
   */
  setBbox: function (bbox) {
    this.options.bbox = bbox;
    return this;
  },

  /**
   * Get a list of the countries to limit search results to
   * @returns {String} a comma separated list of countries to limit to, if any
   */
  getCountries: function () {
    return this.options.countries;
  },

  /**
   * Set the countries to limit search results to
   * @param {String} countries a comma separated list of countries to limit to
   * @returns {TwerStoreLocatorControl} this
   */
  setCountries: function (countries) {
    this.options.countries = countries;
    return this;
  },

  /**
   * Get a list of the types to limit search results to
   * @returns {String} a comma separated list of types to limit to
   */
  getTypes: function () {
    return this.options.types;
  },

  /**
   * Set the types to limit search results to
   * @param {String} countries a comma separated list of types to limit to
   * @returns {TwerStoreLocatorControl} this
   */
  setTypes: function (types) {
    this.options.types = types;
    return this;
  },

  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns {Number} The minimum length in characters before a search is triggered
   */
  getMinLength: function () {
    return this.options.minLength;
  },

  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param {Number} minLength the minimum length in characters
   * @returns {TwerStoreLocatorControl} this
   */
  setMinLength: function (minLength) {
    this.options.minLength = minLength;
    if (this._typeahead) this._typeahead.options.minLength = minLength;
    return this;
  },

  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns {Number} The limit value for the number of results to display used by the plugin
   */
  getLimit: function () {
    return this.options.limit;
  },

  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param {Number} limit the number of search results to return
   * @returns {TwerStoreLocatorControl}
   */
  setLimit: function (limit) {
    this.options.limit = limit;
    if (this._typeahead) this._typeahead.options.limit = limit;
    return this;
  },

  /**
   * Get the filter function used by the plugin
   * @returns {Function} the filter function
   */
  getFilter: function () {
    return this.options.filter;
  },

  /**
   * Set the filter function used by the plugin.
   * @param {Function} filter A function which accepts a Feature in the [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   * @returns {TwerStoreLocatorControl} this
   */
  setFilter: function (filter) {
    this.options.filter = filter;
    return this;
  },

  /**
   * Set the geocoding endpoint used by the plugin.
   * @param {Function} origin A function which accepts an HTTPS URL to specify the endpoint to query results from.
   * @returns {TwerStoreLocatorControl} this
   */
  setOrigin: function (origin) {
    this.options.origin = origin;
    this.geocoderService = mbxGeocoder(MapboxClient({
      accessToken: this.options.accessToken,
      origin: this.options.origin
    }));
    return this;
  },

  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns {Function} the endpoint URL
   */
  getOrigin: function () {
    return this.options.origin;
  },

  /**
   * Set the autocomplete option used for geocoding requests
   * @param {Boolean} value The boolean value to set autocomplete to
   * @returns
   */
  setAutocomplete: function (value) {
    this.options.autocomplete = value;
    return this;
  },

  /**
   * Get the current autocomplete parameter value used for requests
   * @returns {Boolean} The autocomplete parameter value
   */
  getAutocomplete: function () {
    return this.options.autocomplete;
  },

  /**
   * Set the fuzzyMatch option used for approximate matching in geocoding requests
   * @param {Boolean} value The boolean value to set fuzzyMatch to
   * @returns
   */
  setFuzzyMatch: function (value) {
    this.options.fuzzyMatch = value;
    return this;
  },

  /**
   * Get the current fuzzyMatch parameter value used for requests
   * @returns {Boolean} The fuzzyMatch parameter value
   */
  getFuzzyMatch: function () {
    return this.options.fuzzyMatch;
  },

  /**
   * Set the routing parameter used to ask for routable point metadata in geocoding requests
   * @param {Boolean} value The boolean value to set routing to
   * @returns
   */
  setRouting: function (value) {
    this.options.routing = value;
    return this;
  },

  /**
   * Get the current routing parameter value used for requests
   * @returns {Boolean} The routing parameter value
   */
  getRouting: function () {
    return this.options.routing;
  },

  /**
   * Set the worldview parameter
   * @param {String} code The country code representing the worldview (e.g. "us" | "cn" | "jp", "in")
   * @returns
   */
  setWorldview: function (code) {
    this.options.worldview = code;
    return this;
  },

  /**
   * Get the current worldview parameter value used for requests
   * @returns {String} The worldview parameter value
   */
  getWorldview: function () {
    return this.options.worldview;
  },

  /**
   * Handle the placement of a result marking the selected result
   * @private
   * @param {Object} selected the selected geojson feature
   * @returns {TwerStoreLocatorControl} this
   */
  _handleMarker: function (selected) {
    // clean up any old marker that might be present
    if (!this._map) {
      return;
    }

    this._removeMarker();

    var defaultMarkerOptions = {
      color: '#4668f2'
    };
    var markerOptions = extend({}, defaultMarkerOptions, this.options.marker);
    this.mapMarker = new this._mapboxgl.Marker(markerOptions);

    if (selected.center) {
      this.mapMarker.setLngLat(selected.center).addTo(this._map);
    } else if (selected.geometry && selected.geometry.type && selected.geometry.type === 'Point' && selected.geometry.coordinates) {
      this.mapMarker.setLngLat(selected.geometry.coordinates).addTo(this._map);
    }

    return this;
  },

  /**
   * Handle the removal of a result marker
   * @private
   */
  _removeMarker: function () {
    if (this.mapMarker) {
      this.mapMarker.remove();
      this.mapMarker = null;
    }
  }
};
module.exports = TwerStoreLocatorControl;

/***/ }),

/***/ "./src/js/front/modules/twer-store-locator-control/localization.js":
/*!*************************************************************************!*\
  !*** ./src/js/front/modules/twer-store-locator-control/localization.js ***!
  \*************************************************************************/
/***/ (function(module) {

"use strict";

/**
 * Localized values for the placeholder string
 * 
 * @private
 */

var placeholder = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  'de': 'Suche',
  // german
  'it': 'Ricerca',
  //italian
  'en': 'Search',
  // english
  'nl': 'Zoeken',
  //dutch
  'fr': 'Chercher',
  //french
  'ca': 'Cerca',
  //catalan
  'he': 'לחפש',
  //hebrew
  'ja': 'サーチ',
  //japanese
  'lv': 'Meklēt',
  //latvian
  'pt': 'Procurar',
  //portuguese 
  'sr': 'Претрага',
  //serbian
  'zh': '搜索',
  //chinese-simplified
  'cs': 'Vyhledávání',
  //czech
  'hu': 'Keresés',
  //hungarian
  'ka': 'ძიება',
  // georgian
  'nb': 'Søke',
  //norwegian
  'sk': 'Vyhľadávanie',
  //slovak
  'th': 'ค้นหา',
  //thai
  'fi': 'Hae',
  //finnish
  'is': 'Leita',
  //icelandic
  'ko': '수색',
  //korean
  'pl': 'Szukaj',
  //polish
  'sl': 'Iskanje',
  //slovenian
  'fa': 'جستجو',
  //persian(aka farsi)
  'ru': 'Поиск' //russian

};
module.exports = {
  placeholder: placeholder
};

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module) {

"use strict";
module.exports = jQuery;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _defineProperty; }
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@turf/bbox/dist/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/bbox/dist/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/dist/es/index.js");

/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {GeoJSON} geojson any GeoJSON object
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */

function bbox(geojson) {
  var result = [Infinity, Infinity, -Infinity, -Infinity];
  (0,_turf_meta__WEBPACK_IMPORTED_MODULE_0__.coordEach)(geojson, function (coord) {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }

    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }

    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }

    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}

bbox["default"] = bbox;
/* harmony default export */ __webpack_exports__["default"] = (bbox);

/***/ }),

/***/ "./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ booleanPointInPolygon; }
/* harmony export */ });
/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/dist/es/index.js");
 // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
 * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
 *
 * @name booleanPointInPolygon
 * @param {Coord} point input point
 * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
 * the point is inside the polygon otherwise false.
 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt = turf.point([-77, 44]);
 * var poly = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]]);
 *
 * turf.booleanPointInPolygon(pt, poly);
 * //= true
 */

function booleanPointInPolygon(point, polygon, options) {
  if (options === void 0) {
    options = {};
  } // validation


  if (!point) {
    throw new Error("point is required");
  }

  if (!polygon) {
    throw new Error("polygon is required");
  }

  var pt = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getCoord)(point);
  var geom = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getGeom)(polygon);
  var type = geom.type;
  var bbox = polygon.bbox;
  var polys = geom.coordinates; // Quick elimination if point is not inside bbox

  if (bbox && inBBox(pt, bbox) === false) {
    return false;
  } // normalize to multipolygon


  if (type === "Polygon") {
    polys = [polys];
  }

  var insidePoly = false;

  for (var i = 0; i < polys.length && !insidePoly; i++) {
    // check if it is in the outer ring first
    if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
      var inHole = false;
      var k = 1; // check for the point in any of the holes

      while (k < polys[i].length && !inHole) {
        if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
          inHole = true;
        }

        k++;
      }

      if (!inHole) {
        insidePoly = true;
      }
    }
  }

  return insidePoly;
}
/**
 * inRing
 *
 * @private
 * @param {Array<number>} pt [x,y]
 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
 * @param {boolean} ignoreBoundary ignoreBoundary
 * @returns {boolean} inRing
 */

function inRing(pt, ring, ignoreBoundary) {
  var isInside = false;

  if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
    ring = ring.slice(0, ring.length - 1);
  }

  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    var xi = ring[i][0];
    var yi = ring[i][1];
    var xj = ring[j][0];
    var yj = ring[j][1];
    var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;

    if (onBoundary) {
      return !ignoreBoundary;
    }

    var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;

    if (intersect) {
      isInside = !isInside;
    }
  }

  return isInside;
}
/**
 * inBBox
 *
 * @private
 * @param {Position} pt point [x,y]
 * @param {BBox} bbox BBox [west, south, east, north]
 * @returns {boolean} true/false if point is inside BBox
 */


function inBBox(pt, bbox) {
  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}

/***/ }),

/***/ "./node_modules/@turf/buffer/dist/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@turf/buffer/dist/es/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _turf_center__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/center */ "./node_modules/@turf/center/dist/es/index.js");
/* harmony import */ var turf_jsts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! turf-jsts */ "./node_modules/turf-jsts/jsts.min.js");
/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/dist/es/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");





/**
 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
 *
 * When using a negative radius, the resulting geometry may be invalid if
 * it's too small compared to the radius magnitude. If the input is a
 * FeatureCollection, only valid members will be returned in the output
 * FeatureCollection - i.e., the output collection may have fewer members than
 * the input, or even be empty.
 *
 * @name buffer
 * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered
 * @param {number} radius distance to draw the buffer (negative values are allowed)
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units="kilometers"] any of the options supported by turf units
 * @param {number} [options.steps=8] number of steps
 * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features
 * @example
 * var point = turf.point([-90.548630, 14.616599]);
 * var buffered = turf.buffer(point, 500, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [point, buffered]
 */

function buffer(geojson, radius, options) {
  // Optional params
  options = options || {}; // use user supplied options or default values

  var units = options.units || "kilometers";
  var steps = options.steps || 8; // validation

  if (!geojson) throw new Error("geojson is required");
  if (typeof options !== "object") throw new Error("options must be an object");
  if (typeof steps !== "number") throw new Error("steps must be an number"); // Allow negative buffers ("erosion") or zero-sized buffers ("repair geometry")

  if (radius === undefined) throw new Error("radius is required");
  if (steps <= 0) throw new Error("steps must be greater than 0");
  var results = [];

  switch (geojson.type) {
    case "GeometryCollection":
      (0,_turf_meta__WEBPACK_IMPORTED_MODULE_2__.geomEach)(geojson, function (geometry) {
        var buffered = bufferFeature(geometry, radius, units, steps);
        if (buffered) results.push(buffered);
      });
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.featureCollection)(results);

    case "FeatureCollection":
      (0,_turf_meta__WEBPACK_IMPORTED_MODULE_2__.featureEach)(geojson, function (feature) {
        var multiBuffered = bufferFeature(feature, radius, units, steps);

        if (multiBuffered) {
          (0,_turf_meta__WEBPACK_IMPORTED_MODULE_2__.featureEach)(multiBuffered, function (buffered) {
            if (buffered) results.push(buffered);
          });
        }
      });
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.featureCollection)(results);
  }

  return bufferFeature(geojson, radius, units, steps);
}
/**
 * Buffer single Feature/Geometry
 *
 * @private
 * @param {Feature<any>} geojson input to be buffered
 * @param {number} radius distance to draw the buffer
 * @param {string} [units='kilometers'] any of the options supported by turf units
 * @param {number} [steps=8] number of steps
 * @returns {Feature<Polygon|MultiPolygon>} buffered feature
 */


function bufferFeature(geojson, radius, units, steps) {
  var properties = geojson.properties || {};
  var geometry = geojson.type === "Feature" ? geojson.geometry : geojson; // Geometry Types faster than jsts

  if (geometry.type === "GeometryCollection") {
    var results = [];
    (0,_turf_meta__WEBPACK_IMPORTED_MODULE_2__.geomEach)(geojson, function (geometry) {
      var buffered = bufferFeature(geometry, radius, units, steps);
      if (buffered) results.push(buffered);
    });
    return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.featureCollection)(results);
  } // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)


  var projection = defineProjection(geometry);
  var projected = {
    type: geometry.type,
    coordinates: projectCoords(geometry.coordinates, projection)
  }; // JSTS buffer operation

  var reader = new turf_jsts__WEBPACK_IMPORTED_MODULE_1__.GeoJSONReader();
  var geom = reader.read(projected);
  var distance = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.radiansToLength)((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.lengthToRadians)(radius, units), "meters");
  var buffered = turf_jsts__WEBPACK_IMPORTED_MODULE_1__.BufferOp.bufferOp(geom, distance, steps);
  var writer = new turf_jsts__WEBPACK_IMPORTED_MODULE_1__.GeoJSONWriter();
  buffered = writer.write(buffered); // Detect if empty geometries

  if (coordsIsNaN(buffered.coordinates)) return undefined; // Unproject coordinates (convert to Degrees)

  var result = {
    type: buffered.type,
    coordinates: unprojectCoords(buffered.coordinates, projection)
  };
  return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.feature)(result, properties);
}
/**
 * Coordinates isNaN
 *
 * @private
 * @param {Array<any>} coords GeoJSON Coordinates
 * @returns {boolean} if NaN exists
 */


function coordsIsNaN(coords) {
  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
  return isNaN(coords[0]);
}
/**
 * Project coordinates to projection
 *
 * @private
 * @param {Array<any>} coords to project
 * @param {GeoProjection} proj D3 Geo Projection
 * @returns {Array<any>} projected coordinates
 */


function projectCoords(coords, proj) {
  if (typeof coords[0] !== "object") return proj(coords);
  return coords.map(function (coord) {
    return projectCoords(coord, proj);
  });
}
/**
 * Un-Project coordinates to projection
 *
 * @private
 * @param {Array<any>} coords to un-project
 * @param {GeoProjection} proj D3 Geo Projection
 * @returns {Array<any>} un-projected coordinates
 */


function unprojectCoords(coords, proj) {
  if (typeof coords[0] !== "object") return proj.invert(coords);
  return coords.map(function (coord) {
    return unprojectCoords(coord, proj);
  });
}
/**
 * Define Azimuthal Equidistant projection
 *
 * @private
 * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON
 * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection
 */


function defineProjection(geojson) {
  var coords = (0,_turf_center__WEBPACK_IMPORTED_MODULE_0__["default"])(geojson).geometry.coordinates;
  var rotation = [-coords[0], -coords[1]];
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_3__.geoAzimuthalEquidistant)().rotate(rotation).scale(_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.earthRadius);
}

/* harmony default export */ __webpack_exports__["default"] = (buffer);

/***/ }),

/***/ "./node_modules/@turf/center/dist/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@turf/center/dist/es/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _turf_bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/bbox */ "./node_modules/@turf/bbox/dist/es/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");


/**
 * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
 *
 * @name center
 * @param {GeoJSON} geojson GeoJSON to be centered
 * @param {Object} [options={}] Optional parameters
 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point
 * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point
 * @param {Object} [options.id={}] Translate GeoJSON Id to Point
 * @returns {Feature<Point>} a Point feature at the absolute center point of all input features
 * @example
 * var features = turf.points([
 *   [-97.522259, 35.4691],
 *   [-97.502754, 35.463455],
 *   [-97.508269, 35.463245]
 * ]);
 *
 * var center = turf.center(features);
 *
 * //addToMap
 * var addToMap = [features, center]
 * center.properties['marker-size'] = 'large';
 * center.properties['marker-color'] = '#000';
 */

function center(geojson, options) {
  if (options === void 0) {
    options = {};
  }

  var ext = (0,_turf_bbox__WEBPACK_IMPORTED_MODULE_0__["default"])(geojson);
  var x = (ext[0] + ext[2]) / 2;
  var y = (ext[1] + ext[3]) / 2;
  return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.point)([x, y], options.properties, options);
}

/* harmony default export */ __webpack_exports__["default"] = (center);

/***/ }),

/***/ "./node_modules/@turf/distance/dist/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@turf/distance/dist/es/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/dist/es/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");

 //http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord | Point} from origin point or coordinate
 * @param {Coord | Point} to destination point or coordinate
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */

function distance(from, to, options) {
  if (options === void 0) {
    options = {};
  }

  var coordinates1 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getCoord)(from);
  var coordinates2 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getCoord)(to);
  var dLat = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[1] - coordinates1[1]);
  var dLon = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[0] - coordinates1[0]);
  var lat1 = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates1[1]);
  var lat2 = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.radiansToLength)(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}

/* harmony default export */ __webpack_exports__["default"] = (distance);

/***/ }),

/***/ "./node_modules/@turf/helpers/dist/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@turf/helpers/dist/es/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areaFactors": function() { return /* binding */ areaFactors; },
/* harmony export */   "bearingToAzimuth": function() { return /* binding */ bearingToAzimuth; },
/* harmony export */   "convertArea": function() { return /* binding */ convertArea; },
/* harmony export */   "convertLength": function() { return /* binding */ convertLength; },
/* harmony export */   "degreesToRadians": function() { return /* binding */ degreesToRadians; },
/* harmony export */   "earthRadius": function() { return /* binding */ earthRadius; },
/* harmony export */   "factors": function() { return /* binding */ factors; },
/* harmony export */   "feature": function() { return /* binding */ feature; },
/* harmony export */   "featureCollection": function() { return /* binding */ featureCollection; },
/* harmony export */   "geometry": function() { return /* binding */ geometry; },
/* harmony export */   "geometryCollection": function() { return /* binding */ geometryCollection; },
/* harmony export */   "isNumber": function() { return /* binding */ isNumber; },
/* harmony export */   "isObject": function() { return /* binding */ isObject; },
/* harmony export */   "lengthToDegrees": function() { return /* binding */ lengthToDegrees; },
/* harmony export */   "lengthToRadians": function() { return /* binding */ lengthToRadians; },
/* harmony export */   "lineString": function() { return /* binding */ lineString; },
/* harmony export */   "lineStrings": function() { return /* binding */ lineStrings; },
/* harmony export */   "multiLineString": function() { return /* binding */ multiLineString; },
/* harmony export */   "multiPoint": function() { return /* binding */ multiPoint; },
/* harmony export */   "multiPolygon": function() { return /* binding */ multiPolygon; },
/* harmony export */   "point": function() { return /* binding */ point; },
/* harmony export */   "points": function() { return /* binding */ points; },
/* harmony export */   "polygon": function() { return /* binding */ polygon; },
/* harmony export */   "polygons": function() { return /* binding */ polygons; },
/* harmony export */   "radiansToDegrees": function() { return /* binding */ radiansToDegrees; },
/* harmony export */   "radiansToLength": function() { return /* binding */ radiansToLength; },
/* harmony export */   "round": function() { return /* binding */ round; },
/* harmony export */   "unitsFactors": function() { return /* binding */ unitsFactors; },
/* harmony export */   "validateBBox": function() { return /* binding */ validateBBox; },
/* harmony export */   "validateId": function() { return /* binding */ validateId; }
/* harmony export */ });
/**
 * @module helpers
 */

/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
var earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */

var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1000,
  kilometres: earthRadius / 1000,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1000,
  millimetres: earthRadius * 1000,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */

var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1000,
  kilometres: 1 / 1000,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1000,
  millimetres: 1000,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */

var areaFactors = {
  acres: 0.000247105,
  centimeters: 10000,
  centimetres: 10000,
  feet: 10.763910417,
  hectares: 0.0001,
  inches: 1550.003100006,
  kilometers: 0.000001,
  kilometres: 0.000001,
  meters: 1,
  metres: 1,
  miles: 3.86e-7,
  millimeters: 1000000,
  millimetres: 1000000,
  yards: 1.195990046
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */

function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var feat = {
    type: "Feature"
  };

  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }

  if (options.bbox) {
    feat.bbox = options.bbox;
  }

  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */

function geometry(type, coordinates, _options) {
  if (_options === void 0) {
    _options = {};
  }

  switch (type) {
    case "Point":
      return point(coordinates).geometry;

    case "LineString":
      return lineString(coordinates).geometry;

    case "Polygon":
      return polygon(coordinates).geometry;

    case "MultiPoint":
      return multiPoint(coordinates).geometry;

    case "MultiLineString":
      return multiLineString(coordinates).geometry;

    case "MultiPolygon":
      return multiPolygon(coordinates).geometry;

    default:
      throw new Error(type + " is invalid");
  }
}
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */

function point(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  if (!coordinates) {
    throw new Error("coordinates is required");
  }

  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }

  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }

  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }

  var geom = {
    type: "Point",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */

function points(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return point(coords, properties);
  }), options);
}
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */

function polygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
    var ring = coordinates_1[_i];

    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }

    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      // Check if first point of Polygon contains two numbers
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }

  var geom = {
    type: "Polygon",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */

function polygons(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return polygon(coords, properties);
  }), options);
}
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */

function lineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }

  var geom = {
    type: "LineString",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */

function lineStrings(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return lineString(coords, properties);
  }), options);
}
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */

function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }

  var fc = {
    type: "FeatureCollection"
  };

  if (options.id) {
    fc.id = options.id;
  }

  if (options.bbox) {
    fc.bbox = options.bbox;
  }

  fc.features = features;
  return fc;
}
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */

function multiLineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiLineString",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */

function multiPoint(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiPoint",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */

function multiPolygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiPolygon",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */

function geometryCollection(geometries, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "GeometryCollection",
    geometries: geometries
  };
  return feature(geom, properties, options);
}
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */

function round(num, precision) {
  if (precision === void 0) {
    precision = 0;
  }

  if (precision && !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }

  var multiplier = Math.pow(10, precision || 0);
  return Math.round(num * multiplier) / multiplier;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */

function radiansToLength(radians, units) {
  if (units === void 0) {
    units = "kilometers";
  }

  var factor = factors[units];

  if (!factor) {
    throw new Error(units + " units is invalid");
  }

  return radians * factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */

function lengthToRadians(distance, units) {
  if (units === void 0) {
    units = "kilometers";
  }

  var factor = factors[units];

  if (!factor) {
    throw new Error(units + " units is invalid");
  }

  return distance / factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */

function lengthToDegrees(distance, units) {
  return radiansToDegrees(lengthToRadians(distance, units));
}
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */

function bearingToAzimuth(bearing) {
  var angle = bearing % 360;

  if (angle < 0) {
    angle += 360;
  }

  return angle;
}
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */

function radiansToDegrees(radians) {
  var degrees = radians % (2 * Math.PI);
  return degrees * 180 / Math.PI;
}
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */

function degreesToRadians(degrees) {
  var radians = degrees % 360;
  return radians * Math.PI / 180;
}
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */

function convertLength(length, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "kilometers";
  }

  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }

  if (!(length >= 0)) {
    throw new Error("length must be a positive number");
  }

  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted area
 */

function convertArea(area, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "meters";
  }

  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }

  if (!(area >= 0)) {
    throw new Error("area must be a positive number");
  }

  var startFactor = areaFactors[originalUnit];

  if (!startFactor) {
    throw new Error("invalid original units");
  }

  var finalFactor = areaFactors[finalUnit];

  if (!finalFactor) {
    throw new Error("invalid final units");
  }

  return area / startFactor * finalFactor;
}
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */

function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */

function isObject(input) {
  return !!input && input.constructor === Object;
}
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */

function validateBBox(bbox) {
  if (!bbox) {
    throw new Error("bbox is required");
  }

  if (!Array.isArray(bbox)) {
    throw new Error("bbox must be an Array");
  }

  if (bbox.length !== 4 && bbox.length !== 6) {
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  }

  bbox.forEach(function (num) {
    if (!isNumber(num)) {
      throw new Error("bbox must only contain numbers");
    }
  });
}
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */

function validateId(id) {
  if (!id) {
    throw new Error("id is required");
  }

  if (["string", "number"].indexOf(typeof id) === -1) {
    throw new Error("id must be a number or a string");
  }
}

/***/ }),

/***/ "./node_modules/@turf/invariant/dist/es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@turf/invariant/dist/es/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "collectionOf": function() { return /* binding */ collectionOf; },
/* harmony export */   "containsNumber": function() { return /* binding */ containsNumber; },
/* harmony export */   "featureOf": function() { return /* binding */ featureOf; },
/* harmony export */   "geojsonType": function() { return /* binding */ geojsonType; },
/* harmony export */   "getCoord": function() { return /* binding */ getCoord; },
/* harmony export */   "getCoords": function() { return /* binding */ getCoords; },
/* harmony export */   "getGeom": function() { return /* binding */ getGeom; },
/* harmony export */   "getType": function() { return /* binding */ getType; }
/* harmony export */ });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");

/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */

function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }

  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return coord.geometry.coordinates;
    }

    if (coord.type === "Point") {
      return coord.coordinates;
    }
  }

  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return coord;
  }

  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */

function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  } // Feature


  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    // Geometry
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }

  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */

function containsNumber(coordinates) {
  if (coordinates.length > 1 && (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(coordinates[0]) && (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(coordinates[1])) {
    return true;
  }

  if (Array.isArray(coordinates[0]) && coordinates[0].length) {
    return containsNumber(coordinates[0]);
  }

  throw new Error("coordinates must only contain numbers");
}
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */

function geojsonType(value, type, name) {
  if (!type || !name) {
    throw new Error("type and name required");
  }

  if (!value || value.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
  }
}
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */

function featureOf(feature, type, name) {
  if (!feature) {
    throw new Error("No feature passed");
  }

  if (!name) {
    throw new Error(".featureOf() requires a name");
  }

  if (!feature || feature.type !== "Feature" || !feature.geometry) {
    throw new Error("Invalid input to " + name + ", Feature with geometry required");
  }

  if (!feature.geometry || feature.geometry.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
  }
}
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */

function collectionOf(featureCollection, type, name) {
  if (!featureCollection) {
    throw new Error("No featureCollection passed");
  }

  if (!name) {
    throw new Error(".collectionOf() requires a name");
  }

  if (!featureCollection || featureCollection.type !== "FeatureCollection") {
    throw new Error("Invalid input to " + name + ", FeatureCollection required");
  }

  for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
    var feature = _a[_i];

    if (!feature || feature.type !== "Feature" || !feature.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }

    if (!feature.geometry || feature.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
  }
}
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */

function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }

  return geojson;
}
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message (unused)
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */

function getType(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }

  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }

  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }

  return geojson.type;
}

/***/ }),

/***/ "./node_modules/@turf/meta/dist/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/meta/dist/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "coordAll": function() { return /* binding */ coordAll; },
/* harmony export */   "coordEach": function() { return /* binding */ coordEach; },
/* harmony export */   "coordReduce": function() { return /* binding */ coordReduce; },
/* harmony export */   "featureEach": function() { return /* binding */ featureEach; },
/* harmony export */   "featureReduce": function() { return /* binding */ featureReduce; },
/* harmony export */   "findPoint": function() { return /* binding */ findPoint; },
/* harmony export */   "findSegment": function() { return /* binding */ findSegment; },
/* harmony export */   "flattenEach": function() { return /* binding */ flattenEach; },
/* harmony export */   "flattenReduce": function() { return /* binding */ flattenReduce; },
/* harmony export */   "geomEach": function() { return /* binding */ geomEach; },
/* harmony export */   "geomReduce": function() { return /* binding */ geomReduce; },
/* harmony export */   "lineEach": function() { return /* binding */ lineEach; },
/* harmony export */   "lineReduce": function() { return /* binding */ lineReduce; },
/* harmony export */   "propEach": function() { return /* binding */ propEach; },
/* harmony export */   "propReduce": function() { return /* binding */ propReduce; },
/* harmony export */   "segmentEach": function() { return /* binding */ segmentEach; },
/* harmony export */   "segmentReduce": function() { return /* binding */ segmentReduce; }
/* harmony export */ });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */

function coordEach(geojson, callback, excludeWrapCoord) {
  // Handles null Geometry -- Skips this GeoJSON
  if (geojson === null) return;
  var j,
      k,
      l,
      geometry,
      stopG,
      coords,
      geometryMaybeCollection,
      wrapShrink = 0,
      coordIndex = 0,
      isGeometryCollection,
      type = geojson.type,
      isFeatureCollection = type === "FeatureCollection",
      isFeature = type === "Feature",
      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.

  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry

      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;

      switch (geomType) {
        case null:
          break;

        case "Point":
          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
          coordIndex++;
          multiFeatureIndex++;
          break;

        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }

          if (geomType === "LineString") multiFeatureIndex++;
          break;

        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
              coordIndex++;
            }

            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }

          if (geomType === "Polygon") multiFeatureIndex++;
          break;

        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;

            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                coordIndex++;
              }

              geometryIndex++;
            }

            multiFeatureIndex++;
          }

          break;

        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++) if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;

          break;

        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */


function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
  }, excludeWrapCoord);
  return previousValue;
}
/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */


function propEach(geojson, callback) {
  var i;

  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false) break;
      }

      break;

    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}
/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */


function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function (currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}
/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */


function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}
/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */


function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function (currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}
/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */


function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function (coord) {
    coords.push(coord);
  });
  return coords;
}
/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */


function geomEach(geojson, callback) {
  var i,
      j,
      g,
      geometry,
      stopG,
      geometryMaybeCollection,
      isGeometryCollection,
      featureProperties,
      featureBBox,
      featureId,
      featureIndex = 0,
      isFeatureCollection = geojson.type === "FeatureCollection",
      isFeature = geojson.type === "Feature",
      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.

  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry

      if (geometry === null) {
        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
        continue;
      }

      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          {
            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
            break;
          }

        case "GeometryCollection":
          {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
            }

            break;
          }

        default:
          throw new Error("Unknown Geometry Type");
      }
    } // Only increase `featureIndex` per each feature


    featureIndex++;
  }
}
/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */


function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
  });
  return previousValue;
}
/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */


function flattenEach(geojson, callback) {
  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
    // Callback for single geometry
    var type = geometry === null ? null : geometry.type;

    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.feature)(geometry, properties, {
          bbox: bbox,
          id: id
        }), featureIndex, 0) === false) return false;
        return;
    }

    var geomType; // Callback for multi-geometry

    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;

      case "MultiLineString":
        geomType = "LineString";
        break;

      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }

    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.feature)(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
    }
  });
}
/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */


function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
  });
  return previousValue;
}
/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */


function segmentEach(geojson, callback) {
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0; // Exclude null Geometries

    if (!feature.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.

    var type = feature.geometry.type;
    if (type === "Point" || type === "MultiPoint") return; // Generate 2-vertex line segments

    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
        previousCoords = currentCoord;
        previousFeatureIndex = featureIndex;
        previousMultiIndex = multiPartIndexCoord;
        prevGeomIndex = geometryIndex;
        segmentIndex = 0;
        return;
      }

      var currentSegment = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)([previousCoords, currentCoord], feature.properties);
      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
      segmentIndex++;
      previousCoords = currentCoord;
    }) === false) return false;
  });
}
/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentIndex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */


function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
    started = true;
  });
  return previousValue;
}
/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */


function lineEach(geojson, callback) {
  // validation
  if (!geojson) throw new Error("geojson is required");
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    if (feature.geometry === null) return;
    var type = feature.geometry.type;
    var coords = feature.geometry.coordinates;

    switch (type) {
      case "LineString":
        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
        break;

      case "Polygon":
        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
          if (callback((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
        }

        break;
    }
  });
}
/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */


function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
  });
  return previousValue;
}
/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */


function findSegment(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex

  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;

    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;

    case "Point":
    case "MultiPoint":
      return null;

    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;

    default:
      throw new Error("geojson is invalid");
  } // Find SegmentIndex


  if (geometry === null) return null;
  var coords = geometry.coordinates;

  switch (geometry.type) {
    case "Point":
    case "MultiPoint":
      return null;

    case "LineString":
      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);

    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);

    case "MultiLineString":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);

    case "MultiPolygon":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
  }

  throw new Error("geojson is invalid");
}
/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */


function findPoint(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0; // Find FeatureIndex

  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;

    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;

    case "Point":
    case "MultiPoint":
      return null;

    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;

    default:
      throw new Error("geojson is invalid");
  } // Find Coord Index


  if (geometry === null) return null;
  var coords = geometry.coordinates;

  switch (geometry.type) {
    case "Point":
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords, properties, options);

    case "MultiPoint":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[multiFeatureIndex], properties, options);

    case "LineString":
      if (coordIndex < 0) coordIndex = coords.length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[coordIndex], properties, options);

    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[geometryIndex][coordIndex], properties, options);

    case "MultiLineString":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[multiFeatureIndex][coordIndex], properties, options);

    case "MultiPolygon":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
  }

  throw new Error("geojson is invalid");
}



/***/ }),

/***/ "./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customAlphabet": function() { return /* binding */ customAlphabet; },
/* harmony export */   "customRandom": function() { return /* binding */ customRandom; },
/* harmony export */   "nanoid": function() { return /* binding */ nanoid; },
/* harmony export */   "random": function() { return /* binding */ random; },
/* harmony export */   "urlAlphabet": function() { return /* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet; }
/* harmony export */ });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "./node_modules/nanoid/url-alphabet/index.js");


let random = bytes => crypto.getRandomValues(new Uint8Array(bytes));

let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return function () {
    let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;
    let id = '';

    while (true) {
      let bytes = getRandom(step);
      let j = step;

      while (j--) {
        id += alphabet[bytes[j] & mask] || '';
        if (id.length === size) return id;
      }
    }
  };
};

let customAlphabet = function (alphabet) {
  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 21;
  return customRandom(alphabet, size, random);
};

let nanoid = function () {
  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
  return crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63;

    if (byte < 36) {
      id += byte.toString(36);
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte > 62) {
      id += '-';
    } else {
      id += '_';
    }

    return id;
  }, '');
};



/***/ }),

/***/ "./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "urlAlphabet": function() { return /* binding */ urlAlphabet; }
/* harmony export */ });
let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!************************************************!*\
  !*** ./src/js/front/treweler-store-locator.js ***!
  \************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _modules_twer_store_locator_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/twer-store-locator-control */ "./src/js/front/modules/twer-store-locator-control/index.js");
/* harmony import */ var _modules_twer_store_locator_control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_modules_twer_store_locator_control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _turf_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/buffer */ "./node_modules/@turf/buffer/dist/es/index.js");
/* harmony import */ var _turf_distance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turf/distance */ "./node_modules/@turf/distance/dist/es/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");
/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ "./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js");
/* harmony import */ var _modules_select2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/select2 */ "./src/js/front/modules/select2.js");
/* harmony import */ var _modules_filters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/filters */ "./src/js/front/modules/filters.js");



const $ = jQuery.noConflict();







const formData = new FormData();
formData.append('action', 'twer_getDataForMapMarkers');
formData.append('mapId', parseInt(document.getElementById('twer-map').dataset.mapId));
let allMarkers = [];
const fetchDataAll = fetch(treweler_params.ajax_url, {
  method: 'POST',
  credentials: 'same-origin',
  body: formData
}).then(response => response.json()).then(data => {
  const formData1 = new FormData();
  formData1.append('action', 'twer_getStoreLocatorMapFilters');
  formData1.append('mapId', parseInt(document.getElementById('twer-map').dataset.mapId));
  allMarkers = data;
  return fetch(treweler_params.ajax_url, {
    method: 'POST',
    credentials: 'same-origin',
    body: formData1
  });
}).then(response => response.json()).catch(err => {
  console.error('Request failed', err);
});
/**
 * Init Store Locator Logic
 */

class TWER_STORE_LOCATOR {
  /**
   * Сonstructor
   *
   * @param data
   */
  mapboxCtrHandler() {
    if (window.matchMedia('(max-width: 370px)').matches) {
      $('.js-twer-store-locator').closest('div[class^="mapboxgl-ctrl-"]').css('width', '100%');
    } else {
      $('.js-twer-store-locator').closest('div[class^="mapboxgl-ctrl-"]').css('width', 'auto');
    }

    if (this.isExtendedStoreLocatorEnabled()) {
      if (window.matchMedia('(max-width: 650px)').matches) {
        document.getElementById('js-twer-store-locator-panel-btn-open').classList.remove('d-none');
        this.extendedStoreLocatorPanel.classList.remove('open');
        this.extendedStoreLocatorPanel.classList.add('close');
      } else {
        if (this.mapProperties.storeLocatorSidebarClose) {
          document.getElementById('js-twer-store-locator-panel-btn-open').classList.remove('d-none');
          this.extendedStoreLocatorPanel.classList.remove('open');
          this.extendedStoreLocatorPanel.classList.add('close');
        } else {
          document.getElementById('js-twer-store-locator-panel-btn-open').classList.add('d-none');
          this.extendedStoreLocatorPanel.classList.remove('close');
          this.extendedStoreLocatorPanel.classList.add('open');
        }
      }
    }
  }

  storeLocatorControls() {
    const scope = this;
    return {
      onAdd(map) {
        this._map = map;

        let _this = this;

        this.toggleStoreLocatorSidebar = document.createElement("button");
        this.toggleStoreLocatorSidebar.className = `twer-store-locator-panel-btn-open-control d-none`;
        this.toggleStoreLocatorSidebar.id = "js-twer-store-locator-panel-btn-open";
        this.toggleStoreLocatorSidebar.type = "button";
        this._container = document.createElement("div");
        this._container.className = 'mapboxgl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl--treweler';

        this._container.appendChild(this.toggleStoreLocatorSidebar);

        return this._container;
      },

      onRemove() {
        this._container.parentNode.removeChild(this._container);

        this._map = undefined;
      }

    };
  }

  startTouch(e) {
    this.initialX = e.touches[0].clientX;
    this.initialY = e.touches[0].clientY;
  }

  moveTouch(e) {
    if (this.initialX === null || this.initialY === null) {
      return;
    }

    const currentX = e.touches[0].clientX;
    const currentY = e.touches[0].clientY;
    const diffX = this.initialX - currentX;
    const diffY = this.initialY - currentY;

    if (Math.abs(diffX) > Math.abs(diffY)) {
      if (diffX > 0 && this.mapProperties.storeLocatorSidebarPosition === 'left') {
        this.closeSidebar();
      } else if (diffX < 0 && this.mapProperties.storeLocatorSidebarPosition === 'right') {
        this.closeSidebar();
      }
    } else {// Detecting vertical swipe, if you need it
    }

    this.initialX = null;
    this.initialY = null; // e.preventDefault();
  }

  constructor(props) {
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "radius", 10);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "radiusDistance", 'kilometers');

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "radiusCoords", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "simpleCardDocumentFragment", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "imageCardDocumentFragment", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "galleryCardDocumentFragment", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "noResultMessageBlock", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "storeLocatorCardsOutputArea", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "storeLocatorCardDetailArea", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "storeLocatorHeader", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "buttonCloseStoreLocatorPanel", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "buttonOpenStoreLocatorPanel", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "extendedStoreLocatorPanel", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "mapProperties", {});

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "loadedMarkers", {});

    this.mapProperties = props;

    if (this.isExtendedStoreLocatorEnabled()) {
      if (props.storeLocatorSidebarOpenButtonPosition === 'top') {
        TWER.map.addControl(this.storeLocatorControls(), `top-${props.storeLocatorSidebarPosition}`);
      }

      this.initExtendedStoreLocatorElements();
      this.initExtendedStoreLocatorPanelHandlers();
      this.initialX = null;
      this.initialY = null; // Event listeners

      this.extendedStoreLocatorPanel.addEventListener("touchstart", this.startTouch.bind(this), false);
      this.extendedStoreLocatorPanel.addEventListener("touchmove", this.moveTouch.bind(this), false);
    }

    if (props.allowStoreLocator) {
      this.radius = props.storeLocatorRadiusDefault === 'unlim' ? props.storeLocatorRadiusDefault.toString() : parseInt(props.storeLocatorRadiusDefault);
      this.radiusDistance = props.storeLocatorRadiusDistance;
      TWER.map.on('load', () => {
        if (props.storeLocatorGeolocation || props.storeLocatorSearch || props.storeLocatorRadius) {
          let geolocationControl = props.storeLocatorGeolocation;
          let searchControl = props.storeLocatorSearch;
          let filterControl = false;

          if (props.storeLocatorType === 'extended' && !props.storeLocatorSearchAndGeolocation) {
            geolocationControl = false;
            searchControl = false;
          }

          if (props.storeLocatorType === 'extended' && props.storeLocatorSearchAndGeolocation) {
            geolocationControl = true;
            searchControl = true;
          }

          if (props.storeLocatorType === 'extended') {
            let slf = props.storeLocatorFilters;

            if (slf === 'details') {
              slf = true;
            }

            filterControl = slf;
          } // Init store locator & radius control field


          TWER.storeLocator = new (_modules_twer_store_locator_control__WEBPACK_IMPORTED_MODULE_1___default())({
            accessToken: mapboxgl.accessToken,
            zoom: 14,
            flyTo: true,
            placeholder: props.storeLocatorSearchPlaceholder,
            mapboxgl: mapboxgl,
            marker: false,
            positionOptions: {
              enableHighAccuracy: true
            },
            showAccuracyCircle: false,
            trackUserLocation: true,
            showUserHeading: true,
            geolocationControl: geolocationControl,
            filterControl: filterControl,
            geocoderControl: searchControl,
            radiusControl: props.storeLocatorRadius,
            radiusSizes: props.storeLocatorRadiusSize,
            radiusDistance: props.storeLocatorRadiusDistance,
            radiusDefault: props.storeLocatorRadiusDefault,
            storeLocatorType: props.storeLocatorType,
            searchAndGeolocation: props.storeLocatorSearchAndGeolocation,
            strings: props.storeLocatorStrings
          });
          const $extendedStoreLocator = document.getElementById('js-twer-extended-store-locator');

          if ($extendedStoreLocator) {
            $extendedStoreLocator.appendChild(TWER.storeLocator.onAdd(TWER.map));
          } else {
            TWER.map.addControl(TWER.storeLocator, props.storeLocatorControlsPosition.replace('_', '-'));
          } //Change marker position after search in geolocator search box


          TWER.storeLocator.on('result', e => {
            if (props.storeLocatorMarker || props.directions.enable) {
              this.removeMarker();
              this.addMarker(TWER.markerLocationProps, e.result.center);
            }

            if (props.storeLocatorMarker) {
              this.addRadius(e.result.center, 'yes');
            }
          }); // Change marker position after click on geoposition button

          let geolocateFlag = false;
          let geolocateCoords = [];
        }
      });
      TWER.map.on('load', () => {
        fetchDataAll.then(result => {
          if (props.storeLocatorType === 'extended') {
            const filters = new _modules_filters__WEBPACK_IMPORTED_MODULE_7__["default"](result);
          }

          this.loadedMarkers = allMarkers;
          this.initExtendedStoreLocator(); // Add search radius layer

          TWER.map.addLayer({
            id: 'search-radius',
            source: {
              type: 'geojson',
              data: {
                'type': 'FeatureCollection',
                'features': []
              }
            },
            type: 'fill',
            paint: {
              'fill-color': '#d5b244',
              'fill-opacity': 0
            }
          });
          let coords = props.center;
          this.addRadius(coords); // Add Store Locator Marker after click on map

          TWER.map.on('click', event => {
            if (!event.originalEvent.target.classList.contains('mapboxgl-canvas')) return;
            coords = event.lngLat.wrap();
            this.addRadius(coords, 'yes');
          }); //if (props.userGeolocation) {
          //  TWER.map.on('movestart', (e) => {
          //    if (e.hasOwnProperty('userLocation') && props.storeLocatorMarker) {
          //      const userCoords = e.userLocation;
          //      this.addRadius(userCoords, 'yes');
          //    }
          //  });
          //}

          if (props.storeLocatorGeolocation || props.storeLocatorSearch || props.storeLocatorRadius) {
            if (props.storeLocatorFilters === 'details') {
              document.getElementById('js-twer-store-locator-filters-area').classList.remove('hide');
              document.getElementById('js-twer-filters-header').classList.add('hide');
            }
          }

          let width = '133px';
          let classDDl = 'twer-store-locator-radius-ddl';

          if ($('body').hasClass('twer-has-store-locator--extended') && !$('.twer-store-locator-filter').length > 0) {
            width = '100%';
            classDDl += ' twer-store-locator-radius-ddl--fullwidth';
            $('.twer-store-locator-radius').addClass('twer-store-locator-radius--fullwidth');
          }

          $('#js-store-locator-radius').select2({
            //closeOnSelect: false,
            minimumResultsForSearch: -1,
            width: width,
            dropdownCssClass: classDDl
          }).on('select2:select', e => {
            var _e$params;

            const radius = ((_e$params = e.params) === null || _e$params === void 0 ? void 0 : _e$params.data.id) || e.target.value;
            $('#field-radius').val(radius).trigger('change');
            this.refreshRadius(radius, 'yes');
          });
          const $fiterRange = $('.js-twer-filter-form-range');

          if ($fiterRange.length > 0) {
            $fiterRange.each((index, element) => {
              const $filter = $(element);
              const $rangeSlider = $filter.find('.js-twer-slider');
              const $rangeStart = $filter.find('.js-twer-filter-range-value-start');
              const $rangeEnd = $filter.find('.js-twer-filter-range-value-end');
              const min = +$rangeStart.val();
              const max = +$rangeEnd.val();
              const minDefault = +$rangeSlider.data('default-value-min');
              const maxDefault = +$rangeSlider.data('default-value-max');
              $rangeSlider.slider({
                range: true,
                min: min,
                max: max,
                values: [minDefault, maxDefault],
                slide: (event, ui) => {
                  $rangeStart.val(ui.values[0]);
                  $rangeEnd.val(ui.values[1]);
                },
                create: (event, ui) => {
                  $rangeStart.val(minDefault);
                  $rangeEnd.val(maxDefault);
                },
                stop: (event, ui) => {
                  this.refreshRadius(this.getCurrentRadius(), 'yes');
                }
              });
              $rangeStart.on('change', event => {
                const inputSourceValue = event.target.value || 0;
                const inputValueStart = parseInt(inputSourceValue);
                const sliderValues = $rangeSlider.slider('option', 'values');

                if (inputValueStart < min || inputValueStart >= max) {
                  $rangeStart.val(sliderValues[0]);
                } else {
                  $rangeSlider.slider('option', 'values', [inputValueStart, sliderValues[1]]);
                  this.refreshRadius(this.getCurrentRadius(), 'yes');
                }
              });
              $rangeEnd.on('change', event => {
                const inputSourceValue = event.target.value || 0;
                const inputValueEnd = parseInt(inputSourceValue);
                const sliderValues = $rangeSlider.slider('option', 'values');

                if (inputValueEnd <= min || inputValueEnd > max) {
                  $rangeEnd.val(sliderValues[1]);
                } else {
                  $rangeSlider.slider('option', 'values', [sliderValues[0], inputValueEnd]);
                  this.refreshRadius(this.getCurrentRadius(), 'yes');
                }
              });
            });
          }

          const $filterTrueFalse = $('.js-twer-filter-true-false-checkbox');

          if ($filterTrueFalse.length > 0) {
            $filterTrueFalse.each((index, element) => {
              const $checkbox = $(element);
              $checkbox.on('change', e => {
                this.refreshRadius(this.getCurrentRadius(), 'yes');
              });
            });
          }

          const i18n_categories = treweler_params.i18n_categories;
          const $filterInnerCategories = $('.js-twer-filter-categories');
          $filterInnerCategories.each((index, element) => {
            const $select = $(element);
            const options = {
              placeholder: i18n_categories.all,
              maximumSelectionLength: -1,
              selectionCssClass: 'twer-select-control twer-select-control-short',
              closeOnSelect: false,
              tags: false,
              dropdownCssClass: 'twer-select2-ddl twer-select2-ddl--multiselect'
            };
            const select2 = new _modules_select2__WEBPACK_IMPORTED_MODULE_6__["default"](options, $select);
            $select.next('.select2').find('.select2-search.select2-search--inline').html('<span class="category-label1">' + i18n_categories.all + '</span>');
            select2.$select.on('change', e => {
              const value = $(e.currentTarget).val();

              if ($('#mapCatField').length > 0) {
                $('#mapCatField').val(value).trigger('change');
              } else {
                this.refreshRadius(this.getCurrentRadius(), 'yes');
              }
            });
            select2.$select.on('change.select2', e => {
              let $this = $(e.currentTarget).next('.select2');
              let inLabel = $this.find('.select2-search .category-label1');
              let count = select2.$select.select2('data').length;
              let countOptions = $select.find('option').length;

              if (count === 0) {
                inLabel.html('<span class="category-label1">' + i18n_categories.no_selected + '</span>');
              } else if (count === 1) {
                inLabel.html('<span class="category-label1">1 ' + i18n_categories.one_selected + '</span>');
              } else if (count > 1 && countOptions !== count) {
                inLabel.html('<span class="category-label1">' + count + ' ' + i18n_categories.selected + '</span>');
              } else {
                inLabel.html('<span class="category-label1">' + i18n_categories.all + '</span>');
              }
            });
            select2.$select.on('select2:unselect', event => {
              let categoryId = parseInt(event.params.data.id) || 0;
              const options = document.getElementById('field-categories').options;
              const optionsData = {};

              for (let i = 0; i < options.length; i++) {
                if (categoryId === parseInt(options[i].value)) {
                  optionsData[options[i].value] = false;
                } else {
                  optionsData[options[i].value] = options[i].selected;
                }
              }

              if (TWER.fitBounds) {
                TWER.map.fitBounds(TWER.boundsData, {
                  linear: true
                });
              }

              if (!window.TWER.data.allowStoreLocator) {
                // Run code if clusters disabled
                if (!TWER.allowCluster) {
                  for (let i = 0; i < TWER.markers.length; i++) {
                    const $markerElement = TWER.markers[i].element._element;

                    if ($markerElement.classList.contains(`category-${categoryId}`)) {
                      TWER.markers[i].show = false;
                      TWER.markers[i].element._element.style.display = 'none';
                    }
                  }
                } else {
                  TWER.globalClusterStatus = false;
                  const removedIndexesFeatures = [];
                  const removedIndexesMarkers = [];
                  const removedCats = [];

                  if (!TWER.isEmpty(TWER.clusterData)) {
                    if (TWER.clusterData.features.length > 0) {
                      for (let i = 0; i < TWER.clusterData.features.length; i++) {
                        const props = TWER.clusterData.features[i].properties;
                        const categories = JSON.parse(props.cat_ids);

                        if (categories.length <= 1) {
                          if (categories.includes(categoryId)) {
                            removedCats.push(categoryId);
                            removedIndexesFeatures.push(i);
                            TWER.clusterDataDump.push(TWER.clusterData.features[i]);
                          }
                        } else {
                          let globalApprove = 0;

                          for (let j = 0; j < categories.length; j++) {
                            if (!optionsData[categories[j]]) {
                              globalApprove++;
                            }
                          }

                          if (globalApprove === categories.length) {
                            if (categories.includes(categoryId)) {
                              removedCats.push(categoryId);
                              removedIndexesFeatures.push(i);
                              TWER.clusterDataDump.push(TWER.clusterData.features[i]);
                            }
                          }
                        }
                      }

                      if (removedIndexesFeatures.length > 0) {
                        const indexSet = new Set(removedIndexesFeatures);
                        TWER.clusterData.features = TWER.clusterData.features.filter((value, i) => !indexSet.has(i));
                      }

                      for (let i = 0; i < TWER.markers.length; i++) {
                        const props = TWER.markers[i].feature.properties;
                        const markerCategories = JSON.parse(props.cat_ids);

                        if (markerCategories.length <= 1) {
                          if (markerCategories.some(item => removedCats.includes(item))) {
                            removedIndexesMarkers.push(i);
                            TWER.markersDataDump.push(TWER.markers[i]);
                          }
                        } else {
                          let globalApprove1 = 0;

                          for (let j = 0; j < markerCategories.length; j++) {
                            if (!optionsData[markerCategories[j]]) {
                              globalApprove1++;
                            }
                          }

                          if (globalApprove1 === markerCategories.length) {
                            if (markerCategories.some(item => removedCats.includes(item))) {
                              removedIndexesMarkers.push(i);
                              TWER.markersDataDump.push(TWER.markers[i]);
                            }
                          }
                        }
                      }

                      if (removedIndexesMarkers.length > 0) {
                        for (let i = 0; i < removedIndexesMarkers.length; i++) {
                          TWER.markers[removedIndexesMarkers[i]].element.remove();
                        }

                        const indexSet1 = new Set(removedIndexesMarkers);
                        TWER.markers = TWER.markers.filter((value, i) => !indexSet1.has(i));
                        TWER.map.getSource('locations').setData(TWER.clusterData);
                      }
                    }
                  }

                  if (TWER.markersIgnoredClusters.length > 0) {
                    for (let i = 0; i < TWER.markersIgnoredClusters.length; i++) {
                      const $markerElement = TWER.markersIgnoredClusters[i].element._element;

                      if ($markerElement.classList.contains(`category-${categoryId}`)) {
                        TWER.markersIgnoredClusters[i].show = false;
                        TWER.markersIgnoredClusters[i].element._element.style.display = 'none';
                      }
                    }
                  }
                }
              }

              let lRoutesRaw = event.params.data.element.dataset.routes.split(' ');
              let routeAnyChecked = false;
              let ids = [];

              for (let i = 0; i < lRoutesRaw.length; i++) {
                if ($("#field-categories option[value!='" + categoryId + "'][data-routes*='" + lRoutesRaw[i] + "']").is(':checked')) {
                  routeAnyChecked = true;
                  continue;
                }

                ids.push(lRoutesRaw[i]);
              }

              for (let iw = 0; iw < ids.length; iw++) {
                if (ids[iw] && ids[iw] !== 'route-0') {
                  TWER.map.setLayoutProperty(ids[iw], 'visibility', 'none');
                }
              }
            });
            select2.$select.on('select2:select', event => {
              if (!window.TWER.data.allowStoreLocator) {
                let categoryId = parseInt(event.params.data.id) || 0;

                if (TWER.fitBounds) {
                  TWER.map.fitBounds(TWER.boundsData, {
                    linear: true
                  });
                } // Run code if clusters disabled


                if (!TWER.allowCluster) {
                  for (let i = 0; i < TWER.markers.length; i++) {
                    const $markerElement = TWER.markers[i].element._element;

                    if ($markerElement.classList.contains(`category-${categoryId}`)) {
                      TWER.markers[i].show = true;
                      TWER.markers[i].element._element.style.display = 'block';
                    }
                  }
                } else {
                  TWER.globalClusterStatus = false;
                  const removedIndexesFeatures = [];
                  const removedIndexesMarkers = [];
                  const removedCats = [];

                  if (!TWER.isEmpty(TWER.clusterDataDump)) {
                    if (TWER.clusterDataDump.length > 0) {
                      for (let i = 0; i < TWER.clusterDataDump.length; i++) {
                        const props = TWER.clusterDataDump[i].properties;
                        const categories = JSON.parse(props.cat_ids);

                        if (categories.includes(categoryId)) {
                          removedCats.push(categoryId);
                          removedIndexesFeatures.push(i);
                          TWER.clusterData.features.push(TWER.clusterDataDump[i]);
                        }
                      }

                      const indexSet = new Set(removedIndexesFeatures);
                      TWER.clusterDataDump = TWER.clusterDataDump.filter((value, i) => !indexSet.has(i));

                      for (let i = 0; i < TWER.markersDataDump.length; i++) {
                        const props = TWER.markersDataDump[i].feature.properties;
                        const markerCategories = JSON.parse(props.cat_ids);

                        if (markerCategories.some(item => removedCats.includes(item))) {
                          removedIndexesMarkers.push(i);
                          TWER.markers.push(TWER.markersDataDump[i]);
                        }
                      }

                      for (let i = 0; i < removedIndexesMarkers.length; i++) {
                        const coords = TWER.markersDataDump[removedIndexesMarkers[i]].feature.geometry.coordinates;
                        const props = TWER.markersDataDump[removedIndexesMarkers[i]].feature.properties;
                        const desc = props === null || props === void 0 ? void 0 : props.description;
                        props.showPopup = false;
                        const markerElement = TWER.createNewMarker(props, coords, desc);
                        TWER.markersDataDump[removedIndexesMarkers[i]].element = new mapboxgl.Marker(markerElement).setLngLat(coords).addTo(TWER.map);

                        TWER.__afterCreateNewMarker(markerElement, props);
                      }

                      const indexSet1 = new Set(removedIndexesMarkers);
                      TWER.markersDataDump = TWER.markersDataDump.filter((value, i) => !indexSet1.has(i));
                      TWER.map.getSource('locations').setData(TWER.clusterData);
                    }
                  }

                  if (TWER.markersIgnoredClusters.length > 0) {
                    for (let i = 0; i < TWER.markersIgnoredClusters.length; i++) {
                      const $markerElement = TWER.markersIgnoredClusters[i].element._element;

                      if ($markerElement.classList.contains(`category-${categoryId}`)) {
                        TWER.markersIgnoredClusters[i].show = true;
                        TWER.markersIgnoredClusters[i].element._element.style.display = 'block';
                      }
                    }
                  }
                }
              }

              let lRoutesRaw = event.params.data.element.dataset.routes.split(' ');

              for (let i = 0; i < lRoutesRaw.length; i++) {
                if (lRoutesRaw[i] && lRoutesRaw[i] !== 'route-0') {
                  TWER.map.setLayoutProperty(lRoutesRaw[i], 'visibility', 'visible');
                }
              }
            });
          });
          const $filterMultiselect = $('.js-twer-filter-multiselect');
          $filterMultiselect.each((index, element) => {
            const $select = $(element);
            const options = {
              placeholder: {
                id: '-1',
                text: treweler_params.i18n.select_items
              },
              maximumSelectionLength: -1,
              closeOnSelect: false,
              tags: true,
              tokenSeparators: [','],
              dropdownCssClass: 'twer-select2-ddl twer-select2-ddl--multiselect',
              createTag: (params, e) => {
                return null;
              }
            };
            const select2 = new _modules_select2__WEBPACK_IMPORTED_MODULE_6__["default"](options, $select);
            select2.$select.on('change', e => {
              this.refreshRadius(this.getCurrentRadius(), 'yes');
            });
          });
          const $filterSelect = $('.js-twer-filter-select');
          $filterSelect.each((index, element) => {
            const $select = $(element);
            let options = {};
            const select2 = new _modules_select2__WEBPACK_IMPORTED_MODULE_6__["default"](options, $select);
            select2.$select.on('select2:select', e => {
              if (e.currentTarget.id === 'field-radius') {
                var _e$params2;

                const radius = ((_e$params2 = e.params) === null || _e$params2 === void 0 ? void 0 : _e$params2.data.id) || e.target.value;
                $('#js-store-locator-radius').val(radius).trigger('change');
                this.refreshRadius(radius, 'yes');
              }
            });
          });
          const $filterCategories = $('#mapCatField');
          $filterCategories.on('change', e => {
            const value = $(e.currentTarget).val();
            this.refreshRadius(this.getCurrentRadius(), 'yes');

            if ($('.js-twer-filter-categories').length > 0) {
              $('.js-twer-filter-categories').val(value).trigger('change.select2');
            }
          });
          this.mapboxCtrHandler();
          window.addEventListener('resize', () => {
            this.mapboxCtrHandler();
          });
          const $preloader = document.getElementById('js-twer-store-locator-preloader');

          if (typeof $preloader != 'undefined' && $preloader != null) {
            $preloader.classList.add('d-none');
          }
        });
      });

      if (props.storeLocatorType === 'extended') {
        document.getElementById('js-twer-filters-reset').addEventListener('click', e => {
          e.preventDefault();
          this.filtersReset();
        });
        $(document).on('click', '.twer-store-locator-filter-clear', e => {
          e.preventDefault();
          this.filtersReset();
        });
      }
    }
  }

  getCurrentRadius() {
    let currentRadius = $('#js-store-locator-radius').val();

    if (typeof currentRadius === 'undefined') {
      currentRadius = $('#field-radius').val();

      if (typeof currentRadius === 'undefined') {
        currentRadius = 'unlim';
      }
    }

    return currentRadius;
  }

  filtersReset() {
    if ($('#js-twer-filters').children().length > 0) {
      $('#js-twer-filters').children().each((index, element) => {
        const $filter = $(element);
        const filterId = $filter.data('filter-id');

        if ($filter.hasClass('js-twer-filter-form-range')) {
          const startInput = parseInt($filter.find('.js-twer-filter-range-value-start').attr('min'));
          const endInput = parseInt($filter.find('.js-twer-filter-range-value-end').attr('max'));
          const $rangeSlider = $filter.find('.js-twer-slider');
          $rangeSlider.slider('option', 'values', [startInput, endInput]).trigger('stop');
          $filter.find('.js-twer-filter-range-value-start').val(startInput);
          $filter.find('.js-twer-filter-range-value-end').val(endInput);
        }

        if ($filter.hasClass('js-twer-filter-form-true-false')) {
          $filter.find('.js-twer-filter-true-false-checkbox').prop('checked', false).trigger('change');
        }

        if ($filter.hasClass('js-twer-filter-form-multiselect')) {
          $filter.find('.js-twer-filter-multiselect').val(null).trigger('change');
        }
      });
    }

    this.refreshRadius(this.getCurrentRadius());
  }

  isExtendedStoreLocatorEnabled() {
    return this.mapProperties.allowStoreLocator && this.mapProperties.storeLocatorType === 'extended';
  }

  initExtendedStoreLocator() {
    if (this.isExtendedStoreLocatorEnabled()) {
      this.addExtendedLocatorCards();
      this.initExtendedStoreLocatorDetailsCardsHandlers();
      this.initExtendedStoreLocatorCardsHandlers();
      $(window.wp.mediaelement.initialize);
    }
  }

  addExtendedLocatorCards() {
    for (const [key, value] of Object.entries(this.loadedMarkers)) {
      this.addStoreLocatorCardsFromMarker(value);
    }
  }

  initExtendedStoreLocatorElements() {
    this.extendedStoreLocatorPanel = document.getElementById('js-twer-store-locator-panel');
    this.storeLocatorCardsOutputArea = document.getElementById('js-twer-store-locator-cards-area');
    this.simpleCardDocumentFragment = document.getElementById('js-twer-store-locator-simple-card').content;
    this.imageCardDocumentFragment = document.getElementById('js-twer-store-locator-image-card').content;
    this.galleryCardDocumentFragment = document.getElementById('js-twer-store-locator-gallery-card').content;
    this.noResultMessageBlock = document.getElementById('js-twer-store-locator-no-results-message');
    this.storeLocatorCardDetailOutputArea = document.getElementById('js-twer-store-locator-card-detail-area');
    this.storeLocatorHeader = document.getElementById('js-twer-store-locator-header');
    this.buttonCloseStoreLocatorPanel = document.getElementById('js-twer-store-locator-panel-btn-close');
    this.buttonOpenStoreLocatorPanel = document.getElementById('js-twer-store-locator-panel-btn-open');
    this.customFieldsSection = document.getElementById('js-twer-custom-fields-section').content;
    this.customFieldLine = document.getElementById('js-twer-custom-field-line').content;
    this.customFieldLink = document.getElementById('js-twer-custom-field-link').content;
    this.customFieldMultiselect = document.getElementById('js-twer-custom-field-multiselect').content;
    this.customFieldNumber = document.getElementById('js-twer-custom-field-number').content;
    this.customFieldSeparator = document.getElementById('js-twer-custom-field-separator').content;
    this.customFieldText = document.getElementById('js-twer-custom-field-text').content;
    this.customFieldTrueFalse = document.getElementById('js-twer-custom-field-true-false').content;
    this.customFieldHTML = document.getElementById('js-twer-custom-field-html').content;
    this.customFieldCategory = document.getElementById('js-twer-custom-field-category').content;
  }

  closeSidebar() {
    this.extendedStoreLocatorPanel.classList.add('close');
    this.extendedStoreLocatorPanel.classList.remove('open');
    this.buttonOpenStoreLocatorPanel.classList.remove('d-none');
    TWER.map.resize();
  }

  initExtendedStoreLocatorPanelHandlers() {
    this.buttonCloseStoreLocatorPanel.addEventListener('click', event => {
      event.preventDefault();
      this.closeSidebar();
    });
    this.buttonOpenStoreLocatorPanel.addEventListener('click', event => {
      event.preventDefault();
      this.extendedStoreLocatorPanel.classList.add('open');
      this.extendedStoreLocatorPanel.classList.remove('close');
      TWER.map.resize();
      event.target.classList.add('d-none');
    });

    if (window.matchMedia('(max-width: 650px)').matches) {
      document.getElementById('js-twer-store-locator-panel-btn-open').classList.remove('d-none');
      this.extendedStoreLocatorPanel.classList.remove('open');
      this.extendedStoreLocatorPanel.classList.add('close');
    } else {
      if (this.mapProperties.storeLocatorSidebarClose) {
        document.getElementById('js-twer-store-locator-panel-btn-open').classList.remove('d-none');
        this.extendedStoreLocatorPanel.classList.remove('open');
        this.extendedStoreLocatorPanel.classList.add('close');
      } else {
        document.getElementById('js-twer-store-locator-panel-btn-open').classList.add('d-none');
        this.extendedStoreLocatorPanel.classList.remove('close');
        this.extendedStoreLocatorPanel.classList.add('open');
      }
    }
  }

  spatialJoin(sourceGeoJSON, filterFeature) {
    var joined = sourceGeoJSON.features.filter(function (feature) {
      return (0,_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_5__["default"])(feature, filterFeature) || feature.properties.ignoreRadiusFilter;
    });
    return joined;
  }

  hideAllExtendedLocatorCards() {
    if (this.storeLocatorCardsOutputArea !== null) {
      for (let i = 0; i < this.storeLocatorCardsOutputArea.children.length; i++) {
        this.storeLocatorCardsOutputArea.children[i].classList.add('hide');
      }
    }
  }

  getIgnoredFiltrateMarkers(collection) {
    const ignoredFeaturesForFilters = [];

    if (collection.length > 0) {
      for (let q = 0; q < collection.length; q++) {
        if (collection[q].properties.ignoreFilters) {
          ignoredFeaturesForFilters.push(collection[q]);
        }
      }
    }

    return ignoredFeaturesForFilters;
  }

  getClearedCollectionWithOnlyFiltratedMarkers(collection) {
    const featuresForFilters = [];

    if (collection.length > 0) {
      for (let q = 0; q < collection.length; q++) {
        if (!collection[q].properties.ignoreFilters) {
          featuresForFilters.push(collection[q]);
        }
      }
    }

    return featuresForFilters;
  }

  filtrateFeaturesByFiltres(collection, filtrate, filterChange) {
    if (this.mapProperties.storeLocatorType === 'extended') {
      let filteredCollection = [];
      const ignoredMarkersForFiltering = this.getIgnoredFiltrateMarkers(collection);
      const markersForFiltering = this.getClearedCollectionWithOnlyFiltratedMarkers(collection);
      const filtersIgnored = [];
      collection = markersForFiltering;

      if (filtrate === 'yes' && $('#js-twer-filters').children().length > 0 && this.mapProperties.storeLocatorFilters) {
        if (this.getSelectedFiltersNumber() !== 0) {
          let filters = [];
          $('#js-twer-filters').children().each((index, element) => {
            const $filter = $(element);
            const filterId = $filter.data('filter-id');

            if ($filter.hasClass('js-twer-filter-form-range')) {
              const values = $filter.find('.js-twer-slider').slider('option', 'values');
              filters.push({
                'type': 'range',
                'key': filterId,
                'value': values
              });
            }

            if ($filter.hasClass('js-twer-filter-form-true-false')) {
              const checked = $filter.find('.js-twer-filter-true-false-checkbox').prop('checked');
              filters.push({
                'type': 'true_false',
                'key': filterId,
                'value': checked ? 'yes' : 'no'
              });
            }

            if ($filter.hasClass('js-twer-filter-form-multiselect')) {
              const selected = $filter.find('.js-twer-filter-multiselect').val();
              filters.push({
                'type': 'multiselect',
                'key': filterId,
                'value': selected
              });
            }
          });

          if (collection.length > 0) {
            for (let q = 0; q < collection.length; q++) {
              const collectionItem1 = collection[q];
              const filteredFields1 = collectionItem1.properties.filteredFields;

              for (let e = 0; e < filters.length; e++) {
                const filter1 = filters[e];

                if (!lodash.some(filteredFields1, {
                  'key': filter1.key
                })) {
                  let dynamicValue;

                  switch (filter1.type) {
                    case 'true_false':
                      dynamicValue = 'no';
                      break;

                    case 'multiselect':
                      dynamicValue = [];
                      break;

                    case 'range':
                      dynamicValue = 9999999999;
                      break;
                  }

                  collection[q].properties.filteredFields.push({
                    name: 'Dynamic Filtered Field',
                    key: filter1.key,
                    value: dynamicValue
                  });
                }
              }
            }
          }

          if (collection.length > 0) {
            for (let i = 0; i < collection.length; i++) {
              const collectionItem = collection[i];
              const filteredFields = collectionItem.properties.filteredFields;
              const matchList = [];

              for (let k = 0; k < filteredFields.length; k++) {
                const filteredField = filteredFields[k];

                for (let j = 0; j < filters.length; j++) {
                  const filter = filters[j];

                  if (filter.key === filteredField.key) {
                    switch (filter.type) {
                      case 'range':
                        if (filteredField.value >= filter.value[0] && filteredField.value <= filter.value[1]) {
                          matchList.push(1);
                        } else {
                          matchList.push(0);
                        }

                        break;

                      case 'true_false':
                        if (filter.value === 'yes' && filteredField.value === 'no') {
                          matchList.push(0);
                        } else if (filter.value === 'yes' && filteredField.value === 'yes') {
                          matchList.push(1);
                        }

                        break;

                      case 'multiselect':
                        if (filter.value.length > 0) {
                          for (let m = 0; m < filter.value.length; m++) {
                            const mValue = parseInt(filter.value[m]);

                            if (filteredField.value.includes(mValue)) {
                              matchList.push(1);
                            } else {
                              matchList.push(0);
                            }
                          }
                        }

                        break;
                    }
                  }
                }
              }

              if (!matchList.includes(0)) {
                filteredCollection.push(collection[i]);
              }
            }
          }

          collection = filteredCollection;
        }

        this.updateCounterSelectedFilters();
      }

      if (ignoredMarkersForFiltering.length > 0) {
        collection = [...collection, ...ignoredMarkersForFiltering, ...filtersIgnored];
      }
    }

    collection = this.filtrateFeaturesByCategoriesCategories(collection);
    return collection;
  }

  getSelectedFiltersNumber() {
    if (!this.mapProperties.storeLocatorFilters) return false;
    let filtersCounter = 0;
    $('#js-twer-filters').children().each((index, element) => {
      const $filter = $(element);
      const filterId = $filter.data('filter-id');

      if ($filter.hasClass('js-twer-filter-form-range')) {
        const startInput = parseInt($filter.find('.js-twer-filter-range-value-start').attr('min'));
        const endInput = parseInt($filter.find('.js-twer-filter-range-value-end').attr('max'));
        const $rangeSlider = $filter.find('.js-twer-slider');
        const sliderValues = $rangeSlider.slider('option', 'values');

        if (sliderValues[0] !== startInput || sliderValues[1] !== endInput) {
          filtersCounter++;
        }
      }

      if ($filter.hasClass('js-twer-filter-form-true-false')) {
        const checked = $filter.find('.js-twer-filter-true-false-checkbox').prop('checked');

        if (checked) {
          filtersCounter++;
        }
      }

      if ($filter.hasClass('js-twer-filter-form-multiselect')) {
        const selected = $filter.find('.js-twer-filter-multiselect').val();

        if (!lodash.isEmpty(selected)) {
          filtersCounter++;
        }
      }
    });
    return filtersCounter;
  }

  updateCounterSelectedFilters() {
    if (!this.mapProperties.storeLocatorFilters) return false;
    let filtersCounter = this.getSelectedFiltersNumber();
    const $counter = document.getElementsByClassName('twer-store-locator-filter-counter')[0];

    if (filtersCounter > 0) {
      $counter.closest('.twer-store-locator-filter__right-side').classList.remove('hide');
    } else {
      $counter.closest('.twer-store-locator-filter__right-side').classList.add('hide');
    }

    $counter.innerText = filtersCounter;
  }

  updateFiltrateResult(collection) {
    if (!this.mapProperties.storeLocatorFilters) return false;
    document.getElementById('js-twer-filter-results-counter').innerText = collection.length;
  }

  addRadius(coords, filtrate, filterChange) {
    if (allMarkers.length === 0) return false;

    if (this.isExtendedStoreLocatorEnabled()) {
      this.hideAllExtendedLocatorCards();
    }

    if ('unlim' === this.radius) {
      this.radius = 666;
    }

    this.radiusCoords = Object.values(coords);
    const searchRadius = this.makeRadius(this.radiusCoords, this.radius);
    TWER.map.getSource('search-radius').setData(searchRadius);
    let featuresInBuffer = this.spatialJoin(TWER.clusterData, searchRadius);
    let showFeatureCollection = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.featureCollection)(featuresInBuffer);
    let showFeatures = this.filtrateFeaturesByFiltres(showFeatureCollection.features, filtrate, filterChange);
    let showFeatures1 = [];
    TWER.storeLocatorDataDump = showFeatures;
    this.sortAllExtendedLocatorCardsByDistance();

    if (666 !== this.radius) {
      let markersMustShow = [];

      for (let j = 0; j < showFeatures.length; j++) {
        markersMustShow.push(showFeatures[j].properties.id);
      }

      for (let i = 0; i < TWER.markers.length; i++) {
        const markerId = TWER.markers[i].feature.properties.id;

        if (!markersMustShow.includes(markerId)) {
          TWER.closePopups([markerId]);
          TWER.markers[i].insideStoreLocator = false;
          TWER.markers[i].show = false;
          TWER.markers[i].element._element.style.display = 'none';

          if (this.isExtendedStoreLocatorEnabled()) {
            this.hideExtendedLocatorCard(markerId);
          }
        } else {
          TWER.markers[i].insideStoreLocator = true;
          TWER.markers[i].show = true;

          if (this.isMarkerInCluster(TWER.markers[i].feature.properties.id) && TWER.allowCluster) {
            TWER.markers[i].mustShowInCluster = true;
            TWER.markers[i].element._element.style.display = 'none';
          } else {
            TWER.markers[i].element._element.style.display = 'block';
          }

          if (this.isExtendedStoreLocatorEnabled()) {
            this.showExtendedLocatorCard(markerId);
          }
        }
      }

      if (TWER.markersIgnoredClusters.length > 0) {
        let localFeatures = {
          features: TWER.outClusterFeatures
        };
        let featuresInBuffer1 = this.spatialJoin(localFeatures, searchRadius);
        let showFeatureCollection1 = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.featureCollection)(featuresInBuffer1);
        showFeatures1 = this.filtrateFeaturesByFiltres(showFeatureCollection1.features, filtrate, filterChange);
        let markersMustShow5 = [];

        for (let j = 0; j < showFeatures1.length; j++) {
          markersMustShow5.push(showFeatures1[j].properties.id);
        }

        for (let i = 0; i < TWER.markersIgnoredClusters.length; i++) {
          const markerId = TWER.markersIgnoredClusters[i].feature.properties.id;

          if (!markersMustShow5.includes(markerId)) {
            TWER.closePopups([markerId]);
            TWER.markersIgnoredClusters[i].insideStoreLocator = false;
            TWER.markersIgnoredClusters[i].show = false;
            TWER.markersIgnoredClusters[i].element._element.style.display = 'none';

            if (this.isExtendedStoreLocatorEnabled()) {
              this.hideExtendedLocatorCard(markerId);
            }
          } else {
            TWER.markersIgnoredClusters[i].insideStoreLocator = true;
            TWER.markersIgnoredClusters[i].show = true;
            TWER.markersIgnoredClusters[i].element._element.style.display = 'block';

            if (this.isExtendedStoreLocatorEnabled()) {
              this.showExtendedLocatorCard(markerId);
            }
          }
        }
      }

      let counterColection = showFeatures;

      if (TWER.markersIgnoredClusters.length > 0) {
        counterColection = [...showFeatures, ...showFeatures1];
      }

      if (this.mapProperties.storeLocatorType === 'extended') {
        this.updateFiltrateResult(counterColection);
      }

      TWER.map.getSource('locations').setData({
        'type': 'FeatureCollection',
        'features': showFeatures
      });
    } else {
      if (filtrate === 'yes') {
        let showFeaturesUnlim = this.filtrateFeaturesByFiltres(TWER.clusterData.features, filtrate, filterChange);
        let showFeaturesUnlim4 = [];
        TWER.storeLocatorDataDump = showFeaturesUnlim;
        let markersMustShow1 = [];

        for (let j = 0; j < showFeaturesUnlim.length; j++) {
          markersMustShow1.push(showFeaturesUnlim[j].properties.id);
        }

        for (let i = 0; i < TWER.markers.length; i++) {
          const markerId = TWER.markers[i].feature.properties.id;

          if (markersMustShow1.includes(markerId)) {
            TWER.markers[i].insideStoreLocator = true;
            TWER.markers[i].show = true;

            if (this.isMarkerInCluster(TWER.markers[i].feature.properties.id) && TWER.allowCluster) {
              TWER.markers[i].mustShowInCluster = true;
              TWER.markers[i].element._element.style.display = 'none';
            } else {
              TWER.markers[i].element._element.style.display = 'block';
            }

            if (this.isExtendedStoreLocatorEnabled()) {
              this.showExtendedLocatorCard(markerId);
            }
          } else {
            TWER.closePopups([markerId]);
            TWER.markers[i].insideStoreLocator = false;
            TWER.markers[i].show = false;
            TWER.markers[i].element._element.style.display = 'none';

            if (this.isExtendedStoreLocatorEnabled()) {
              this.hideExtendedLocatorCard(markerId);
            }
          }
        }

        if (TWER.markersIgnoredClusters.length > 0) {
          showFeaturesUnlim4 = this.filtrateFeaturesByFiltres(TWER.outClusterFeatures, filtrate, filterChange);
          let markersMustShow4 = [];

          for (let j = 0; j < showFeaturesUnlim4.length; j++) {
            markersMustShow4.push(showFeaturesUnlim4[j].properties.id);
          }

          for (let i = 0; i < TWER.markersIgnoredClusters.length; i++) {
            const markerId = TWER.markersIgnoredClusters[i].feature.properties.id;

            if (!markersMustShow4.includes(markerId)) {
              TWER.closePopups([markerId]);
              TWER.markersIgnoredClusters[i].insideStoreLocator = false;
              TWER.markersIgnoredClusters[i].show = false;
              TWER.markersIgnoredClusters[i].element._element.style.display = 'none';

              if (this.isExtendedStoreLocatorEnabled()) {
                this.hideExtendedLocatorCard(markerId);
              }
            } else {
              TWER.markersIgnoredClusters[i].insideStoreLocator = true;
              TWER.markersIgnoredClusters[i].show = true;
              TWER.markersIgnoredClusters[i].element._element.style.display = 'block';

              if (this.isExtendedStoreLocatorEnabled()) {
                this.showExtendedLocatorCard(markerId);
              }
            }
          }
        }

        let counterColection1 = showFeaturesUnlim;

        if (TWER.markersIgnoredClusters.length > 0) {
          counterColection1 = [...showFeaturesUnlim, ...showFeaturesUnlim4];
        }

        if (this.mapProperties.storeLocatorType === 'extended') {
          this.updateFiltrateResult(counterColection1);
        }

        TWER.map.getSource('locations').setData({
          'type': 'FeatureCollection',
          'features': showFeaturesUnlim
        });
      } else {
        let showFeaturesUnlim2 = this.filtrateFeaturesByFiltres(TWER.clusterData.features, filtrate, filterChange);
        let showFeaturesUnlim3 = [];
        TWER.storeLocatorDataDump = showFeaturesUnlim2;

        for (let i = 0; i < TWER.markers.length; i++) {
          TWER.markers[i].insideStoreLocator = true;
          TWER.markers[i].show = true;

          if (this.isMarkerInCluster(TWER.markers[i].feature.properties.id) && TWER.allowCluster) {
            TWER.markers[i].mustShowInCluster = true;
            TWER.markers[i].element._element.style.display = 'none';
          } else {
            TWER.markers[i].element._element.style.display = 'block';
          }

          if (this.isExtendedStoreLocatorEnabled()) {
            this.showExtendedLocatorCard(TWER.markers[i].feature.properties.id);
          }
        }

        if (TWER.markersIgnoredClusters.length > 0) {
          for (let i = 0; i < TWER.markersIgnoredClusters.length; i++) {
            TWER.markersIgnoredClusters[i].insideStoreLocator = true;
            TWER.markersIgnoredClusters[i].show = true;
            TWER.markersIgnoredClusters[i].element._element.style.display = 'block';

            if (this.isExtendedStoreLocatorEnabled()) {
              this.showExtendedLocatorCard(TWER.markersIgnoredClusters[i].feature.properties.id);
            }
          }

          showFeaturesUnlim3 = this.filtrateFeaturesByFiltres(TWER.outClusterFeatures, filtrate, filterChange);
        }

        let counterColection2 = showFeaturesUnlim2;

        if (TWER.markersIgnoredClusters.length > 0) {
          counterColection2 = [...showFeaturesUnlim2, ...showFeaturesUnlim3];
        }

        if (this.mapProperties.storeLocatorType === 'extended') {
          this.updateFiltrateResult(counterColection2);
        }

        TWER.map.getSource('locations').setData({
          'type': 'FeatureCollection',
          'features': showFeaturesUnlim2
        });
      }
    }

    if (this.isExtendedStoreLocatorEnabled()) {
      this.toggleExtendedStoreLocatorNoResultsMessage();
      this.initExtendedStoreLocatorMarkerHandlers();
    }
  }

  isMarkerInCluster(markerId) {
    return !this.getNonClusterIdFeatures().includes(markerId);
  }

  getNonClusterIdFeatures() {
    const featuresNotClusters = TWER.map.querySourceFeatures('locations', {
      filter: ['!', ['has', 'point_count']],
      sourceLayer: ['unclustered-point']
    });
    let featuresNotClustersIds = [];

    if (featuresNotClusters.length > 0) {
      for (let i = 0; i < featuresNotClusters.length; i++) {
        featuresNotClustersIds.push(featuresNotClusters[i].properties.id);
      }
    }

    return featuresNotClustersIds;
  }

  filtrateFeaturesByCategoriesCategories(collection) {
    const showUncategorized = this.mapProperties.showUncategorized;
    const uncategorizedId = this.mapProperties.uncategorizedId;
    let $categorySwitcher = $('#mapCatField');

    if ($categorySwitcher.length > 0) {} else {
      $categorySwitcher = $('#field-categories');
    }

    if ($categorySwitcher.length > 0) {
      let selectedCategories = $categorySwitcher.val();
      const filteredCollectionByCategory = [];
      const filteredCollection = [];

      if (showUncategorized === 'no') {
        selectedCategories.push(uncategorizedId);
      }

      if (selectedCategories.length > 0) {
        selectedCategories = selectedCategories.map(function (value) {
          return parseInt(value);
        });

        if (collection.length > 0) {
          for (let i = 0; i < collection.length; i++) {
            const categories = JSON.parse(collection[i].properties.cat_ids);

            if (selectedCategories.some(r => categories.includes(r))) {
              filteredCollection.push(collection[i]);
            }
          }

          collection = filteredCollection;
        }
      } else {
        collection = [];
      }
    }

    return collection;
  }

  sortAllExtendedLocatorCardsByDistance() {
    if (this.mapProperties.storeLocatorType === 'extended') {
      const distanceStartPoint = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.point)(this.radiusCoords);
      const allDistances = {};
      let allMarkers = TWER.markers;

      if (TWER.markersIgnoredClusters.length > 0) {
        allMarkers = [...allMarkers, ...TWER.markersIgnoredClusters];
      }

      for (let i = 0; i < allMarkers.length; i++) {
        const markerEndPoint = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.point)(allMarkers[i].feature.geometry.coordinates);
        const markerId = allMarkers[i].feature.properties.id;
        const distanceF = (0,_turf_distance__WEBPACK_IMPORTED_MODULE_3__["default"])(distanceStartPoint, markerEndPoint, {
          units: this.radiusDistance
        });
        allDistances[`marker-id-${markerId}`] = distanceF;
      }

      const sorted = Object.entries(allDistances).sort((_ref, _ref2) => {
        let [, a] = _ref;
        let [, b] = _ref2;
        return a - b;
      }).reduce((r, _ref3) => {
        let [k, v] = _ref3;
        return { ...r,
          [k]: v
        };
      }, {});

      for (const [key, value] of Object.entries(sorted)) {
        const $card = this.storeLocatorCardsOutputArea.getElementsByClassName(`twer-store-locator-card--${key}`);

        if ($card.length > 0) {
          this.storeLocatorCardsOutputArea.appendChild($card[0]);
        }
      }
    }
  }

  toggleExtendedStoreLocatorNoResultsMessage() {
    if (this.isExtendedStoreLocatorCardEmptyOutputAreaEmpty()) {
      this.noResultMessageBlock.classList.remove('hide');
    } else {
      this.noResultMessageBlock.classList.add('hide');
    }
  }

  isExtendedStoreLocatorCardEmptyOutputAreaEmpty() {
    const $cards = this.storeLocatorCardsOutputArea.getElementsByClassName('twer-store-locator-card');
    const totalCards = $cards.length;
    let totalHiddenCards = 0;

    for (let i = 0; i < totalCards; i++) {
      if ($cards[i].classList.contains('hide')) {
        totalHiddenCards++;
      }
    }

    return totalCards === totalHiddenCards;
  }

  showExtendedLocatorCard(markerId) {
    let isDetailCard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const $areaOutput = isDetailCard ? this.storeLocatorCardDetailOutputArea : this.storeLocatorCardsOutputArea;
    const $card = $areaOutput.getElementsByClassName(`twer-store-locator-card--marker-id-${markerId}`);

    if ($card.length > 0) {
      $card[0].classList.remove('hide');
    }
  }

  hideExtendedLocatorCard(markerId) {
    let isDetailCard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const $areaOutput = isDetailCard ? this.storeLocatorCardDetailOutputArea : this.storeLocatorCardsOutputArea;
    const $card = $areaOutput.getElementsByClassName(`twer-store-locator-card--marker-id-${markerId}`);

    if ($card.length > 0) {
      $card[0].classList.add('hide');
    }
  }

  closeAllExtendedLocatorDetailsCards() {
    const $cards = this.storeLocatorCardDetailOutputArea.children;

    if ($cards.length > 0) {
      for (let i = 0; i < $cards.length; i++) {
        $cards[i].classList.add('hide');
      }
    }
  }

  hideStoreLocatorCardDetailArea() {
    this.storeLocatorCardDetailOutputArea.classList.add('hide');
  }

  showStoreLocatorCardDetailArea() {
    this.storeLocatorCardDetailOutputArea.classList.remove('hide');
  }

  isExtendedStoreLocatorCardEmpty(markerDetails) {
    let cardIsEmpty = false;

    if (!markerDetails.hasImage) {
      cardIsEmpty = true;
    }

    return cardIsEmpty;
  }

  addStoreLocatorCardsFromMarker(marker) {
    if (marker.properties.hideInLocator !== 'no') return;
    const $baseCard = this.buildDefaultCard(marker);
    this.storeLocatorCardsOutputArea.appendChild($baseCard);
    const $detailCard = this.buildDetailCard(marker);
    this.storeLocatorCardDetailOutputArea.appendChild($detailCard);
  }

  isTargetLink(target) {
    return target.tagName.toLowerCase() === 'a';
  }

  isLinkFromCustomField(target) {
    return this.isTargetLink(target) && target.closest('.js-twer-custom-field') !== null;
  }

  initExtendedStoreLocatorCardsHandlers() {
    const $cards = this.storeLocatorCardsOutputArea.getElementsByClassName('js-twer-store-locator-card');

    if ($cards.length > 0) {
      for (let i = 0; i < $cards.length; i++) {
        const $cardAreaElement = $cards[i];
        $cardAreaElement.addEventListener('click', event => {
          if (this.isLinkFromCustomField(event.target)) {
            return false;
          }

          event.preventDefault();
          const $card = event.target.closest('.js-twer-store-locator-card');
          const cardStyle = $card.currentStyle || window.getComputedStyle($card);
          const cardsOutputAreaStyle = this.storeLocatorCardsOutputArea.currentStyle || window.getComputedStyle(this.storeLocatorCardsOutputArea);
          const storeLocatorHeaderStyle = this.storeLocatorHeader.currentStyle || window.getComputedStyle(this.storeLocatorHeader);
          const markerId = parseInt($card.dataset.markerId);
          const coordinates = JSON.parse($card.dataset.coordinates);
          const markerClickOffset = JSON.parse($card.dataset.markerClickOffset);
          const cardClickEvent = this.mapProperties.storeLocatorCardClickEvent;

          if ('focus_on_card' === cardClickEvent) {
            this.storeLocatorCardsOutputArea.scrollTo({
              top: $card.offsetTop + parseInt(cardStyle.paddingTop) - (parseInt(storeLocatorHeaderStyle.height) + parseInt(cardsOutputAreaStyle.paddingTop)),
              behavior: 'smooth'
            });
          } else if ('marker_details' === cardClickEvent) {
            this.storeLocatorCardDetailOutputArea.classList.remove('hide');
            this.showExtendedLocatorCard(markerId, true);
          }

          const flyOption = {
            center: coordinates,
            padding: {
              top: markerClickOffset.top,
              bottom: markerClickOffset.bottom,
              left: markerClickOffset.left,
              right: markerClickOffset.right
            }
          };

          if (this.mapProperties.storeLocatorZoomOnClick !== '') {
            flyOption.zoom = this.mapProperties.storeLocatorZoomOnClick;
          }

          TWER.map.flyTo(flyOption);
          const $markerPopup = document.getElementsByClassName(`twer-popup-id-${markerId}`);
          let isMarkerHasOpenPopup = $markerPopup.length > 0;

          if (!isMarkerHasOpenPopup) {
            if (this.mapProperties.storeLocatorZoomOnClick === '') {
              TWER.closePopups();
              TWER.closeTourPopup();
              let isVisibleMarker = false;

              if (TWER.markers.length > 0) {
                for (let i = 0; i < TWER.markers.length; i++) {
                  let createdMarkerId = parseInt(TWER.markers[i].feature.properties.id);

                  if (markerId === createdMarkerId) {
                    isVisibleMarker = TWER.markers[i].show;
                  }
                }
              }

              if (TWER.markersIgnoredClusters.length > 0) {
                for (let i = 0; i < TWER.markersIgnoredClusters.length; i++) {
                  let createdMarkerId = parseInt(TWER.markersIgnoredClusters[i].feature.properties.id);

                  if (markerId === createdMarkerId) {
                    isVisibleMarker = TWER.markersIgnoredClusters[i].show;
                  }
                }
              }

              if (isVisibleMarker) {
                TWER.openPopup({
                  target: document.getElementById(`twer-popup-id-${markerId}`)
                }, coordinates);
              }
            } else {
              TWER.closePopups();
              TWER.closeTourPopup();
              TWER.tourInProgress = true;
              TWER.openPopup({
                target: document.getElementById(`twer-popup-id-${markerId}`)
              }, coordinates);
              setTimeout(function () {
                TWER.tourInProgress = false;
              }, 500);
            }
          }
        });
      }
    }
  }

  initExtendedStoreLocatorMarkerHandlers() {
    let allMarkers = TWER.markers;

    if (TWER.markersIgnoredClusters.length > 0) {
      allMarkers = [...allMarkers, ...TWER.markersIgnoredClusters];
    }

    if (allMarkers.length > 0) {
      for (let i = 0; i < allMarkers.length; i++) {
        const markerObj = allMarkers[i];
        const $marker = markerObj.element;
        const markerId = markerObj.feature.properties.id;
        const hideInLocator = markerObj.feature.properties.hideInLocator;
        if (hideInLocator) continue;

        $marker._element.addEventListener('click', event => {
          event.preventDefault();
          const markerClickEvent = this.mapProperties.storeLocatorMarkerClickEvent;
          this.closeAllExtendedLocatorDetailsCards();

          if ('focus_on_card' === markerClickEvent) {
            this.hideStoreLocatorCardDetailArea();
            const $card = this.storeLocatorCardsOutputArea.getElementsByClassName(`twer-store-locator-card--marker-id-${markerId}`);

            if ($card.length > 0) {
              const cardStyle = $card[0].currentStyle || window.getComputedStyle($card[0]);
              const cardsOutputAreaStyle = this.storeLocatorCardsOutputArea.currentStyle || window.getComputedStyle(this.storeLocatorCardsOutputArea);
              const storeLocatorHeaderStyle = this.storeLocatorHeader.currentStyle || window.getComputedStyle(this.storeLocatorHeader);
              this.storeLocatorCardsOutputArea.scrollTo({
                top: $card[0].offsetTop + parseInt(cardStyle.paddingTop) - (parseInt(storeLocatorHeaderStyle.height) + parseInt(cardsOutputAreaStyle.paddingTop)),
                behavior: 'smooth'
              });
            }
          } else if ('marker_details' === markerClickEvent) {
            this.showStoreLocatorCardDetailArea();
            this.showExtendedLocatorCard(markerId, true);
          }

          if (markerObj.feature.properties.allowMarkerCenterOnClick) {
            TWER.map.flyTo({
              center: markerObj.feature.geometry.coordinates,
              padding: {
                top: markerObj.feature.properties.markerClickOffset.top,
                bottom: markerObj.feature.properties.markerClickOffset.bottom,
                left: markerObj.feature.properties.markerClickOffset.left,
                right: markerObj.feature.properties.markerClickOffset.right
              }
            });
          }

          const $markerPopup = document.getElementsByClassName(`twer-popup-id-${markerId}`);
          let isMarkerHasOpenPopup = $markerPopup.length > 0;

          if (!isMarkerHasOpenPopup) {
            TWER.openPopup({
              target: $marker._element
            }, markerObj.feature.geometry.coordinates);
          }
        });
      }
    }
  }

  initExtendedStoreLocatorDetailsCardsHandlers() {
    const $cards = this.storeLocatorCardDetailOutputArea.getElementsByClassName('js-twer-store-locator-card');

    if ($cards.length > 0) {
      for (let i = 0; i < $cards.length; i++) {
        const $cardAreaElement = $cards[i];
        const $closeButton = $cardAreaElement.getElementsByClassName('js-twer-store-locator-card-close')[0];
        $closeButton.addEventListener('click', event => {
          event.preventDefault();
          const $card = event.target.closest('.js-twer-store-locator-card');
          const id = parseInt($card.dataset.markerId);
          this.storeLocatorCardDetailOutputArea.classList.add('hide');
          this.hideExtendedLocatorCard(id, true);
        });
      }
    }
  }

  buildDetailCard(marker) {
    const markerId = marker.properties.markerId;
    const $card = this.buildBaseCard(marker);
    const locatorCustomFields = marker.properties.customFields.locatorCustomFields;
    $card.firstElementChild.classList.add(`twer-store-locator-card--detail`);
    const {
      hasGallery
    } = marker.properties;

    if (hasGallery) {
      const $galleryFeatureImageLink = $card.querySelector('.js-twer-store-locator-gallery-feature-image-link');
      $galleryFeatureImageLink.classList.remove('no-event');
      $galleryFeatureImageLink.dataset.fancybox = `gallery-card-${markerId}`;
      const $galleryList = $card.querySelector('.js-twer-store-locator-gallery-list');
      const $galleryListItems = $galleryList.children;

      for (let i = 0; i < $galleryListItems.length; i++) {
        const $galleryListItem = $galleryListItems[i];
        $galleryListItem.dataset.fancybox = `gallery-card-${markerId}`;
      }
    }

    if (locatorCustomFields.length > 0) {
      for (let i = 0; i < locatorCustomFields.length; i++) {
        const customField = locatorCustomFields[i];
        $card.querySelector('.js-twer-store-locator-custom-fields').appendChild(this.buildCustomField(customField));
      }
    }

    return $card;
  }

  buildDefaultCard(marker) {
    const $card = this.buildBaseCard(marker);
    const locatorPreviewCustomFields = marker.properties.customFields.locatorPreviewCustomFields;

    if (locatorPreviewCustomFields.length > 0) {
      for (let i = 0; i < locatorPreviewCustomFields.length; i++) {
        const customField = locatorPreviewCustomFields[i];
        $card.querySelector('.js-twer-store-locator-custom-fields').appendChild(this.buildCustomField(customField));
      }
    }

    return $card;
  }

  buildCustomField(fieldData) {
    const {
      id,
      type,
      name,
      showName,
      value
    } = fieldData;
    let $field = null;

    switch (type) {
      case 'number':
        $field = document.importNode(this.customFieldNumber, true);

        for (const [attrName, attrValue] of Object.entries(fieldData.atts)) {
          if ('data-name-width' === attrName) {
            const $fieldName = $field.querySelector('.js-twer-custom-field-name');
            $fieldName.style.maxWidth = `${attrValue}%`;
            $fieldName.style.flex = `0 0 ${attrValue}%`;
          } else {
            $field.setAttribute(attrName, attrValue);
          }
        }

        $field.querySelector('.js-twer-custom-field-number-value').innerText = value;
        break;

      case 'multiselect':
        $field = document.importNode(this.customFieldMultiselect, true);
        const $list = $field.querySelector('.js-twer-custom-field-multiselect-list');
        const $tag = $field.querySelector('.js-twer-custom-field-multiselect-item');
        const $multiselectField = $field.querySelector('.twer-custom-field-multiselect');

        for (const [attrName, attrValue] of Object.entries(fieldData.atts)) {
          $multiselectField.setAttribute(attrName, attrValue);
        }

        if (value.length > 0) {
          for (let i = 0; i < value.length; i++) {
            const $clonedTag = $tag.cloneNode();
            $clonedTag.innerHTML = value[i];
            $list.appendChild($clonedTag);
          }
        }

        $list.style.justifyContent = fieldData.align;
        $tag.remove();
        break;

      case 'category':
        $field = document.importNode(this.customFieldCategory, true);
        const $categoryList = $field.querySelector('.js-twer-custom-field-category-list');
        const $categoryTag = $field.querySelector('.js-twer-custom-field-category-item');
        const $categoryValue = $field.querySelector('.js-twer-custom-field-category-value');
        const $categoryField = $field.querySelector('.js-twer-custom-field-category');

        for (const [attrName, attrValue] of Object.entries(fieldData.atts)) {
          $categoryField.setAttribute(attrName, attrValue);
        }

        const outputType = fieldData.outputType;

        if (outputType === 'tags') {
          if (value.length > 0) {
            for (let i = 0; i < value.length; i++) {
              const $clonedTag = $categoryTag.cloneNode();
              $clonedTag.innerHTML = value[i];
              $categoryList.appendChild($clonedTag);
            }
          }

          $categoryTag.remove();
          $categoryList.style.justifyContent = fieldData.align;
        } else {
          $categoryField.classList.add('twer-custom-field-category--as-text');
          $categoryValue.innerHTML = value;
        }

        break;

      case 'line':
        $field = document.importNode(this.customFieldLine, true);
        const $line = $field.querySelector('.js-twer-custom-field-line');

        for (const [attrName, attrValue] of Object.entries(value)) {
          $line.setAttribute(attrName, attrValue);
        }

        break;

      case 'link-universal':
        const subtype = fieldData.subtype;
        $field = document.importNode(this.customFieldLink, true);
        const $link = $field.querySelector('.js-twer-custom-field-link');

        for (const [attrName, attrValue] of Object.entries(fieldData.atts)) {
          if ('data-align' === attrName) {
            $field.querySelector('.js-twer-custom-field-value').style.textAlign = attrValue;
          } else if ('data-name-width' === attrName) {
            const $fieldName = $field.querySelector('.js-twer-custom-field-name');
            $fieldName.style.maxWidth = `${attrValue}%`;
            $fieldName.style.flex = `0 0 ${attrValue}%`;
          } else {
            $link.setAttribute(attrName, attrValue);
          }
        }

        if (document.body.classList.contains('twer-page-iframe-map') && !$link.hasAttribute('target')) {
          $link.setAttribute('target', '_parent');
        }

        $link.innerHTML = value;
        $link.classList.replace('twer-custom-field-link', `twer-custom-field-${subtype}`);
        break;

      case 'text':
        $field = document.importNode(this.customFieldText, true);
        const $text = $field.querySelector('.js-twer-custom-field-text');

        for (const [attrName, attrValue] of Object.entries(fieldData.atts)) {
          if ('data-name-width' === attrName) {
            const $fieldName = $field.querySelector('.js-twer-custom-field-name');
            $fieldName.style.maxWidth = `${attrValue}%`;
            $fieldName.style.flex = `0 0 ${attrValue}%`;
          } else {
            $text.setAttribute(attrName, attrValue);
          }
        }

        const showAsTitle = fieldData.showAsTitle;

        if ('yes' === showAsTitle) {
          $text.classList.add('twer-custom-field-text--as-title');
        }

        $field.querySelector('.js-twer-custom-field-text-value').innerHTML = value;
        break;

      case 'html':
        $field = document.importNode(this.customFieldHTML, true);
        const $html = $field.querySelector('.js-twer-custom-field-html');

        for (const [attrName, attrValue] of Object.entries(fieldData.atts)) {
          $html.setAttribute(attrName, attrValue);
        }

        $field.querySelector('.js-twer-custom-field-html-value').innerHTML = value;
        const $links = $field.querySelectorAll('.js-twer-custom-field-html-value a');

        if ($links.length > 0) {
          $links.forEach(($link, index) => {
            if (document.body.classList.contains('twer-page-iframe-map') && !$link.hasAttribute('target')) {
              $link.setAttribute('target', '_parent');
            }
          });
        }

        break;

      case 'separator':
        $field = document.importNode(this.customFieldSeparator, true);
        const $separator = $field.querySelector('.js-twer-custom-field-separator');

        for (const [attrName, attrValue] of Object.entries(value)) {
          $separator.setAttribute(attrName, attrValue);
        }

        break;

      case 'true_false':
        $field = document.importNode(this.customFieldTrueFalse, true);

        if (value === 'yes') {
          const $trueFalse = $field.querySelector('.js-twer-custom-field-true-false-value');
          $trueFalse.classList.add('twer-custom-field-true-false__value--checked');
        }

        break;
    }

    if ($field !== null) {
      const $fieldName = $field.querySelector('.js-twer-custom-field-name');
      $field.querySelector('.js-twer-custom-field').setAttribute('data-id', id);

      if ($fieldName !== null) {
        if (showName === 'no') {
          $field.querySelector('.js-twer-custom-field').classList.add('twer-custom-field--one-col');
          $fieldName.remove();
        } else {
          $fieldName.innerHTML = name;
        }
      }
    }

    return $field;
  }

  buildBaseCard(marker) {
    const markerId = marker.properties.markerId;
    const {
      hasGallery,
      hasImage,
      imageTotalNumber,
      imageUrl,
      imageCaption,
      gallery,
      imagePlace
    } = marker.properties;
    let $card = document.importNode(this.simpleCardDocumentFragment, true);

    if (hasGallery) {
      $card = document.importNode(this.galleryCardDocumentFragment, true);
      const $galleryFeatureImage = $card.querySelector('.js-twer-store-locator-image');
      const $galleryFeatureImageLink = $card.querySelector('.js-twer-store-locator-gallery-feature-image-link');
      $galleryFeatureImage.src = $galleryFeatureImageLink.href = imageUrl;
      $galleryFeatureImage.alt = $galleryFeatureImageLink.dataset.caption = imageCaption;
      $galleryFeatureImageLink.dataset.place = imagePlace;
      $card.querySelector('.js-twer-store-locator-indicate').innerText = imageTotalNumber;

      if (gallery.length > 0) {
        for (let i = 0; i < gallery.length; i++) {
          const galleryItem = gallery[i];
          let $galleryImage = document.createElement('img');
          let $galleryLink = document.createElement('a');
          $galleryLink.href = $galleryImage.src = galleryItem['url'];
          $galleryLink.dataset.caption = $galleryImage.alt = galleryItem['caption'];
          $galleryLink.dataset.place = galleryItem['place'];
          $galleryLink.appendChild($galleryImage);
          $card.querySelector('.js-twer-store-locator-gallery-list').appendChild($galleryLink);
        }
      }
    } else if (hasImage) {
      $card = document.importNode(this.imageCardDocumentFragment, true);
      $card.querySelector('.js-twer-store-locator-image').src = imageUrl;
      $card.querySelector('.js-twer-store-locator-image').alt = imageCaption;
    }

    $card.firstElementChild.classList.add(`twer-store-locator-card--marker-id-` + markerId);
    const coordinates = marker.geometry.coordinates;
    $card.firstElementChild.dataset.coordinates = JSON.stringify(coordinates);
    $card.firstElementChild.dataset.markerId = markerId;
    $card.firstElementChild.dataset.markerClickOffset = JSON.stringify(marker.properties.markerClickOffset);
    return $card;
  }

  refreshRadius(radius, filtrate, filterChange) {
    this.radius = radius === 'unlim' ? radius.toString() : parseInt(radius);
    this.addRadius(this.radiusCoords, filtrate, filterChange);
  }

  makeRadius(lngLatArray, radiusInMeters) {
    var pointt = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_4__.point)(lngLatArray);
    var buffered = (0,_turf_buffer__WEBPACK_IMPORTED_MODULE_2__["default"])(pointt, radiusInMeters, {
      units: this.radiusDistance
    });
    return buffered;
  }

  addMarker(props, coords) {
    const markerElement = this.createNewMarker(props, coords, '');
    TWER.markerLocation = new mapboxgl.Marker(markerElement).setLngLat(coords).addTo(TWER.map);
  }

  removeMarker() {
    TWER.markerLocation.remove();
  }

  createNewMarker(props, coords, desc) {
    const markerElement = document.createElement('div');

    if (props.marker_style === 'default') {
      markerElement.innerHTML = `<div class="treweler-marker"><div class="marker">
                 <div class="marker-wrap">
                 <div class="marker__shadow" style="background-color:${TWER.hex2rgba(props.point_halo_color, props.point_halo_opacity)}">
                 <div class="marker__border" style="border-color:${props.point_color};">
                 <div class="marker__center"></div>
                 </div>
                 </div>
                 </div>
                 </div></div>`;
    } else if ('dot-default' === props.marker_style) {
      let iconHtml = '';

      if (props.dot_icon_picker.length > 0 && props.dot_icon_show > 0) {
        iconHtml = `<span class="marker-dot__icon material-icons" style="color:${props.dot_icon.color};font-size:${props.dot_icon.size}px;">${props.dot_icon_picker}</span>`;
      }

      markerElement.innerHTML = `<div class="treweler-marker" style="width:${props.dot.size}px;height:${props.dot.size}px;border-radius:${props.dot_corner_radius.size}${props.dot_corner_radius.units};border:${props.dot_border.size}px solid ${props.dot_border.color};background-color:${props.dot.color};">${iconHtml}</div>`;
    } else if ('triangle-default' === props.marker_style) {
      const styleTriangle = `
                        border-right-width:${props.triangle_width / 2}px;
                        border-left-width:${props.triangle_width / 2}px;
                        border-bottom-width: ${props.triangle_height}px;
                        border-bottom-color: ${props.triangle_color};
                        `;
      markerElement.innerHTML = `<div data-height="${props.triangle_height}" class="treweler-marker marker-triangle" style="${styleTriangle}"></div>`;
    } else if ('balloon-default' === props.marker_style) {
      const realMarkerSizeBalloon = props.balloon.size + (props.balloon_border.size + props.balloon_border.size);
      const x = (realMarkerSizeBalloon + realMarkerSizeBalloon - Math.sqrt(Math.pow(realMarkerSizeBalloon, 2) + Math.pow(realMarkerSizeBalloon, 2))) * (Math.sqrt(2) - 1) / 2;
      let styleBalloon = `
                        background-color: ${props.balloon.color};    
                        border: ${props.balloon_border.size}px solid ${props.balloon_border.color};
                        bottom:${x + x}px;                        
                        width: ${props.balloon.size}px;
                        height: ${props.balloon.size}px;`;
      let styleBalloonDot = `
                        width:${props.balloon_dot.size}px;
                        height:${props.balloon_dot.size}px;
                        margin-left:${props.balloon_dot.size / 2 * -1}px;
                        margin-top:${props.balloon_dot.size / 2 * -1}px;
                        background-color:${props.balloon_dot.color};
                        `;
      let iconHtml = '';

      if (props.balloon_icon_picker.length > 0 && props.balloon_icon_show > 0) {
        iconHtml = `<span class="marker-balloon__icon material-icons" style="color:${props.balloon_icon.color};font-size:${props.balloon_icon.size}px;">${props.balloon_icon_picker}</span>`;
      }

      markerElement.innerHTML = `<div data-width="${props.balloon.size}" data-height="${realMarkerSizeBalloon + x + x}" class="treweler-marker marker-svg"><div class="marker-balloon" style="${styleBalloon}"><div class="marker-balloon__dot" style="${styleBalloonDot}">${iconHtml}</div></div></div>`;
      props.anchor = 'bottom';
    } else if ('custom' === props.marker_style) {
      const size = props.custom_marker_size_default !== '' ? props.custom_marker_size_default.split(';') : '42;42'.split(';');
      markerElement.className = 'treweler-marker icon';
      markerElement.style.backgroundImage = `url('${props.custom_marker_img}')`;
      markerElement.style.backgroundSize = 'contain';
      markerElement.style.backgroundRepeat = 'no-repeat';
      markerElement.style.backgroundPosition = 'center center';
      const width = parseInt(size[1]) <= 42 ? parseInt(size[1]) % 2 === 0 ? parseInt(size[1]) : parseInt(size[1]) + 1 : 42;
      const height = parseInt(size[0]) <= 42 ? parseInt(size[0]) % 2 === 0 ? parseInt(size[0]) : parseInt(size[0]) + 1 : 42;
      const finalWidth = parseInt(props.custom_marker_size) > 1 ? parseInt(props.custom_marker_size) : width;
      const finalHeight = parseInt(props.custom_marker_size) > 1 ? parseInt(props.custom_marker_size) : height;
      markerElement.style.width = `${finalWidth}px`;
      markerElement.style.height = `${finalHeight}px`;
      props.anchor = props.custom_marker_position;
    } else {
      markerElement.innerHTML = `<div class="treweler-marker"><div class="marker">
                 <div class="marker-wrap">
                 <div class="marker__shadow" style="background-color:${TWER.hex2rgba(props.point_halo_color, props.point_halo_opacity)}">
                 <div class="marker__border" style="border-color:${props.point_color};">
                 <div class="marker__center"></div>
                 </div>
                 </div>
                 </div>
                 </div></div>`;
      props.anchor = 'center';
    }

    markerElement.classList.add(`js-twer-marker`);
    markerElement.setAttribute('id', `twer-popup-id-${props.id}`); // Add marker style class

    markerElement.classList.add(`twer-cursor-${props.cursor}`); // Add type of marker

    markerElement.classList.add(`twer-marker-type--${props.marker_style}`);
    return {
      element: markerElement,
      anchor: props.anchor
    };
  }

}

!(() => {
  window.addEventListener('load', () => {
    const locator = new TWER_STORE_LOCATOR(window.TWER.data);
  });
})();
}();
/******/ })()
;
//# sourceMappingURL=treweler-store-locator.js.map